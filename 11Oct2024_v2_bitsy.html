<!DOCTYPE HTML>
<html>

<!-- HEADER -->
<head>

<meta charset="UTF-8">

<title></title>

<script type="text/bitsyGameData" id="exportedGameData">


# BITSY VERSION 8.12

! VER_MAJ 8
! VER_MIN 12
! ROOM_FORMAT 1
! DLG_COMPAT 0
! TXT_MODE 0

PAL 0
24,36,85
249,249,249
255,255,255
NAME blueprint

PAL 1
0,0,0
254,47,57
254,47,57
NAME Rm2 Color

PAL 2
103,138,254
253,233,204
255,183,217

PAL 3
255,224,161
102,55,255
255,224,161

PAL 4
65,160,238
235,253,245
235,253,245
NAME ClinicColor

PAL 5
255,240,251
105,104,197
255,240,251
NAME Props

PAL 6
132,103,207
255,255,255
255,255,255
NAME Say

ROOM 0
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
NAME example room
PAL 0

ROOM 1
a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a
a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
0,0,0,m,n,l,f,0,0,0,0,0,0,0,0,0
0,0,0,d,p,k,g,0,0,1g,1f,1j,0,0,0,0
0,0,0,d,p,k,g,1m,1k,1h,1e,19,1c,0,0,0
0,0,0,e,p,k,h,1n,1l,1i,1d,1a,1b,0,0,0
0,0,0,q,o,j,i,0,1o,r,s,15,1z,0,6y,6y
yy3a,yy3a,yy3a,yy3a,yy3a,yy3a,yy3a,yy3a,14,13,w,16,1v,yy3a,25,26
0,0,0,0,0,0,0,0,y,12,v,17,1w,0,23,24
0,0,1q,1p,1r,21,0,0,z,10,11,18,6z,1y,0,2k
0,1u,1t,1t,1s,22,0,0,0,0,0,0,70,cl2y,0,2k
a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a
a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a
a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a
NAME Marie room (Rm1)
ITM 1_0 3,11
ITM 1_2 4,11
ITM 1_5 14,9
ITM 1_6 13,10
ITM 1_4 13,12
ITM 1_3 12,12
EXT 12,12 a 12,12
PAL 0

ROOM 2
a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a
a,2i,2i,2i,2i,2i,2i,2i,2i,2i,2i,2i,2i,2i,2b,a
a,2i,2a,2a,2a,2a,2a,2a,2a,2a,2a,2a,2a,2b,2i,a
a,2i,2a,2d,2c,2c,2c,2c,2c,2c,2c,2c,2c,2a,2i,a
a,2i,2a,2c,2f,2f,2f,2f,2f,2f,2f,2g,2c,2a,2i,a
a,2i,2a,2c,2f,2h,2h,2h,2h,2h,2h,2f,2c,2a,2i,a
a,2i,2a,2c,2f,2h,2i,2i,2i,2i,2h,2f,2c,2a,2i,a
a,2i,2a,2c,2f,2h,2i,2j,2j,2i,2h,2f,2c,2a,2i,a
a,2i,2a,2c,2f,2h,2i,2j,2j,2i,2h,2f,2c,2a,2i,a
a,2i,2a,2c,2f,2h,2i,2i,2i,2i,2h,2f,2c,2a,2i,a
a,2i,2a,2c,2f,2h,2h,2h,2h,2h,2h,2f,2c,2a,2i,a
a,2i,2a,2c,2g,2f,2f,2f,2f,2f,2f,2f,2c,2a,2i,a
a,2i,2a,2c,2c,2c,2c,2c,2c,2c,2c,2c,2e,2a,2i,a
a,2i,29,2a,2a,2a,2a,2a,2a,2a,2a,2a,2a,2a,2i,a
a,29,2i,2i,2i,2i,2i,2j,2j,2i,2i,2i,2i,2i,2i,a
a,a,a,a,a,a,2i,2j,2j,2i,a,a,a,a,a,a
NAME Hallucination (Rm2)
ITM d 5,5
ITM e 10,5
ITM f 10,10
ITM g 5,10
PAL 1

ROOM 3
CL1a,CL1a,CL1a,CL1a,CL1a,CL1a,CL1a,CL1a,CL1a,CL1a,CL1a,CL1a,CL1a,CL1a,CL1a,CL1a
CL1a,CL1a,CL1a,CL1a,CL1a,CL1a,CL1a,CL1a,CL1a,CL1a,CL1a,CL1a,CL1a,CL1a,CL1a,CL1a
0,0,0,0,0,0,0,0,0,0,0,CL14,CL14,0,0,0
0,CL2x,CL2x,CL2x,CL2x,0,0,CL2q,CL2t,CL2s,0,CL1g,CL1b,CL21,CL22,CL24
0,0,0,0,0,0,0,CL2r,CLy,CL2u,0,CL1f,CL1c,CL1w,CL1x,CL23
0,0,0,CL2b,CL2c,0,0,CL2r,CLx,CL2v,0,CL1e,CL1d,CL1v,CL2a,CL23
0,0,0,CLt,CL2d,0,CL16,CL17,CL18,CL2w,0,0,0,CL1v,CL1y,CL23
0,0,0,0,0,0,CL1q,0,CL1i,0,0,0,0,CL1v,CL2a,CL23
0,CL2g,CL2g,CL2g,CL2g,CL1m,CL2f,CL1o,CL1u,0,0,0,0,CL1v,CL1y,CL23
0,CL2h,CL2j,CL2k,CL2h,CL1j,CL2e,CL1l,CL1t,CLh,CLh,CL2p,0,CL1v,CL2a,CL23
0,0,CL2i,CL2l,CLi,CLi,CLi,CLi,CLi,CLi,CLj,0,0,CL1v,CL1y,CL23
0,CL2m,CL2g,CLi,CLi,CLi,CLi,CLi,CLi,CLj,CLo,0,0,CL20,CL1z,CL27
0,0,CL2o,0,0,0,0,CLo,0,0,CLo,0,0,0,0,0
CL1a,CL1a,CL1a,CL1a,CL1a,CL1a,CL1a,CL1a,CL1a,CL1a,CL1a,CL1a,CL1a,CL1a,CL1a,CL1a
CL1a,CL1a,CL1a,CL1a,CL1a,CL1a,CL1a,CL1a,CL1a,CL1a,CL1a,CL1a,CL1a,CL1a,CL1a,CL1a
CL1a,CL1a,CL1a,CL1a,CL1a,CL1a,CL1a,CL1a,CL1a,CL1a,CL1a,CL1a,CL1a,CL1a,CL1a,CL1a
NAME Clinic room (Rm3)
ITM rm3_records1 3,5
ITM rm3_records2 4,5
ITM rm3_records4 4,6
ITM rm3_records3 3,6
ITM rm8 1,8
ITM rm8 2,8
ITM rm8 3,8
ITM rm8 4,8
ITM rm9 1,9
ITM rm9 4,9
ITM rma 2,9
ITM rmb 3,9
ITM rmc 5,8
ITM rmd 6,8
ITM rme 7,8
ITM rmf 5,9
ITM rmg 6,9
ITM rmh 7,9
PAL 4

ROOM 4
a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a
a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
0,0,3k,3l,3m,0,30,31,31,31,32,0,0,0,0,0
0,0,3j,3q,3n,0,2y,3x,3y,3z,33,0,0,0,0,0
0,0,3i,3p,3o,6y,36,35,40,35,34,43,44,45,0,0
b,b,b,b,b,b,37,b,b,b,38,42,46,49,b,b
0,0,0,0,0,0,39,3a,3b,3c,3d,41,47,48,0,0
0,0,0,0,0,2n,2o,2r,3e,3f,2q,2s,0,0,0,0
0,0,0,0,0,2m,2l,2l,2l,2l,2p,3t,3u,0,0,0
0,0,0,0,0,2v,2u,0,3g,3h,2v,3s,3v,0,0,0
0,0,0,0,0,2w,0,0,0,0,2w,3r,3w,0,0,0
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a
a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a
a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a
NAME Journalists room (Rm4)
ITM 4_1 12,6
ITM 4_2 11,10
ITM 4_3 8,4
ITM 4_4 7,4
ITM 4_5 8,8
PAL 2

ROOM 5
a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a
a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a
a,a,a,a,a,0,0,0,0,0,0,a,a,a,a,a
a,a,a,a,a,0,0,0,0,0,0,a,a,a,a,a
a,a,a,a,a,0,0,0,0,0,0,a,a,a,a,a
a,a,a,a,a,5s,5s,5s,5s,5s,5s,a,a,a,a,a
a,0,0,0,5q,0,0,0,0,0,0,5r,0,0,0,a
a,0,0,0,5q,0,0,5v,5w,0,0,5r,0,0,0,a
a,0,0,0,5q,0,0,5t,5u,0,0,5r,0,0,0,a
a,0,0,0,5q,0,0,0,0,0,0,5r,0,0,0,a
a,a,a,a,a,0,0,0,0,0,0,a,a,a,a,a
a,a,a,a,a,0,0,0,0,0,0,a,a,a,a,a
a,a,a,a,a,0,0,0,0,0,0,a,a,a,a,a
a,a,a,a,a,0,0,0,0,0,0,a,a,a,a,a
a,a,a,a,a,a,a,0,0,a,a,a,a,a,a,a
a,a,a,a,a,a,a,0,0,a,a,a,a,a,a,a
NAME Museum (Rm5)
PAL 0

ROOM 6
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
0,0,0,0,0,0,0,6g,6h,0,0,0,0,0,0,0
0,0,0,0,0,64,65,6i,6j,65,66,0,0,0,0,0
0,0,0,0,0,60,61,62,63,61,62,0,0,0,0,0
0,0,6p,6k,0,5y,5x,5x,5x,5x,5z,0,6q,6u,0,0
0,6p,6m,6o,0,0,0,0,0,0,0,0,6s,6r,6u,0
0,6n,6o,6w,0,0,0,0,0,0,0,0,6x,6v,6t,0
0,0,0,6a,68,67,67,67,67,67,67,69,6b,0,0,0
0,0,0,6c,6e,0,0,0,0,0,0,6f,6d,0,0,0
0,0,0,6c,6e,0,0,0,0,0,0,6f,6d,0,0,0
0,0,0,6c,6e,0,0,0,0,0,0,6f,6d,0,0,0
0,0,0,6c,6e,0,0,0,0,0,0,6f,6d,0,0,0
a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a
a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a
NAME Hearing (Rm6)
PAL 3

ROOM 7
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
0,ty30,0,0,0,0,0,0,0,0,0,0,0,0,0,0
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
0,0,0,5n,5p,5p,5p,5p,5p,5p,5p,5p,5o,0,0,0
0,0,0,5l,0,0,0,0,0,0,0,0,5m,0,0,0
0,0,0,5j,5a,5b,5c,5d,5e,5f,5g,5h,5k,0,0,0
0,0,0,50,51,52,53,54,55,56,57,58,59,0,0,0
0,0,0,4q,4q,4q,4q,4q,4q,4q,4q,4q,4q,0,0,0
0,0,4r,4k,4k,4k,4k,4k,4k,4k,4k,4k,4k,4v,0,0
0,4s,4k,4k,4k,4k,4k,4k,4k,4k,4k,4k,4l,4m,4w,0
0,4t,0,4k,4k,4k,4k,4k,4k,4k,4k,4k,4k,0,4x,0
0,4u,4z,0,0,0,4n,4o,4p,0,0,0,0,4z,4y,0
0,4h,4j,4j,4j,4j,4j,4j,4j,4j,4j,4j,4j,4j,4i,0
a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
NAME Typewriter1 (Rm7_1)
PAL 0
AVA rm2extch

ROOM 8
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
0,ty30,ty31,ty32,0,0,0,0,0,0,0,0,0,0,0,0
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
0,0,0,5n,5p,5p,5p,5p,5p,5p,5p,5p,5o,0,0,0
0,0,0,5l,0,0,0,0,0,0,0,0,5m,0,0,0
0,0,0,5l,0,0,0,0,0,0,0,0,5m,0,0,0
0,0,0,5j,5a,5b,5c,5d,5e,5f,5g,5h,5k,0,0,0
0,0,0,50,51,52,53,54,55,56,57,58,59,0,0,0
0,0,0,4q,4q,4q,4q,4q,4q,4q,4q,4q,4q,0,0,0
0,0,4r,4k,4k,4k,4k,4k,4k,4k,4k,4k,4k,4v,0,0
0,4s,4k,4k,4k,4k,4k,4k,4k,4k,4k,4k,4l,4m,4w,0
0,4t,0,4k,4k,4k,4k,4k,4k,4k,4k,4k,4k,0,4x,0
0,4u,4z,0,0,0,4n,4o,4p,0,0,0,0,4z,4y,0
0,4h,4j,4j,4j,4j,4j,4j,4j,4j,4j,4j,4j,4j,4i,0
a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
NAME Typewriter1 (Rm7_2)
PAL 0
AVA rm2extch

ROOM 9
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
0,ty30,ty31,ty32,ty33,ty34,0,0,0,0,0,0,0,0,0,0
0,0,0,5n,5p,5p,5p,5p,5p,5p,5p,5p,5o,0,0,0
0,0,0,5l,0,0,0,0,0,0,0,0,5m,0,0,0
0,0,0,5l,0,0,0,0,0,0,0,0,5m,0,0,0
0,0,0,5l,0,0,0,0,0,0,0,0,5m,0,0,0
0,0,0,5j,5a,5b,5c,5d,5e,5f,5g,5h,5k,0,0,0
0,0,0,50,51,52,53,54,55,56,57,58,59,0,0,0
0,0,0,4q,4q,4q,4q,4q,4q,4q,4q,4q,4q,0,0,0
0,0,4r,4k,4k,4k,4k,4k,4k,4k,4k,4k,4k,4v,0,0
0,4s,4k,4k,4k,4k,4k,4k,4k,4k,4k,4k,4l,4m,4w,0
0,4t,0,4k,4k,4k,4k,4k,4k,4k,4k,4k,4k,0,4x,0
0,4u,4z,0,0,0,4n,4o,4p,0,0,0,0,4z,4y,0
0,4h,4j,4j,4j,4j,4j,4j,4j,4j,4j,4j,4j,4j,4i,0
a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a
yy3b,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
NAME Typewriter1 (Rm7_3)
PAL 0
AVA rm2extch

ROOM 10
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
0,ty30,ty31,ty32,ty33,ty34,ty35,ty36,ty37,0,0,0,0,0,0,0
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
0,0,0,5n,5p,5p,5p,5p,5p,5p,5p,5p,5o,0,0,0
0,0,0,5l,0,0,0,0,0,0,0,0,5m,0,0,0
0,0,0,5l,0,0,0,0,0,0,0,0,5m,0,0,0
0,0,0,5j,5a,5b,5c,5d,5e,5f,5g,5h,5k,0,0,0
0,0,0,50,51,52,53,54,55,56,57,58,59,0,0,0
0,0,0,4q,4q,4q,4q,4q,4q,4q,4q,4q,4q,0,0,0
0,0,4r,4k,4k,4k,4k,4k,4k,4k,4k,4k,4k,4v,0,0
0,4s,4k,4k,4k,4k,4k,4k,4k,4k,4k,4k,4l,4m,4w,0
0,4t,0,4k,4k,4k,4k,4k,4k,4k,4k,4k,4k,0,4x,0
0,4u,4z,0,0,0,4n,4o,4p,0,0,0,0,4z,4y,0
0,4h,4j,4j,4j,4j,4j,4j,4j,4j,4j,4j,4j,4j,4i,0
a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a
yy3b,yy3b,0,0,0,0,0,0,0,0,0,0,0,0,0,0
NAME Typewriter1 (Rm7_4)
PAL 0
AVA rm2extch

ROOM 11
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
0,ty30,ty31,ty32,ty33,ty34,ty35,ty36,ty37,ty38,ty39,0,0,0,0,0
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
0,0,0,5n,5p,5p,5p,5p,5p,5p,5p,5p,5o,0,0,0
0,0,0,5l,0,0,0,0,0,0,0,0,5m,0,0,0
0,0,0,5j,5a,5b,5c,5d,5e,5f,5g,5h,5k,0,0,0
0,0,0,50,51,52,53,54,55,56,57,58,59,0,0,0
0,0,0,4q,4q,4q,4q,4q,4q,4q,4q,4q,4q,0,0,0
0,0,4r,4k,4k,4k,4k,4k,4k,4k,4k,4k,4k,4v,0,0
0,4s,4k,4k,4k,4k,4k,4k,4k,4k,4k,4k,4l,4m,4w,0
0,4t,0,4k,4k,4k,4k,4k,4k,4k,4k,4k,4k,0,4x,0
0,4u,4z,0,0,0,4n,4o,4p,0,0,0,0,4z,4y,0
0,4h,4j,4j,4j,4j,4j,4j,4j,4j,4j,4j,4j,4j,4i,0
a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a
yy3b,yy3b,yy3b,0,0,0,0,0,0,0,0,0,0,0,0,0
NAME Typewriter1 (Rm7_5)
PAL 0
AVA rm2extch

ROOM 12
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
0,ty3a,ty3b,0,0,0,0,0,0,0,0,0,0,0,0,0
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
0,0,0,5n,5p,5p,5p,5p,5p,5p,5p,5p,5o,0,0,0
0,0,0,5l,0,0,0,0,0,0,0,0,5m,0,0,0
0,0,0,5l,0,0,0,0,0,0,0,0,5m,0,0,0
0,0,0,5j,5a,5b,5c,5d,5e,5f,5g,5h,5k,0,0,0
0,0,0,50,51,52,53,54,55,56,57,58,59,0,0,0
0,0,0,4q,4q,4q,4q,4q,4q,4q,4q,4q,4q,0,0,0
0,0,4r,4k,4k,4k,4k,4k,4k,4k,4k,4k,4k,4v,0,0
0,4s,4k,4k,4k,4k,4k,4k,4k,4k,4k,4k,4l,4m,4w,0
0,4t,0,4k,4k,4k,4k,4k,4k,4k,4k,4k,4k,0,4x,0
0,4u,4z,0,0,0,4n,4o,4p,0,0,0,0,4z,4y,0
0,4h,4j,4j,4j,4j,4j,4j,4j,4j,4j,4j,4j,4j,4i,0
a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a
yy3b,yy3b,yy3b,yy3b,0,0,0,0,0,0,0,0,0,0,0,0
NAME Typewriter1 (Rm7_6)
PAL 0
AVA rm2extch

ROOM 13
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
0,ty3a,ty3b,ty3c,ty3d,0,0,0,0,0,0,0,0,0,0,0
0,0,0,5n,5p,5p,5p,5p,5p,5p,5p,5p,5o,0,0,0
0,0,0,5l,0,0,0,0,0,0,0,0,5m,0,0,0
0,0,0,5l,0,0,0,0,0,0,0,0,5m,0,0,0
0,0,0,5l,0,0,0,0,0,0,0,0,5m,0,0,0
0,0,0,5j,5a,5b,5c,5d,5e,5f,5g,5h,5k,0,0,0
0,0,0,50,51,52,53,54,55,56,57,58,59,0,0,0
0,0,0,4q,4q,4q,4q,4q,4q,4q,4q,4q,4q,0,0,0
0,0,4r,4k,4k,4k,4k,4k,4k,4k,4k,4k,4k,4v,0,0
0,4s,4k,4k,4k,4k,4k,4k,4k,4k,4k,4k,4l,4m,4w,0
0,4t,0,4k,4k,4k,4k,4k,4k,4k,4k,4k,4k,0,4x,0
0,4u,4z,0,0,0,4n,4o,4p,0,0,0,0,4z,4y,0
0,4h,4j,4j,4j,4j,4j,4j,4j,4j,4j,4j,4j,4j,4i,0
a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a
yy3b,yy3b,yy3b,yy3b,yy3b,0,0,0,0,0,0,0,0,0,0,0
NAME Typewriter1 (Rm7_7)
PAL 0
AVA rm2extch

ROOM 14
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
0,ty3a,ty3b,ty3c,ty3d,ty3e,ty3f,ty3g,0,0,0,0,0,0,0,0
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
0,0,0,5n,5p,5p,5p,5p,5p,5p,5p,5p,5o,0,0,0
0,0,0,5l,0,0,0,0,0,0,0,0,5m,0,0,0
0,0,0,5l,0,0,0,0,0,0,0,0,5m,0,0,0
0,0,0,5j,5a,5b,5c,5d,5e,5f,5g,5h,5k,0,0,0
0,0,0,50,51,52,53,54,55,56,57,58,59,0,0,0
0,0,0,4q,4q,4q,4q,4q,4q,4q,4q,4q,4q,0,0,0
0,0,4r,4k,4k,4k,4k,4k,4k,4k,4k,4k,4k,4v,0,0
0,4s,4k,4k,4k,4k,4k,4k,4k,4k,4k,4k,4l,4m,4w,0
0,4t,0,4k,4k,4k,4k,4k,4k,4k,4k,4k,4k,0,4x,0
0,4u,4z,0,0,0,4n,4o,4p,0,0,0,0,4z,4y,0
0,4h,4j,4j,4j,4j,4j,4j,4j,4j,4j,4j,4j,4j,4i,0
a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a
yy3b,yy3b,yy3b,yy3b,yy3b,yy3b,0,0,0,0,0,0,0,0,0,0
NAME Typewriter1 (Rm7_8)
PAL 0
AVA rm2extch

ROOM 15
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
0,ty3a,ty3b,ty3c,ty3d,ty3e,ty3f,ty3g,ty3h,ty3i,0,0,0,0,0,0
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
0,0,0,5n,5p,5p,5p,5p,5p,5p,5p,5p,5o,0,0,0
0,0,0,5l,0,0,0,0,0,0,0,0,5m,0,0,0
0,0,0,5j,5a,5b,5c,5d,5e,5f,5g,5h,5k,0,0,0
0,0,0,50,51,52,53,54,55,56,57,58,59,0,0,0
0,0,0,4q,4q,4q,4q,4q,4q,4q,4q,4q,4q,0,0,0
0,0,4r,4k,4k,4k,4k,4k,4k,4k,4k,4k,4k,4v,0,0
0,4s,4k,4k,4k,4k,4k,4k,4k,4k,4k,4k,4l,4m,4w,0
0,4t,0,4k,4k,4k,4k,4k,4k,4k,4k,4k,4k,0,4x,0
0,4u,4z,0,0,0,4n,4o,4p,0,0,0,0,4z,4y,0
0,4h,4j,4j,4j,4j,4j,4j,4j,4j,4j,4j,4j,4j,4i,0
a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a
yy3b,yy3b,yy3b,yy3b,yy3b,yy3b,yy3b,0,0,0,0,0,0,0,0,0
NAME Typewriter1 (Rm7_9)
PAL 0
AVA rm2extch

ROOM 16
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
0,ty3a,ty3b,ty3c,ty3d,ty3e,ty3f,ty3g,ty3h,ty3i,ty3j,ty3k,ty3l,0,0,0
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
0,0,0,5n,5p,5p,5p,5p,5p,5p,5p,5p,5o,0,0,0
0,0,0,5l,0,0,0,0,0,0,0,0,5m,0,0,0
0,0,0,5l,0,0,0,0,0,0,0,0,5m,0,0,0
0,0,0,5j,5a,5b,5c,5d,5e,5f,5g,5h,5k,0,0,0
0,0,0,50,51,52,53,54,55,56,57,58,59,0,0,0
0,0,0,4q,4q,4q,4q,4q,4q,4q,4q,4q,4q,0,0,0
0,0,4r,4k,4k,4k,4k,4k,4k,4k,4k,4k,4k,4v,0,0
0,4s,4k,4k,4k,4k,4k,4k,4k,4k,4k,4k,4l,4m,4w,0
0,4t,0,4k,4k,4k,4k,4k,4k,4k,4k,4k,4k,0,4x,0
0,4u,4z,0,0,0,4n,4o,4p,0,0,0,0,4z,4y,0
0,4h,4j,4j,4j,4j,4j,4j,4j,4j,4j,4j,4j,4j,4i,0
a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a
yy3b,yy3b,yy3b,yy3b,yy3b,yy3b,yy3b,yy3b,0,0,0,0,0,0,0,0
NAME Typewriter1 (Rm7_10)
PAL 0
AVA rm2extch

ROOM 17
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
0,ty3m,ty3n,0,0,0,0,0,0,0,0,0,0,0,0,0
0,0,0,5n,5p,5p,5p,5p,5p,5p,5p,5p,5o,0,0,0
0,0,0,5l,0,0,0,0,0,0,0,0,5m,0,0,0
0,0,0,5l,0,0,0,0,0,0,0,0,5m,0,0,0
0,0,0,5l,0,0,0,0,0,0,0,0,5m,0,0,0
0,0,0,5j,5a,5b,5c,5d,5e,5f,5g,5h,5k,0,0,0
0,0,0,50,51,52,53,54,55,56,57,58,59,0,0,0
0,0,0,4q,4q,4q,4q,4q,4q,4q,4q,4q,4q,0,0,0
0,0,4r,4k,4k,4k,4k,4k,4k,4k,4k,4k,4k,4v,0,0
0,4s,4k,4k,4k,4k,4k,4k,4k,4k,4k,4k,4l,4m,4w,0
0,4t,0,4k,4k,4k,4k,4k,4k,4k,4k,4k,4k,0,4x,0
0,4u,4z,0,0,0,4n,4o,4p,0,0,0,0,4z,4y,0
0,4h,4j,4j,4j,4j,4j,4j,4j,4j,4j,4j,4j,4j,4i,0
a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a
yy3b,yy3b,yy3b,yy3b,yy3b,yy3b,yy3b,yy3b,yy3b,0,0,0,0,0,0,0
NAME Typewriter1 (Rm7_11)
PAL 0
AVA rm2extch

ROOM 18
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
0,ty3m,ty3n,ty3o,ty3p,0,0,0,0,0,0,0,0,0,0,0
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
0,0,0,5n,5p,5p,5p,5p,5p,5p,5p,5p,5o,0,0,0
0,0,0,5l,0,0,0,0,0,0,0,0,5m,0,0,0
0,0,0,5l,0,0,0,0,0,0,0,0,5m,0,0,0
0,0,0,5j,5a,5b,5c,5d,5e,5f,5g,5h,5k,0,0,0
0,0,0,50,51,52,53,54,55,56,57,58,59,0,0,0
0,0,0,4q,4q,4q,4q,4q,4q,4q,4q,4q,4q,0,0,0
0,0,4r,4k,4k,4k,4k,4k,4k,4k,4k,4k,4k,4v,0,0
0,4s,4k,4k,4k,4k,4k,4k,4k,4k,4k,4k,4l,4m,4w,0
0,4t,0,4k,4k,4k,4k,4k,4k,4k,4k,4k,4k,0,4x,0
0,4u,4z,0,0,0,4n,4o,4p,0,0,0,0,4z,4y,0
0,4h,4j,4j,4j,4j,4j,4j,4j,4j,4j,4j,4j,4j,4i,0
a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a
yy3b,yy3b,yy3b,yy3b,yy3b,yy3b,yy3b,yy3b,yy3b,yy3b,0,0,0,0,0,0
NAME Typewriter1 (Rm7_12)
PAL 0
AVA rm2extch

ROOM 19
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
0,ty3m,ty3n,ty3o,ty3p,ty3q,ty3r,0,0,0,0,0,0,0,0,0
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
0,0,0,5n,5p,5p,5p,5p,5p,5p,5p,5p,5o,0,0,0
0,0,0,5l,0,0,0,0,0,0,0,0,5m,0,0,0
0,0,0,5j,5a,5b,5c,5d,5e,5f,5g,5h,5k,0,0,0
0,0,0,50,51,52,53,54,55,56,57,58,59,0,0,0
0,0,0,4q,4q,4q,4q,4q,4q,4q,4q,4q,4q,0,0,0
0,0,4r,4k,4k,4k,4k,4k,4k,4k,4k,4k,4k,4v,0,0
0,4s,4k,4k,4k,4k,4k,4k,4k,4k,4k,4k,4l,4m,4w,0
0,4t,0,4k,4k,4k,4k,4k,4k,4k,4k,4k,4k,0,4x,0
0,4u,4z,0,0,0,4n,4o,4p,0,0,0,0,4z,4y,0
0,4h,4j,4j,4j,4j,4j,4j,4j,4j,4j,4j,4j,4j,4i,0
a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a
yy3b,yy3b,yy3b,yy3b,yy3b,yy3b,yy3b,yy3b,yy3b,yy3b,yy3b,0,0,0,0,0
NAME Typewriter1 (Rm7_13)
PAL 0
AVA rm2extch

ROOM 20
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
0,ty3m,ty3n,ty3o,ty3p,ty3q,ty3r,ty3s,ty3t,0,0,0,0,0,0,0
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
0,0,0,5n,5p,5p,5p,5p,5p,5p,5p,5p,5o,0,0,0
0,0,0,5l,0,0,0,0,0,0,0,0,5m,0,0,0
0,0,0,5l,0,0,0,0,0,0,0,0,5m,0,0,0
0,0,0,5j,5a,5b,5c,5d,5e,5f,5g,5h,5k,0,0,0
0,0,0,50,51,52,53,54,55,56,57,58,59,0,0,0
0,0,0,4q,4q,4q,4q,4q,4q,4q,4q,4q,4q,0,0,0
0,0,4r,4k,4k,4k,4k,4k,4k,4k,4k,4k,4k,4v,0,0
0,4s,4k,4k,4k,4k,4k,4k,4k,4k,4k,4k,4l,4m,4w,0
0,4t,0,4k,4k,4k,4k,4k,4k,4k,4k,4k,4k,0,4x,0
0,4u,4z,0,0,0,4n,4o,4p,0,0,0,0,4z,4y,0
0,4h,4j,4j,4j,4j,4j,4j,4j,4j,4j,4j,4j,4j,4i,0
a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a
yy3b,yy3b,yy3b,yy3b,yy3b,yy3b,yy3b,yy3b,yy3b,yy3b,yy3b,yy3b,0,0,0,0
NAME Typewriter1 (Rm7_14)
PAL 0
AVA rm2extch

ROOM 21
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
0,ty3m,ty3n,ty3o,ty3p,ty3q,ty3r,ty3s,ty3t,ty3u,ty3v,ty3w,ty3x,0,0,0
0,0,0,5n,5p,5p,5p,5p,5p,5p,5p,5p,5o,0,0,0
0,0,0,5l,0,0,0,0,0,0,0,0,5m,0,0,0
0,0,0,5l,0,0,0,0,0,0,0,0,5m,0,0,0
0,0,0,5l,0,0,0,0,0,0,0,0,5m,0,0,0
0,0,0,5j,5a,5b,5c,5d,5e,5f,5g,5h,5k,0,0,0
0,0,0,50,51,52,53,54,55,56,57,58,59,0,0,0
0,0,0,4q,4q,4q,4q,4q,4q,4q,4q,4q,4q,0,0,0
0,0,4r,4k,4k,4k,4k,4k,4k,4k,4k,4k,4k,4v,0,0
0,4s,4k,4k,4k,4k,4k,4k,4k,4k,4k,4k,4l,4m,4w,0
0,4t,0,4k,4k,4k,4k,4k,4k,4k,4k,4k,4k,0,4x,0
0,4u,4z,0,0,0,4n,4o,4p,0,0,0,0,4z,4y,0
0,4h,4j,4j,4j,4j,4j,4j,4j,4j,4j,4j,4j,4j,4i,0
a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a
yy3b,yy3b,yy3b,yy3b,yy3b,yy3b,yy3b,yy3b,yy3b,yy3b,yy3b,yy3b,yy3b,0,0,0
NAME Typewriter1 (Rm7_15)
PAL 0
AVA rm2extch

ROOM 22
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
0,ty3m,ty3n,ty3o,ty3p,ty3q,ty3r,ty3s,ty3t,ty3u,ty3v,ty3w,ty3x,ty3y,0,0
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
0,0,0,5n,5p,5p,5p,5p,5p,5p,5p,5p,5o,0,0,0
0,0,0,5l,0,0,0,0,0,0,0,0,5m,0,0,0
0,0,0,5l,0,0,0,0,0,0,0,0,5m,0,0,0
0,0,0,5j,5a,5b,5c,5d,5e,5f,5g,5h,5k,0,0,0
0,0,0,50,51,52,53,54,55,56,57,58,59,0,0,0
0,0,0,4q,4q,4q,4q,4q,4q,4q,4q,4q,4q,0,0,0
0,0,4r,4k,4k,4k,4k,4k,4k,4k,4k,4k,4k,4v,0,0
0,4s,4k,4k,4k,4k,4k,4k,4k,4k,4k,4k,4l,4m,4w,0
0,4t,0,4k,4k,4k,4k,4k,4k,4k,4k,4k,4k,0,4x,0
0,4u,4z,0,0,0,4n,4o,4p,0,0,0,0,4z,4y,0
0,4h,4j,4j,4j,4j,4j,4j,4j,4j,4j,4j,4j,4j,4i,0
a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a
yy3b,yy3b,yy3b,yy3b,yy3b,yy3b,yy3b,yy3b,yy3b,yy3b,yy3b,yy3b,yy3b,yy3b,0,0
NAME Typewriter1 (Rm7_16)
PAL 0
AVA rm2extch

ROOM 23
p79,p79,p79,p79,p79,p79,p79,p79,p79,p79,p79,p79,p79,p79,p79,p79
p79,p79,p79,p72,p76,p76,p76,p76,p76,p76,p76,p76,p77,p79,p79,p79
p79,p79,p72,p7d,0,0,0,0,0,0,0,0,p7c,p77,p79,p79
p79,p79,p73,0,0,0,p7e,p7e,p7e,p7e,p7g,0,0,p74,p79,p79
p79,p79,p73,0,0,p7n,p7k,p7i,p7i,p7l,p7o,0,0,p74,p79,p79
p79,p79,p73,0,0,p7m,0,0,0,0,p7p,0,0,p74,p79,p79
p79,p79,p73,0,0,p7q,p7w,p7v,p7v,p7y,p7q,0,0,p74,p79,p79
p79,p79,p73,0,0,p7q,p7x,0,0,p7z,p7q,0,0,p74,p79,p79
p79,p79,p73,0,0,p7q,p81,p7v,p7v,p80,p7q,0,0,p74,p79,p79
p79,p79,p73,0,0,p7q,0,0,0,0,p7q,0,0,p74,p79,p79
p79,p79,p73,0,0,p7q,0,0,0,0,p7q,0,0,p74,p79,p79
p79,p79,p73,0,0,p7s,p7u,p7u,p7u,p7u,p7t,0,0,p74,p79,p79
p79,p79,p73,0,0,0,0,0,0,0,0,0,0,p75,p79,p79
p79,p78,p7a,p7a,p7a,p7a,p7a,p7a,p7a,p7a,p7a,p7a,p75,p79,p79,p79
p79,p79,p79,p79,p79,p79,p79,p79,p79,p79,p79,p79,p79,p79,p79,p79
p79,p79,p79,p79,p79,p79,p79,p79,p79,p79,p79,p79,p79,p79,p79,p79
NAME props_rm1_medicine_bottle
PAL 5

ROOM 24
p79,p79,p79,p79,p79,p79,p79,p79,p79,p79,p79,p79,p79,p79,p79,p79
p79,p79,p79,p72,p76,p76,p76,p76,p76,p76,p76,p76,p77,p79,p79,p79
p79,p79,p72,p7d,0,0,0,0,0,0,0,0,p7c,p77,p79,p79
p79,p79,p73,0,0,0,0,p88,p84,0,0,0,0,p74,p79,p79
p79,p79,p73,0,0,0,p88,0,0,p84,0,0,0,p74,p79,p79
p79,p79,p73,0,0,p88,0,0,0,p8l,p8j,0,0,p74,p79,p79
p79,p79,p73,0,p8c,0,0,0,p8n,p8k,p8m,p84,0,p74,p79,p79
p79,p79,p73,0,p8d,p84,0,0,p8p,p8o,0,0,p89,p74,p79,p79
p79,p79,p73,0,0,p84,p84,0,0,0,0,p8h,p8e,p74,p79,p79
p79,p79,p73,0,0,0,p84,p84,0,0,p8h,p8f,0,p74,p79,p79
p79,p82,p73,0,0,0,0,p84,p84,p8h,p8f,0,0,p74,p79,p79
p79,p79,p73,0,0,0,0,0,p84,p8g,0,0,0,p74,p79,p79
p79,p79,p73,0,0,0,0,0,0,0,0,0,0,p75,p79,p79
p79,p78,p7a,p7a,p7a,p7a,p7a,p7a,p7a,p7a,p7a,p7a,p75,p79,p79,p79
p79,p79,p79,p79,p79,p79,p79,p79,p79,p79,p79,p79,p79,p79,p79,p79
p79,p79,p79,p79,p79,p79,p79,p79,p79,p79,p79,p79,p79,p79,p79,p79
NAME props_rm1_notes
PAL 5

ROOM 25
p79,p79,p79,p79,p79,p79,p79,p79,p79,p79,p79,p79,p79,p79,p79,p79
p79,p79,p79,p72,p76,p76,p76,p76,p76,p76,p76,p76,p77,p79,p79,p79
p79,p79,p72,p7d,0,0,0,0,0,0,0,0,p7c,p77,p79,p79
p79,p79,p73,0,0,0,0,0,0,0,0,0,0,p74,p79,p79
p79,p79,p73,0,0,0,0,0,0,0,0,0,0,p74,p79,p79
p79,p79,p73,p8y,p8q,p8q,p8q,p8q,p8q,p8q,p8q,p8q,p8z,p74,p79,p79
p79,p79,p73,p8t,p91,0,0,0,0,0,0,p90,p8u,p74,p79,p79
p79,p79,p73,p8t,0,p91,0,0,0,0,p90,0,p8u,p74,p79,p79
p79,p79,p73,p8t,0,0,p91,0,0,p90,0,0,p8u,p74,p79,p79
p79,p79,p73,p8t,0,0,0,p93,p92,0,0,0,p8u,p74,p79,p79
p79,p79,p73,p8w,p8x,p8x,p8x,p8x,p8x,p8x,p8x,p8x,p8v,p74,p79,p79
p79,p79,p73,0,0,0,0,0,0,0,0,0,0,p74,p79,p79
p79,p79,p73,0,0,0,0,0,0,0,0,0,0,p75,p79,p79
p79,p78,p7a,p7a,p7a,p7a,p7a,p7a,p7a,p7a,p7a,p7a,p75,p79,p79,p79
p79,p79,p79,p79,p79,p79,p79,p79,p79,p79,p79,p79,p79,p79,p79,p79
p79,p79,p79,p79,p79,p79,p79,p79,p79,p79,p79,p79,p79,p79,p79,p79
NAME props_rm1_letter
PAL 5

ROOM 26
p79,p79,p79,p79,p79,p79,p79,p79,p79,p79,p79,p79,p79,p79,p79,p79
p79,p79,p79,p72,p76,p76,p76,p76,p76,p76,p76,p76,p77,p79,p79,p79
p79,p79,p72,p7d,0,0,0,0,0,0,0,0,p7c,p77,p79,p79
p79,p79,p73,0,0,p97,p99,p99,p99,p99,p98,0,0,p74,p79,p79
p79,p79,p73,0,0,p95,p9h,p9g,p9i,0,p96,0,0,p74,p79,p79
p79,p79,p73,0,0,p95,p9f,0,p9j,0,p96,0,0,p74,p79,p79
p79,p79,p73,0,0,p95,0,p9l,p9k,0,p96,0,0,p74,p79,p79
p94,p79,p73,0,0,p95,0,p9m,0,0,p96,0,0,p74,p79,p79
p79,p79,p73,0,0,p95,0,p9n,0,0,p96,0,0,p74,p79,p79
p79,p79,p73,0,0,p95,0,0,0,0,p96,0,0,p74,p79,p79
p79,p79,p73,0,p9a,p9e,p9e,p9e,p9e,p9e,p9d,0,0,p74,p79,p79
p79,p79,p73,0,0,0,0,0,0,0,0,0,0,p74,p79,p79
p79,p79,p73,0,0,0,0,0,0,0,0,0,0,p75,p79,p79
p79,p78,p7a,p7a,p7a,p7a,p7a,p7a,p7a,p7a,p7a,p7a,p75,p79,p79,p79
p79,p79,p79,p79,p79,p79,p79,p79,p79,p94,p79,p79,p79,p79,p79,p79
p79,p79,p79,p79,p79,p79,p79,p79,p94,p94,p79,p79,p79,p79,p79,p79
NAME props_rm1_confidential_document
PAL 5

ROOM 27
p79,p79,p79,p79,p79,p79,p79,p79,p79,p79,p79,p79,p79,p79,p79,p79
p79,p79,p79,p72,p76,p76,p76,p76,p76,p76,p76,p76,p77,p79,p79,p79
p79,p79,p72,p7d,0,0,0,0,0,0,0,0,p7c,p77,p79,p79
p79,p79,p73,0,0,0,0,0,0,0,0,0,0,p74,p79,p79
p79,p79,p73,p9q,p9o,p9o,p9o,p9o,p9o,p9o,p9o,p9o,p9s,p74,p79,p79
p79,p79,p73,p9v,0,0,0,0,0,0,pab,pac,p9u,p74,p79,p79
p79,p79,p73,p9v,0,p9w,0,0,0,pa4,paa,0,p9u,p74,p79,p79
p79,p79,p73,p9v,p9y,p9x,p9z,0,0,pa5,pa9,0,p9u,p74,p79,p79
p79,p79,p73,p9v,pa0,p9x,pa1,pa2,pa8,pa6,pa7,0,p9u,p74,p79,p79
p79,p79,p73,p9v,pa0,p9x,pa1,pa3,pa6,pa6,pa6,pa7,p9u,p74,p79,p79
p79,p79,p73,p9r,p9p,p9p,p9p,p9p,p9p,p9p,p9p,p9p,p9t,p74,p79,p79
p79,p79,p73,0,0,0,0,0,0,0,0,0,0,p74,p79,p79
p79,p79,p73,0,0,0,0,0,0,0,0,0,0,p75,p79,p79
p79,p78,p7a,p7a,p7a,p7a,p7a,p7a,p7a,p7a,p7a,p7a,p75,p79,p79,p79
p79,p79,p79,p79,p79,p79,p79,p79,p79,p79,p79,p79,p79,p79,p79,p79
p79,p79,p79,p79,p79,p79,p79,p79,p79,p79,p79,p79,p79,p79,p79,p79
NAME props_rm1_photo
PAL 5

ROOM 28
p79,p79,p79,p79,p79,p79,p79,p79,p79,p79,p79,p79,p79,p79,p79,p79
p79,p79,p79,p72,p76,p76,p76,p76,p76,p76,p76,p76,p77,p79,p79,p79
p79,p79,p72,p7d,0,0,0,0,0,0,0,0,p7c,p77,p79,p79
p79,p79,p73,0,0,pai,pak,pak,pak,pak,pak,paj,0,p74,p79,p79
p79,p79,p73,0,pam,pad,pas,pat,0,pay,paz,pae,0,p74,p79,pah
p79,p79,p73,0,pan,pad,pau,pav,0,pb1,pb1,pae,0,p74,p79,pah
p79,p79,p73,0,pan,pad,paw,pax,0,0,0,pae,0,p74,p79,p79
p79,p79,p73,0,pan,pad,0,0,0,0,0,pae,0,p74,p79,p79
p79,p79,p73,0,pan,pad,pay,pb0,pb0,pb0,paz,pae,0,p74,p79,p79
p79,p79,p73,0,pan,pad,pay,pb0,pb0,pb0,paz,pae,0,p74,p79,p79
p79,p79,p73,0,pan,pad,pay,pb0,pb0,pb0,paz,pae,0,p74,p79,p79
p79,p79,p73,0,pan,pag,pal,pal,pal,pal,pal,paf,0,p74,p79,p79
p79,p79,p73,0,pao,pap,pap,pap,pap,paq,0,0,0,p75,p79,p79
p79,p78,p7a,p7a,p7a,p7a,p7a,p7a,p7a,p7a,p7a,p7a,p75,p79,p79,p79
p79,p79,p79,p79,p79,p79,p79,p79,p79,p79,p79,p79,p79,p79,p79,p79
p79,p79,p79,p79,p79,p79,p79,p79,p79,p79,p79,p79,p79,p79,p79,p79
NAME props_rm3_medical_records
PAL 5

ROOM 29
p79,p79,p79,p79,p79,p79,p79,p79,p79,p79,p79,p79,p79,p79,p79,p79
p79,p79,p79,p72,p76,p76,p76,p76,p76,p76,p76,p76,p77,p79,p79,p79
p79,p79,p72,p7d,0,0,0,0,0,0,0,0,p7c,p77,p79,p79
p79,p79,p73,0,0,0,0,0,0,0,0,0,0,p74,p79,p79
p79,p79,p73,0,0,0,pb7,pb9,pb9,pb8,0,0,0,p74,p79,p79
p79,p79,p73,0,0,0,pb5,0,0,pb6,0,0,0,p74,p79,p79
p79,p79,p73,0,pb3,pb2,pb2,pb2,pb2,pb2,pb2,pb4,0,p74,p79,p79
p79,p79,p73,0,pb2,pb2,pb2,pba,pbb,pb2,pb2,pb2,0,p74,p79,p79
p79,p79,p73,0,pb2,pb2,pb2,pbc,pbd,pb2,pb2,pb2,0,p74,p79,p79
p79,p79,p73,0,pbe,pbe,pbe,pbe,pbe,pbe,pbe,pbe,0,p74,p79,p79
p79,p79,p73,0,pb2,pb2,pb2,pb2,pb2,pb2,pb2,pb2,0,p74,p79,p79
p79,p79,p73,0,0,0,0,0,0,0,0,0,0,p74,p79,p79
p79,p79,p73,0,0,0,0,0,0,0,0,0,0,p75,p79,p79
p79,p78,p7a,p7a,p7a,p7a,p7a,p7a,p7a,p7a,p7a,p7a,p75,p79,p79,p79
p79,p79,p79,p79,p79,p79,p79,p79,p79,p79,p79,p79,p79,p79,p79,p79
p79,p79,p79,p79,p79,p79,p79,p79,p79,p79,p79,p79,p79,p79,p79,p79
NAME props_rm3_medical_chest
PAL 5

ROOM 30
p79,p79,p79,p79,p79,p79,p79,p79,p79,p79,p79,p79,p79,p79,p79,p79
p79,p79,p79,p72,p76,p76,p76,p76,p76,p76,p76,p76,p77,p79,p79,p79
p79,p79,p72,p7d,0,0,0,0,0,0,0,0,p7c,p77,p79,p79
p79,p79,p73,0,0,0,0,0,0,0,0,0,0,p74,p79,p79
p79,p79,p73,0,pbf,pbh,pbh,pbh,pbh,pbh,pbh,pbg,0,p74,p79,p79
p79,p79,p73,0,pbi,pbr,pbz,pc0,pc1,pbx,0,pbj,0,p74,p79,p79
p79,p79,p73,0,pbi,pc2,pc3,pc4,pc5,pbw,0,pbj,0,p74,p79,p79
p79,p79,p73,0,pbi,pbt,pbu,pbu,pbu,pc6,0,pbj,0,p74,p79,p79
p79,p79,p73,0,pbi,0,0,0,0,0,0,pbj,0,p74,p79,p79
p79,p79,p73,0,pbk,pbm,pbm,pbm,pbm,pbm,pbm,pbl,0,p74,p79,p79
p79,p79,p73,0,0,0,0,pbn,pbo,0,0,0,0,p74,p79,p79
p79,p79,p73,0,0,0,0,pbp,pbq,0,0,0,0,p74,p79,p79
p79,p79,p73,0,0,0,0,0,0,0,0,0,0,p75,p79,p79
p79,p78,p7a,p7a,p7a,p7a,p7a,p7a,p7a,p7a,p7a,p7a,p75,p79,p79,p79
p79,p79,p79,p79,p79,p79,p79,p79,p79,p79,p79,p79,p79,p79,p79,p79
p79,p79,p79,p79,p79,p79,p79,p79,p79,p79,p79,p79,p79,p79,p79,p79
NAME props_rm3_pc
PAL 5

ROOM 31
p79,p79,p79,p79,p79,p79,p79,p79,p79,p79,p79,p79,p79,p79,p79,p79
p79,p79,p79,p72,p76,p76,p76,p76,p76,p76,p76,p76,p77,p79,p79,p79
p79,p79,p72,p7d,0,0,0,0,0,0,0,0,p7c,p77,p79,p79
p79,p79,p73,0,0,0,0,0,0,0,0,0,0,p74,p79,p79
p79,p79,p73,pcn,pcm,pci,pcj,pck,pck,pcl,pcg,pcf,0,p74,p79,p79
p79,p79,p73,pco,0,0,0,0,0,0,pch,pce,0,p74,p79,p79
p79,p79,p73,pco,pca,0,0,0,0,pcs,pct,pce,0,p74,p79,p79
p79,p79,p73,pco,pca,0,0,0,0,0,0,pce,0,p74,p79,p79
p79,p79,p73,pcp,pca,pcq,pcq,pcq,pcq,0,0,pce,0,p74,p79,p79
p79,p79,p73,0,pcb,pcc,pcc,pcc,pcc,pcc,pcc,pcd,0,p74,p79,p79
p79,p79,p73,0,0,0,0,0,0,0,0,0,0,p74,p79,p79
p79,p79,p73,0,0,0,0,0,0,0,0,0,0,p74,p79,p79
p79,p79,p73,0,0,0,0,0,0,0,0,0,0,p75,p79,p79
p79,p78,p7a,p7a,p7a,p7a,p7a,p7a,p7a,p7a,p7a,p7a,p75,p79,p79,p79
p79,p79,p79,p79,p79,p79,p79,p79,p79,p79,p79,p79,p79,p79,p79,p79
p79,p79,p79,p79,p79,p79,p79,p79,p79,p79,p79,p79,p79,p79,p79,p79
NAME props_rm4_typing
PAL 5

ROOM 32
p79,p79,p79,p79,p79,p79,p79,p79,p79,p79,p79,p79,p79,p79,p79,p79
p79,p79,p79,p72,p76,p76,p76,p76,p76,p76,p76,p76,p77,p79,p79,p79
p79,p79,p72,p7d,0,pd7,pd6,pd6,pd6,pd6,pd6,pd5,p7c,p77,p79,p79
p79,p79,p73,0,pcu,pcy,pcy,pcy,pcy,pcy,pcz,pd4,0,p74,p79,p79
p79,p79,p73,0,pdb,pd8,pd8,pd8,pd8,pd8,pda,pd4,0,p74,p79,p79
p79,p79,p73,0,pcv,pdc,pdc,pdc,0,pdd,pde,pd4,0,p74,p79,p79
p79,p79,p73,0,pcv,pdf,pdf,0,0,pdd,pde,pd4,0,p74,p79,p79
p79,p79,p73,0,pcv,pdf,pdf,pdf,0,pdd,pde,pd4,0,p74,p79,p79
p79,p79,p73,0,pcv,pdf,pdf,pdf,pdf,pdf,pd1,pd4,0,p74,p79,p79
p79,p79,p73,0,pcv,0,0,0,0,0,pd1,pd4,0,p74,p79,p79
p79,p79,p73,0,pcv,pdf,pdf,pdf,pdf,pdg,pd1,pd3,0,p74,p79,p79
p79,p79,p73,0,pcw,pcx,pcx,pcx,pcx,pcx,pd0,0,0,p74,p79,p79
p79,p79,p73,0,0,0,0,0,0,0,0,0,0,p75,p79,p79
p79,p78,p7a,p7a,p7a,p7a,p7a,p7a,p7a,p7a,p7a,p7a,p75,p79,p79,p79
p79,p79,p79,p79,p79,p79,p79,p79,p79,p79,p79,p79,p79,p79,p79,p79
p79,p79,p79,p79,p79,p79,p79,p79,p79,p79,p79,p79,p79,p79,p79,p79
NAME props_rm4_newpaper
PAL 5

ROOM 33
p79,p79,p79,p79,p79,p79,p79,p79,p79,p79,p79,p79,p79,p79,p79,p79
p79,p79,p79,p72,p76,p76,p76,p76,p76,p76,p76,p76,p77,p79,p79,p79
p79,p79,p72,p7d,0,pdp,0,0,0,0,0,0,p7c,p77,p79,p79
p79,p79,p73,0,0,pdh,pdi,pdj,pdj,pdj,pdj,pdk,pdx,p74,p79,p79
p79,p79,p73,0,0,pdh,pdh,pdy,pdy,pdy,pdy,pdz,pdw,p74,p79,p79
p79,p79,p73,0,0,pdh,pdh,pe0,pe0,pe0,pe0,pdl,pdw,p74,p79,p79
p79,p79,p73,0,0,pdh,pdh,0,0,0,0,pdl,pdw,p74,p79,p79
p79,p79,p73,0,0,pdh,pdh,pe0,pe0,pe0,pe0,pdl,pdw,p74,p79,p79
p79,p79,p73,0,0,pdh,pdh,0,0,0,0,pdl,pdw,p74,p79,p79
p79,p79,p73,0,0,pdh,pe1,pe2,pe2,pe2,pe2,pdl,pdw,p74,p79,p79
p79,p79,p73,0,0,pdr,pdn,pdo,pdo,pdo,pdo,pdm,pdw,p74,p79,p79
p79,p79,p73,0,0,pdt,pdu,pdu,pdu,pdu,pdu,pdu,pdv,p74,p79,p79
p79,p79,p73,0,0,0,0,0,0,0,0,0,0,p75,p79,p79
p79,p78,p7a,p7a,p7a,p7a,p7a,p7a,p7a,p7a,p7a,p7a,p75,p79,p79,p79
p79,p79,p79,p79,p79,p79,p79,p79,p79,p79,p79,p79,p79,p79,p79,p79
p79,p79,p79,p79,p79,p79,p79,p79,p79,p79,p79,p79,p79,p79,p79,p79
NAME props_rm4_notes
PAL 5

ROOM 34
p79,p79,p79,p79,p79,p79,p79,p79,p79,p79,p79,p79,p79,p79,p79,p79
p79,p79,p79,p72,p76,p76,p76,p76,p76,p76,p76,p76,p77,p79,p79,p79
p79,p79,p72,p7d,0,0,0,0,0,0,0,0,p7c,p77,p79,p79
p79,p79,p73,0,0,0,0,0,0,0,0,0,0,p74,p79,p79
p79,p79,p73,0,0,0,0,0,0,0,0,0,0,p74,p79,p79
p79,p79,p73,0,0,0,peh,pei,pej,pek,0,0,0,p74,p79,p79
p79,p79,p73,0,pee,pef,pen,0,peo,pel,pem,0,0,p74,p79,p79
p79,p79,p73,0,pea,pec,pe3,pe7,pe8,ped,peb,0,0,p74,p79,p79
p79,p79,p73,0,0,pe4,pep,peq,pe6,pe9,0,0,0,p74,p79,p79
p79,p79,p73,0,per,pe6,pe6,pe6,pe6,pe6,0,0,0,p74,p79,p79
p79,p79,p73,0,pes,0,0,0,0,0,0,0,0,p74,p79,p79
p79,p79,p73,0,pet,0,0,0,0,0,0,0,0,p74,p79,p79
p79,p79,p73,peu,0,0,0,0,0,0,0,0,0,p75,p79,p79
p79,p78,p7a,p7a,p7a,p7a,p7a,p7a,p7a,p7a,p7a,p7a,p75,p79,p79,p79
p79,p79,p79,p79,p79,p79,p79,p79,p79,p79,p79,p79,p79,p79,p79,p79
p79,p79,p79,p79,p79,p79,p79,p79,p79,p79,p79,p79,p79,p79,p79,p79
NAME props_rm4_phone
PAL 5

ROOM 35
p79,p79,p79,p79,p79,p79,p79,p79,p79,p79,p79,p79,p79,p79,p79,p79
p79,p79,p79,p72,p76,p76,p76,p76,p76,p76,p76,p76,p77,p79,p79,p79
p79,p79,p72,p7d,0,0,0,0,0,0,0,0,p7c,p77,p79,p79
p79,p79,p73,0,0,p79,p79,p79,p79,p79,p79,0,0,p74,p79,p79
p79,p79,p73,0,0,p79,0,0,0,0,p79,0,0,p74,p79,p79
p79,p79,p73,0,0,p79,0,0,0,0,p79,0,0,p74,p79,p79
p79,p79,p73,0,0,p79,p79,p79,p79,p79,p79,0,0,p74,p79,p79
p79,p79,p73,0,0,0,0,0,0,p79,0,0,0,p74,p79,p79
p79,p79,p73,0,0,0,0,p79,p79,p79,0,0,0,p74,p79,p79
p79,p79,p73,0,0,0,0,0,0,p79,0,0,0,p74,p79,p79
p79,p79,p73,0,0,0,0,p79,p79,p79,0,0,0,p74,p79,p79
p79,p79,p73,0,0,0,0,0,0,0,0,0,0,p74,p79,p79
p79,p79,p73,0,0,0,0,0,0,0,0,0,0,p75,p79,p79
p79,p78,p7a,p7a,p7a,p7a,p7a,p7a,p7a,p7a,p7a,p7a,p75,p79,p79,p79
p79,p79,p79,p79,p79,p79,p79,p79,p79,p79,p79,p79,p79,p79,p79,p79
p79,p79,p79,p79,p79,p79,p79,p79,p79,p79,p79,p79,p79,p79,p79,p79
NAME props_rm1_key
PAL 5

ROOM StartGame
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
0,0,0,0,0,0,0,0,0,a,0,0,0,0,0,0
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
NAME StartGame
PAL 0
AVA rm2extdc

ROOM a
a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a
a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
0,0,0,m,n,l,f,0,0,0,0,0,0,0,0,0
0,0,0,d,p,k,g,0,0,1g,1f,1j,0,0,0,0
0,0,0,d,p,k,g,1m,1k,1h,1e,19,1c,0,0,0
0,0,0,e,p,k,h,1n,1l,1i,1d,1a,1b,0,0,0
0,0,0,q,o,j,i,0,1o,r,s,15,1z,6y,27,27
yy3a,yy3a,yy3a,yy3a,yy3a,yy3a,yy3a,yy3a,14,13,w,16,1v,b,25,26
0,0,0,0,0,0,0,0,y,12,v,17,1w,0,23,24
0,0,1q,1p,1r,21,0,0,z,10,11,18,6z,1y,0,0
0,1u,1t,1t,1s,22,0,0,0,0,27,27,70,cl2y,5i,0
a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a
a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a
a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a
NAME Marie room (Rm1_2) 
ITM 1_5 14,9
ITM 1_6 13,10
ITM 1_4 13,12
ITM 1_3 12,12
EXT 15,11 2 8,7
PAL 0

ROOM b
a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a
a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
0,0,0,m,n,l,f,0,0,0,0,0,0,0,0,0
0,0,0,d,p,k,g,0,0,1g,1f,1j,0,0,0,0
0,0,0,d,p,k,g,1m,1k,1h,1e,19,1c,0,0,0
0,0,0,e,p,k,h,1n,1l,1i,1d,1a,1b,0,0,0
0,0,0,q,o,j,i,0,1o,r,s,15,1z,6y,27,27
yy3a,yy3a,yy3a,yy3a,yy3a,yy3a,yy3a,yy3a,14,13,w,16,1v,b,25,26
0,0,0,0,0,0,0,0,y,12,v,17,1w,0,23,24
0,0,1q,1p,1r,21,0,0,z,10,11,71,1x,1y,0,0
0,1u,1t,1t,1s,22,0,0,0,0,0,0,70,cl2y,5i,0
a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a
a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a
a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a
NAME Marie room (Rm1_3) 
ITM 1_5 14,9
ITM 1_6 13,10
PAL 0

ROOM d
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
0,0,q2,q3,q3,q3,q3,q3,q3,q3,q3,q3,q3,q4,0,0
0,0,q5,q6,q7,q7,q7,q7,q7,q7,q7,q7,q8,q9,0,0
0,0,q5,qb,qc,qc,qd,qe,qf,qg,qc,qc,qh,q9,0,0
0,0,q5,qb,qc,qi,qj,qk,ql,qm,qn,qc,qh,q9,0,0
0,0,q5,qb,qc,qo,qp,qq,qr,qs,qt,qc,qh,q9,0,0
0,0,q5,qb,qc,qu,qv,qw,qx,qy,qz,qc,qh,q9,0,0
0,0,q5,qb,qc,qc,q10,q11,q12,q13,qc,qc,qh,q9,0,0
0,0,q5,qb,qc,qc,q14,q15,q16,q17,qc,qc,qh,q9,0,0
0,0,q5,qb,qc,qc,q18,q19,q1a,q1b,qc,qc,qh,q9,0,0
0,0,q5,qb,q1c,q1d,q1e,q1f,q1g,q1h,q1i,q1j,qh,q9,0,0
0,0,q5,qb,q1k,q1l,q1l,q1l,q1m,q1n,q1l,q1o,qh,q9,0,0
0,0,q1p,q1q,q1r,0,0,0,0,0,0,q1s,q1t,q1u,0,0
0,0,q1v,q1w,q1r,0,0,0,0,0,0,q1s,q1x,q1y,0,0
0,0,0,q1z,q20,q21,q22,q23,q24,q25,q26,q27,q28,0,0,0
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
NAME DoctorSay
PAL 6
AVA rm2extdc

ROOM e
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
0,0,yy2,yy3,yy3,yy3,yy3,yy3,yy3,yy3,yy3,yy3,yy3,yy4,0,0
0,0,yy5,yy6,yy7,yy7,yy8,yy9,yyb,yy7,yy7,yy7,yyd,yye,0,0
0,0,yy5,yyf,yyg,yyg,yyh,yyi,yyj,yyk,yyg,yyg,yyl,yye,0,0
0,0,yy5,yyf,yyg,yym,yyn,yyo,yyp,0,yyq,yyg,yyl,yye,0,0
0,0,yy5,yyf,yyg,yyr,yys,yyt,yyu,0,yyv,yyg,yyl,yye,0,0
0,0,yy5,yyf,yyg,yyw,yyx,yyy,yyz,0,yy10,yyg,yyl,yye,0,0
0,0,yy5,yyf,yy11,yy12,yy13,yy14,yy15,yy16,yy17,yyg,yyl,yye,0,0
0,0,yy5,yyf,yy18,yy19,yy1a,yy1b,yy1c,yy1d,yy1e,yy1f,yyl,yye,0,0
0,0,yy5,yy1g,yy1h,yy1i,yy1j,yy1k,yy1l,yy1m,yy1n,yy1o,yyl,yye,0,0
0,0,yy5,yyf,yy1p,yy1q,yy1r,yy1s,yy1t,yy3,yy1u,yy1v,yyl,yye,0,0
0,0,yy5,yy1w,yy1x,yy1y,yy1z,yy20,yy20,yy21,yy20,yy22,yy23,yye,0,0
0,0,yy5,yy24,yy25,yy26,yy27,0,yy28,yy29,yy2a,yy2b,yy2c,yye,0,0
0,0,yy2d,yy2e,yy2f,yy2g,yy2h,yy2i,yy2j,yy2k,yy2l,yy2b,yy2m,yy2n,0,0
0,0,0,yy2o,yy2p,yy2q,yy2q,yy2r,yy2s,yy2q,yy2q,yy2t,yy2u,0,0,0
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
NAME PatientSay
PAL 6
AVA rm2extdc

ROOM f
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
0,0,jj2,jj3,jj3,jj3,jj3,jj3,jj3,jj3,jj3,jj3,jj3,jj4,0,0
0,0,jj5,jj6,jj7,jj7,jj7,jj7,jj7,jj7,jj7,jj7,jjd,jje,0,0
0,0,jj5,jjf,jjg,jjg,jj2v,jj2w,jj2x,jj2y,jjg,jjg,jjl,jje,0,0
0,0,jj5,jjf,jjg,jjg,jj2z,0,0,jj30,jjg,jjg,jjl,jje,0,0
0,0,jj5,jjf,jjg,jj31,jj32,jj33,jj34,jj35,jj36,jjg,jjl,jje,0,0
0,0,jj5,jjf,jjg,jjg,jj37,jj38,jj39,jj3a,jjg,jjg,jjl,jje,0,0
0,0,jj5,jjf,jjg,jjg,jj3b,jj3c,jj3d,jj3e,jjg,jjg,jjl,jje,0,0
0,0,jj5,jjf,jjg,jjg,jj3f,jj3g,jj3h,jj3i,jjg,jjg,jjl,jje,0,0
0,0,jj5,jjf,jj3j,jj3k,jj3l,jj3m,jj3n,jj3o,jj3p,jj3q,jjl,jje,0,0
0,0,jj5,jjf,jj3r,jj3s,jj3t,jj3u,jj3v,jj3w,jj3x,jj3y,jjl,jje,0,0
0,0,jj5,jjf,jj1x,jj1y,jj1y,jj3z,jj3z,jj3z,jj1y,jj40,jjl,jje,0,0
0,0,jj41,jjf,jj25,0,0,0,0,0,0,jj2b,jjl,jj42,0,0
0,0,jj43,jj44,jj25,0,0,0,0,0,0,jj2b,jj45,jj46,0,0
0,0,0,jj47,jj48,jj49,jj4a,jj4b,jj4c,jj4c,jj2q,jj2t,jj2u,0,0,0
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
NAME JournalistSay
PAL 6
AVA rm2extdc

ROOM EndGame
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
0,yy39,yy39,yy39,0,0,0,0,0,0,0,0,0,0,0,0
0,yy39,0,a,yy3c,yy3d,yy3e,yy3f,0,yy3g,yy3h,yy3c,yy3i,0,0,0
0,yy39,0,0,yy32,yy2w,yy33,yy34,yy35,0,yy36,yy37,yy38,yy33,0,0
0,yy39,yy39,yy39,0,0,0,0,0,0,0,0,0,0,0,0
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
NAME EndGame
PAL 0
AVA rm2extc9

ROOM startgamf
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
0,a,a,0,0,a,0,0,0,a,0,0,a,0,a,0
0,a,0,a,0,a,0,0,a,0,a,0,a,0,a,0
0,a,0,a,0,a,0,0,a,a,a,0,0,a,0,0
0,a,a,0,0,a,0,0,a,0,a,0,0,a,0,0
0,a,0,0,0,a,0,0,a,0,a,0,0,a,0,0
0,a,0,0,0,a,a,0,a,0,a,0,0,a,0,0
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
0,yy39,yy39,yy39,0,0,0,0,0,0,0,0,0,0,0,0
0,yy39,0,0,yy2y,yy2z,yy30,yy2w,yy2z,0,0,0,0,0,0,0
0,yy39,0,0,yy32,yy2w,yy33,yy34,yy35,0,yy36,yy37,yy38,yy33,0,0
0,yy39,yy39,yy39,0,0,0,0,0,0,0,0,0,0,0,0
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
NAME CovePage
PAL 0
AVA rm2extc9

ROOM startgamg
a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a
a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
0,0,0,m,n,l,f,0,0,0,0,0,0,0,0,0
0,0,0,d,p,k,g,0,0,1g,1f,1j,0,0,0,0
0,0,0,d,p,k,g,1m,1k,1h,1e,19,1c,0,0,0
0,0,0,e,p,k,h,1n,1l,1i,1d,1a,1b,0,0,0
0,0,0,q,o,j,i,0,1o,r,s,15,1z,6y,27,27
yy3a,yy3a,yy3a,yy3a,yy3a,yy3a,yy3a,yy3a,14,13,w,16,1v,b,25,26
0,0,0,0,0,0,0,0,y,12,v,17,1w,0,23,24
0,0,1q,1p,1r,21,0,0,z,10,11,71,1x,1y,0,0
0,1u,1t,1t,1s,22,0,0,0,0,0,0,70,cl2y,5i,0
a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a
a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a
a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a
NAME Marie room (Rm1) end
PAL 0

ROOM startgamh
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
0,0,0,0,0,0,0,0,0,a,0,0,0,0,0,0
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
NAME over
PAL 0
AVA rm2extdc

TIL 10
11111111
11111111
11111111
11111111
00000000
11111111
00000000
00000000
NAME W_EL7
WAL true

TIL 11
11111010
11110101
11111011
11110111
01111110
11111101
01111111
01100000
NAME W_EL8
WAL true

TIL 12
11111111
11111111
00000100
11111111
00000000
11111111
11111111
11111111
NAME T_EL17
WAL false

TIL 13
01100000
01100000
01111111
01110000
11101111
11000000
11111111
11111111
NAME T_EL18
WAL false

TIL 14
00000000
00000000
00000000
00000000
00000000
11111111
00000011
11111111
NAME W_EL9
WAL true

TIL 15
01100000
01100000
11100001
11100011
11100110
01101111
11100010
01100000
NAME T_EL19
WAL false

TIL 16
01100000
01100000
11100011
11100110
11101111
11111111
11100000
11101111
NAME W_EL10
WAL true

TIL 17
11101000
11101010
11101000
11101111
11100000
11101111
11101000
01101010
NAME W_EL11
WAL true

TIL 18
11101000
11101111
10100000
01111111
10101010
01010101
11111110
00000000
NAME floorMat_Block
WAL true

TIL 19
00000000
00000000
11111111
10000000
10000110
10011000
10001111
10001000
NAME T_EL20

TIL 21
00000000
11110000
11110000
10110000
01110000
11110000
11110000
10110000
NAME T_EL47
WAL false

TIL 22
01110000
10110000
11110000
11110000
10110000
00110000
00110000
00110000
NAME T_EL48
WAL true

TIL 23
01000000
01000000
01000000
01000000
01111111
00000000
00000000
00000000
NAME T_EL49

TIL 24
00010100
00010100
00010100
00011000
11110000
00000000
00000000
00000000
NAME T_EL50

TIL 25
00000000
00000000
00000000
00011111
00100000
11000000
01111111
11000000
NAME T_EL51

TIL 26
00000000
00000000
00000000
11111100
00001100
00010111
11110100
00010111
NAME T_EL52

TIL 27
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
NAME W_EL53
WAL true

TIL 28
11111111
11111111
11111111
11111111
11111111
11111111
11111111
11111111
NAME T_EL54

TIL 29
11010101
11101010
11110101
11111010
11111101
11111110
11111111
11111111
NAME T_EL55

TIL 30
00000000
00000000
00001111
00010000
00111111
00100000
00100000
00100000
NAME W_EL17
WAL true

TIL 31
00000000
00000000
11111111
00000000
11111111
00000000
00000000
00000000
NAME W_EL18
WAL true

TIL 32
00000000
00000000
11111110
00000110
11111010
00001010
00001010
00001010
NAME W_EL19
WAL true

TIL 33
00001010
00001010
00001010
00001010
00001010
00001010
00001010
00001010
NAME W_EL20
WAL true

TIL 34
00001010
00001010
00001010
00001010
11111100
11000000
11000000
11000000
NAME T_EL76
WAL false

TIL 35
11110000
00010000
11110000
00000000
11111111
11111111
00000000
00000000
NAME T_EL77
WAL false

TIL 36
00100111
00100100
00100111
00100000
00111111
00000011
00000011
00000011
NAME T_EL78
WAL false

TIL 37
00000011
00000011
00000011
00000011
00000011
11111111
00000011
11111111
NAME T_EL79
WAL false

TIL 38
11000000
11000000
11000000
11000000
11000000
11111111
11000000
11111111
NAME T_EL80
WAL false

TIL 39
00000011
11111111
00000000
00000000
00000000
00000000
00000000
00000000
NAME T_EL81

TIL 40
00000001
00000001
00000001
00000000
11111111
11111111
00000000
00000000
NAME T_EL108
WAL false

TIL 41
10000000
10000000
10000000
10000000
10000000
10000000
11111111
00000000
NAME T_EL109

TIL 42
10100000
10100000
10100000
10100000
10100000
10100000
10100000
10100000
NAME T_EL110
WAL false

TIL 43
00001111
00011011
00110111
01101111
11111111
10100000
11111111
10100000
NAME T_EL111
WAL true

TIL 44
11111111
11111111
11111111
11111111
11111111
00000101
11111111
00000101
NAME T_EL112
WAL true

TIL 45
11111000
11111000
11101000
11011000
10111000
01101000
11011000
10111000
NAME T_EL113
WAL true

TIL 46
00000101
00000101
00000101
00000101
00000101
00000101
01110101
01010101
NAME T_EL114

TIL 47
01110101
00000101
00000101
00000101
00000101
00000101
11111111
00000000
NAME T_EL115

TIL 48
00001000
00001000
00010000
00100000
01000000
10000000
00000000
00000000
NAME T_EL116

TIL 49
01101000
11011000
10111000
01101000
11001000
10001111
00001000
00001111
NAME T_EL117

TIL 50
00010000
00010000
00010000
00010000
00011111
00110010
01100100
11001000
NAME T_EL144

TIL 51
00010000
00100000
01000001
10000010
11111111
00001000
00010000
00100000
NAME T_EL145

TIL 52
01000001
10000010
00000100
00001000
11111111
00100000
01000000
10000000
NAME T_EL146

TIL 53
00001000
00001000
00010000
00010000
11111111
00100000
01000001
01000001
NAME T_EL147

TIL 54
00100010
00100010
01000100
01000100
11111111
10001000
00001000
00001000
NAME T_EL148

TIL 55
00100100
00100100
00100010
00100010
11111111
00100001
00100001
00100001
NAME T_EL149

TIL 56
01000100
01000100
00100010
00100010
11111111
00010001
00001000
00001000
NAME T_EL150

TIL 57
10001000
01000100
00100010
00010001
11111111
00000100
10000010
10000001
NAME T_EL151

TIL 58
01000001
00100000
00010000
00001000
11111111
01000010
00100001
00010000
NAME T_EL152

TIL 59
00001000
10001000
01001000
00101000
11111000
00001000
00000100
10000010
NAME T_EL153

TIL 60
11111111
01001001
01001001
01001001
01001001
01001001
01001001
01001001
NAME T_EL180

TIL 61
11111111
00100100
00100100
00100100
00100100
00100100
00100100
00100100
NAME T_EL181

TIL 62
11111111
10010010
10010010
10010010
10010010
10010010
10010010
10010010
NAME T_EL182

TIL 63
11111111
01001001
01001001
01001001
01001001
01001001
01001001
01001001
NAME T_EL183

TIL 64
00000000
00000000
00000000
00000000
00000000
11111111
10000000
11111111
NAME T_EL184

TIL 65
00000000
00000000
00000000
00000000
00000000
11111111
00000000
11111111
NAME T_EL185

TIL 66
00000000
00000000
00000000
00000000
00000000
11111111
00000001
11111111
NAME T_EL186

TIL 67
11111111
00000000
00000000
11111111
00000000
11111111
00000000
10101010
NAME T_EL187

TIL 68
11111111
00000000
00000000
00011111
00100000
01011111
01010000
01010000
NAME T_EL188

TIL 69
11111111
00000000
00000000
11111000
00000100
11111010
00001010
00001010
NAME T_EL189

TIL 70
00000111
00001100
00010011
00010100
00101110
01111111
00000000
11000000
NAME key1_tile
WAL false

TIL 71
11101000
11101111
10100000
01111111
10101010
01010101
11111110
00000000
NAME floorMat
WAL false

TIL a
11111111
11000111
11110101
10011101
10111001
10101111
11100011
11111111
NAME W_block
WAL true

TIL b
00000000
00000000
00000000
00000000
00000000
11111111
00000000
11111111
NAME T_EL2
WAL false

TIL d
10001000
10001000
10001000
10001000
10000100
10000100
10000100
10000000
NAME T_EL2
WAL false

TIL e
10001000
10001000
10001000
10001100
10000100
10000100
10000000
10000100
NAME W_EL1
WAL true

TIL f
11111111
11111111
11111111
11111111
11111111
01000001
01000001
00100001
NAME T_EL1

TIL g
00100001
00100001
00100001
00100001
00100001
00000001
00100001
00000001
NAME T_EL3

TIL h
00000001
00000001
00100001
00100001
00100001
00000001
00000001
00000001
NAME W_EL3
WAL true

TIL i
00100001
00100001
00110001
00010001
00010001
00011111
11110000
00000000
NAME T_EL4
WAL false

TIL j
10001000
10001000
10001100
10000100
11100100
00111100
00000011
00000000
NAME T_EL5
WAL false

TIL k
10001000
10001000
10001000
10001000
10000000
10000000
10000000
10000000
NAME W_EL4
WAL true

TIL l
11111111
11111111
11111111
11111111
11111111
10010000
10010000
11111111
NAME T_EL6

TIL m
11111111
11111111
11111111
11111111
11111111
10000000
11111001
10000010
NAME T_EL7

TIL n
11111111
11111111
11111111
11111110
11111111
00000010
11001111
00000010
NAME T_EL8

TIL o
00100010
00100011
00100011
00010010
11000010
00111100
00000000
00000000
NAME T_EL9
WAL false

TIL p
00100010
00100010
00101010
00100010
00010010
00010010
00000010
00000010
NAME W_EL5
WAL true

TIL q
10000000
10010010
10000010
11111000
00001111
00000000
00000000
00000000
NAME T_EL10
WAL false

TIL r
01100000
01100000
01111111
01111111
01111111
01100000
01111111
01100000
NAME T_EL11

TIL s
00000000
00000000
11111111
11111111
11111111
00000000
11111111
00000000
NAME T_EL12

TIL t
11111111
11111111
11111111
11111111
11111111
11111111
11111111
11111111
NAME T_EL13

TIL v
10011111
11111111
10011111
10010111
00011011
11110101
11111010
11110101
NAME T_EL14

TIL w
00000000
00000000
11111111
00000011
11110111
00001111
11111111
10011111
NAME T_EL15

TIL y
11011111
00111111
11010000
11011111
11000000
11111111
11111111
11111111
NAME W_EL6
WAL true

TIL z
11111111
11111111
11111111
11111111
11000000
11111111
11000000
11000000
NAME T_EL16
WAL true

TIL 1a
10011011
10110111
10010010
10100011
10001110
10000000
11111111
00000000
NAME T_EL21

TIL 1b
11100001
11100001
11100001
00000001
00111101
00000001
11111111
00000000
NAME T_EL22

TIL 1c
00000000
00000000
11111111
00000001
00100001
01110001
10100001
01000001
NAME T_EL23

TIL 1d
11000100
01110100
10110100
01011100
11111100
00000000
00000000
00000000
NAME T_EL24

TIL 1e
00000100
10000100
10100100
11011100
11100100
10111100
01100100
01010100
NAME T_EL25

TIL 1f
00000000
00000000
00000000
11111100
00000100
11110100
11110100
00000100
NAME T_EL26

TIL 1g
00000000
00000000
00000000
00011111
00010000
00010000
00010000
00010000
NAME T_EL27

TIL 1h
00010011
00010110
00010100
11010010
01010011
01010100
01010110
01010001
NAME T_EL28

TIL 1i
01010001
01010010
01010111
11011111
00011111
00000000
00000000
00000000
NAME T_EL29

TIL 1j
00000000
00000000
01111100
01000100
01000100
01000100
01000100
01111100
NAME T_EL30

TIL 1k
00000000
00000000
00000000
11111111
00000000
00000000
00000000
00000000
NAME T_EL31

TIL 1l
00000000
00000000
00000000
11111111
00000000
00111110
00100010
00100010
NAME T_EL32

TIL 1m
00000000
00000000
00000000
00000011
00000010
00000010
00000010
00000010
NAME T_EL33

TIL 1n
00000010
00000010
00000010
00000011
00000000
00000000
00000000
00000000
NAME T_EL34

TIL 1o
00100010
00100010
00100010
00100010
00100010
00111110
00000000
00000000
NAME T_EL35
WAL false

TIL 1p
00000000
11111111
11111111
11111111
11111111
11111111
11111111
11111111
NAME T_EL36
WAL false

TIL 1q
00000000
00000011
00000111
00001111
00011111
00111111
01111111
11111111
NAME T_EL37
WAL false

TIL 1r
00000000
11111111
11111111
11111111
11111111
11111110
11111101
11111011
NAME T_EL38
WAL false

TIL 1s
11110111
11101111
01011101
11111010
11111101
11101111
11010110
11101100
NAME T_EL39
WAL true

TIL 1t
11111111
11111111
00000000
11111111
11111111
00000000
00000000
00000000
NAME T_EL40
WAL true

TIL 1u
00000001
00000011
00000010
00000011
00000011
00000011
00000011
00000011
NAME T_EL41
WAL true

TIL 1v
11000000
11000000
11111110
11010110
00101010
11110111
00101010
10110111
NAME T_EL42
WAL true

TIL 1w
10101010
10110110
10101110
10111010
00110010
10100110
10101110
10111110
NAME T_EL43
WAL true

TIL 1x
10111101
10111010
00110101
11101011
00000000
00000000
00000000
00000000
NAME T_EL44
WAL false

TIL 1y
01110000
11100000
11000000
10000000
00000000
00000000
00000000
00000000
NAME T_EL45
WAL false

TIL 1z
00000000
11000000
01100000
10010000
01001000
00111100
11010000
10000000
NAME T_EL46

TIL 2a
01010101
10101010
01010101
10101010
01010101
10101010
01010101
10101010
NAME T_EL56

TIL 2b
11111111
11111111
01111111
10111111
01011111
10101111
01010111
10101011
NAME T_EL57

TIL 2c
11011011
10110110
01101101
11011011
10110110
01101101
11011011
10110110
NAME T_EL58

TIL 2d
11111111
11111111
11111110
11111101
11111011
11110110
11101101
11011011
NAME T_EL59

TIL 2e
01101101
11011011
10110111
01101111
11011111
10111111
01111111
11111111
NAME T_EL60

TIL 2f
01001001
10010010
00100100
01001001
10010010
00100100
01001001
10010010
>
10010010
00100100
01001001
10010010
00100100
01001001
10010010
00100100
NAME T_EL61

TIL 2g
01001001
00100100
10010010
01001001
00100100
10010010
01001001
00100100
>
10010010
01001001
00100100
10010010
01001001
00100100
10010010
01001001
NAME T_EL62

TIL 2h
10000001
01000010
00100100
00011000
00011000
00100100
01000010
10000001
NAME T_EL63

TIL 2i
11000011
11100111
01111110
00111100
00111100
01111110
11100111
11000011
>
01111110
10011100
11001001
11100011
11100011
11001001
10011100
00111110
NAME T_EL64

TIL 2j
11101100
11111011
10110110
01101100
11011011
00110110
01101101
11010011
>
10111011
01100100
11001001
10010011
01100100
11001001
10010111
10110111
NAME T_EL65

TIL 2k
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
NAME T_EL66

TIL 2l
11111111
11111111
11111111
11111111
11111111
11111111
01100001
11111111
NAME T_EL67
WAL false

TIL 2m
00000011
00000111
00001111
00011111
00111111
01111111
01110010
01111111
NAME T_EL68
WAL false

TIL 2n
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000001
NAME T_EL69

TIL 2o
00000000
00000000
00000000
00011111
00111111
01111111
11111111
11111111
NAME T_EL70

TIL 2p
11111111
11111110
11111101
11111010
11110101
11101010
11110100
11101000
NAME T_EL71

TIL 2q
00000000
00000000
00000000
11111111
11111111
11111111
11111111
11111111
NAME T_EL72

TIL 2r
00000000
00000000
00000000
11111111
01010101
11111111
11111111
11111111
NAME T_EL73

TIL 2s
00000000
00000000
00000000
11100000
11100000
11100000
11100000
11100000
NAME T_EL74

TIL 2t
01100000
11100000
01100000
11100000
01100000
01100000
01100000
01100000
NAME W_EL12
WAL true

TIL 2u
01100000
01100000
00000000
01100000
00000000
00000000
00000000
00000000
NAME W_EL13
WAL true

TIL 2v
01110000
01100000
01100000
01100000
01100000
01100000
01100000
01100000
NAME W_EL14
WAL true

TIL 2w
00000000
01100000
00000000
00000000
00000000
00000000
00000000
00000000
NAME W_EL15
WAL true

TIL 2y
00100000
00100000
00100000
00100000
00100000
00100000
00100000
00100000
NAME W_EL16
WAL true

TIL 3a
00000000
11111111
00000000
00000000
00000000
00000000
00000000
00000000
NAME T_EL82

TIL 3b
00001100
11111111
00001100
00001111
00001100
00001100
00001100
00001100
NAME T_EL83

TIL 3c
00000110
11111111
00000110
11111110
10100110
10100110
10100110
10100110
NAME T_EL84
WAL false

TIL 3d
11000000
11111111
00000000
00000000
00000000
00000000
00000000
00000000
NAME T_EL85
WAL false

TIL 3e
00001111
00011111
00111111
11111111
10101010
11111111
11111111
11111111
NAME T_EL86

TIL 3f
11111110
11111100
11111110
11111111
10101010
11111111
11111111
11111111
NAME T_EL87

TIL 3g
01100000
00000000
01100000
00000000
00000000
00000000
00000000
00000000
NAME T_EL88

TIL 3h
00110000
00000000
00110000
00000000
00000000
00000000
00000000
00000000
NAME T_EL89

TIL 3i
10100000
10100000
10100000
10100000
10100000
11111111
00000000
00000000
NAME T_EL90

TIL 3j
10100000
10100100
10111111
10100000
10111111
10100000
10100000
10100000
NAME T_EL91

TIL 3k
00000000
00000000
00000000
00000000
11111111
10100000
10100100
10101001
NAME T_EL92

TIL 3l
00000000
00000000
00000000
00000000
11111111
00010000
00100100
01001001
NAME T_EL93

TIL 3m
00000000
00000000
00000000
00000000
11110000
01010000
01010000
01010000
NAME T_EL94

TIL 3n
01010000
01010000
11010000
01010000
11010000
01010000
01010000
01010000
NAME T_EL95
WAL false

TIL 3o
01010000
01010000
01010000
01010000
01010000
11110000
00000000
00000000
NAME T_EL96
WAL false

TIL 3p
00000000
00000000
00000000
00000000
00000000
11111111
00000000
00000000
NAME T_EL97

TIL 3q
00000010
00110100
11111111
01110000
11111111
00000000
00000000
00000000
NAME T_EL98

TIL 3r
11001100
11111111
01111000
00000000
00000000
00000000
00000000
00000000
NAME T_EL99

TIL 3s
11010010
11011110
11000000
11000000
11000000
11111110
11100110
11111110
NAME T_EL100

TIL 3t
01111111
11111101
01111011
11110111
11111111
11000000
11011110
11010010
NAME T_EL101
WAL false

TIL 3u
11111100
11111100
11111100
11110100
11101100
11010100
11101100
11010100
NAME T_EL102

TIL 3v
11100100
11000100
11000100
11000100
11000100
11000100
11000100
11001000
NAME T_EL103

TIL 3w
11010000
11100000
00000000
00000000
00000000
00000000
00000000
00000000
NAME T_EL104

TIL 3x
00000001
01111101
01000101
01000101
01000101
01000101
01000101
01111100
NAME T_EL105

TIL 3y
11111111
00000001
00000001
00000001
00000001
00000001
11111111
00000000
NAME T_EL106

TIL 3z
00000000
01111110
01000010
01000010
01000010
01000010
01111110
00000000
NAME T_EL107

TIL 4a
00000000
00000000
00000000
00000000
00000000
11111111
00000000
00000000
NAME T_EL118
WAL true

TIL 4b
00000000
00000000
00000000
00000000
00000000
00001111
00010000
00100000
NAME T_EL119

TIL 4c
00000000
00000000
00000000
00000000
00000000
11110000
00001000
00000100
NAME T_EL120

TIL 4d
01000000
10000000
00000000
00000000
00000000
00000000
00000000
00000000
NAME T_EL121

TIL 4e
00000010
00000001
00000000
00000000
00000000
00000000
00000000
00000000
NAME T_EL122

TIL 4f
00000000
00000000
00000001
00000010
00000100
00001000
00010000
00100000
NAME T_EL123

TIL 4g
00000000
00000000
10000000
01000000
00100000
00010000
00001000
00000100
NAME T_EL124

TIL 4h
01000000
11111111
10000000
10000000
10000000
10000000
11111111
00000000
NAME T_EL125

TIL 4i
00000010
11111111
00000001
00000001
00000001
00000001
11111111
00000000
NAME T_EL126

TIL 4j
00000000
11111111
00000000
00000000
00000000
00000000
11111111
00000000
NAME T_EL127

TIL 4k
00000000
00000000
00000000
01111000
01001110
01001110
01111110
00111110
NAME T_EL128

TIL 4l
00000000
00000000
00000000
01111111
01000000
01000000
01111111
00011111
NAME T_EL129

TIL 4m
00000000
00000000
00000000
11110000
00011000
00011000
11111000
11111000
NAME T_EL130

TIL 4n
00000000
00000000
00000000
01111111
01000000
01000000
01111111
00111111
NAME T_EL131

TIL 4o
00000000
00000000
00000000
11111111
00000000
00000000
11111111
11111111
NAME T_EL132

TIL 4p
00000000
00000000
00000000
11111100
00000110
00000110
11111110
11111110
NAME T_EL133

TIL 4q
00000000
00000000
01011101
00010100
00010100
11111111
00000000
11111111
NAME T_EL134

TIL 4r
00000001
00000011
00000110
00001100
00011000
00110000
01100000
11000000
NAME T_EL135

TIL 4s
00000001
00000011
00000010
00000010
00000110
00000110
00000100
00001100
NAME T_EL136

TIL 4t
00001000
00001000
00011000
00010000
00010000
00010000
00100000
00100000
NAME T_EL137

TIL 4u
00100000
00100000
00100000
00100000
01111111
01000000
01111111
01000000
NAME T_EL138

TIL 4v
10000000
11000000
01100000
00110000
00011000
00001100
00000110
00000011
NAME T_EL139

TIL 4w
10000000
11000000
01000000
01000000
01100000
00110000
00010000
00010000
NAME T_EL140

TIL 4x
00010000
00010000
00001000
00001000
00001000
00000100
00000100
00000100
NAME T_EL141

TIL 4y
00000100
00000100
00000100
00000100
11111110
00000010
11111110
00000010
NAME T_EL142

TIL 4z
00000000
00000000
00000000
00000000
11111111
00000000
11111111
00000000
NAME T_EL143

TIL 5a
00000000
00000000
00000000
00000000
00000001
00000010
00000100
00001000
NAME T_EL154

TIL 5b
00011000
00101000
01000001
10000010
00000100
00001000
00010000
00100000
NAME T_EL155

TIL 5c
01100001
10100010
00000101
00001001
00010010
00100010
01000100
10000100
NAME T_EL156

TIL 5d
11100011
11100011
00000100
00000100
00001001
00001001
00010001
00010010
NAME T_EL157

TIL 5e
01111100
10111100
10101010
10101010
00101001
00100101
00100100
00100100
NAME T_EL158

TIL 5f
11011000
01010100
00100010
00110001
00011000
00010100
10001010
10001001
NAME T_EL159

TIL 5g
11000011
10100010
00010000
00001000
10000100
01000010
00100001
00010000
NAME T_EL160

TIL 5h
00000000
10000000
01000000
00100000
00010000
00001000
00000100
10000010
NAME T_EL161

TIL 5i
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
NAME T_EL162

TIL 5j
00001000
00001000
00001000
00001000
00001000
00001000
00010000
00010000
NAME T_EL163

TIL 5k
00010000
00010000
00010000
00010000
00010000
00010000
00001000
00001000
NAME T_EL164

TIL 5l
00000100
00000100
00000100
00000100
00000100
00000100
00001000
00001000
NAME T_EL165

TIL 5m
00100000
00100000
00100000
00100000
00100000
00100000
00010000
00010000
NAME T_EL166

TIL 5n
00000000
00000000
00000000
00000011
00000010
00000010
00000010
00000100
NAME T_EL167

TIL 5o
00000000
00000000
00000000
11000000
01000000
01000000
01000000
00100000
NAME T_EL168

TIL 5p
00000000
00000000
00000000
11111111
00000000
00000000
00000000
00000000
NAME T_EL169

TIL 5q
01011010
01010100
01110010
01010010
01010010
01110010
01010100
01011010
NAME T_EL170

TIL 5r
01011010
00101010
01001110
01001010
01001010
01001110
00101010
01011010
NAME T_EL171

TIL 5s
00000000
11111111
00100100
11111111
10000001
01000010
10111101
00000000
NAME T_EL172

TIL 5t
00000000
00000011
00000011
00001111
00001000
00001000
00111111
00000000
NAME T_EL173
WAL true

TIL 5u
00000000
11000000
11000000
11110000
00010000
00010000
11111100
00000000
NAME T_EL174
WAL true

TIL 5v
00001111
00000111
00001100
00001000
00001111
00001111
00001111
00000000
>
00001111
00000111
00001100
00001000
00001111
00001000
00001111
00000000
NAME T_EL175
WAL true

TIL 5w
11110000
11100000
00110000
00010000
11110000
11110000
11110000
00000000
>
11110000
11100000
00110000
00010000
11110000
00010000
11110000
00000000
NAME T_EL176
WAL true

TIL 5x
00000000
00000000
00000000
00000000
00000000
11111111
01010101
10101010
NAME T_EL177

TIL 5y
01000000
01000000
01000000
01000000
01000000
01111111
01010101
10101010
NAME T_EL178

TIL 5z
00000010
00000010
00000010
00000010
00000010
11111110
01010101
10101010
NAME T_EL179

TIL 6a
00000001
00000010
00000100
00001000
00010000
00101010
00100000
00100000
NAME T_EL190

TIL 6b
10000000
01000000
00100000
00010000
00001000
01010100
00000100
00000100
NAME T_EL191

TIL 6c
00100000
00100000
00100000
00100000
00100000
00100000
00100000
00100000
NAME T_EL192

TIL 6d
00000100
00000100
00000100
00000100
00000100
00000100
00000100
00000100
NAME T_EL193

TIL 6e
01010000
01010000
01010000
01010000
01010000
01010000
01010000
01010000
NAME T_EL194

TIL 6f
00001010
00001010
00001010
00001010
00001010
00001010
00001010
00001010
NAME T_EL195

TIL 6g
00000000
00000111
00001000
00010000
00010010
00010000
00001000
00000111
NAME T_EL196

TIL 6h
00000000
11100000
00010000
00001000
01001000
00001000
00010000
11100000
NAME T_EL197

TIL 6i
00000100
00001110
00110001
01010000
01010000
11111111
00000000
11111111
NAME T_EL198

TIL 6j
00100000
01110000
10001100
00101010
00001010
11111111
00000000
11111111
NAME T_EL199

TIL 6k
11111110
11111110
11111010
11110010
11100110
11001010
10010010
00100010
NAME T_EL200

TIL 6l
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000001
NAME T_EL201

TIL 6m
11111110
11111100
11111001
11110010
11100100
11001000
10010000
00100001
NAME T_EL202

TIL 6n
11111110
10000010
10000011
11111110
11111110
10000010
10000010
11111111
NAME T_EL203

TIL 6o
01000011
10000110
00001101
00011010
00110101
01101010
11010101
10101010
NAME T_EL204

TIL 6p
00000001
00000011
00000111
00001111
00011111
00111111
01111111
11111111
NAME T_EL205

TIL 6q
01111111
01111111
01011111
01001111
01100111
01010011
01001001
01000100
NAME T_EL206

TIL 6r
01111111
00111111
10011111
01001111
00100111
00010011
00001001
10000100
NAME T_EL207

TIL 6s
01000010
10100001
01010000
10101000
01010100
10101010
01010101
10101010
NAME T_EL208

TIL 6t
01111111
01000001
11000001
01111111
01111111
01000001
01000001
11111111
NAME T_EL209

TIL 6u
10000000
11000000
11100000
11110000
11111000
11111100
11111110
11111111
NAME T_EL210

TIL 6v
01000010
10100001
01010000
10101000
01010100
10101010
01010101
10101010
NAME T_EL211

TIL 6w
01010100
10101000
01010000
10100000
01000000
10000000
00000000
00000000
NAME T_EL212

TIL 6x
01010101
00101010
00010101
00001010
00000101
00000010
00000001
00000000
NAME T_EL213

TIL 6y
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
NAME T_EL214
WAL true

TIL 6z
10111101
10111010
00110101
11101011
00000000
00000000
00000000
00000000
NAME T_EL215
WAL true

TIL CL14
00000000
00000000
00000000
00000000
00000000
00000000
11111111
11111111

TIL CL16
00000000
00000000
00111111
01000000
10000000
10000000
10000000
10000000

TIL CL17
00000000
00000000
11111111
00000000
00000000
00000000
00000000
00000000

TIL CL18
00000000
00000000
11111000
00000100
00000010
00000010
00000010
00000010

TIL CL20
11000000
11000000
11000000
11000000
11000000
11000000
11111111
11111111

TIL CL21
00000001
00000011
00000111
00001111
00011111
00111111
01111111
11111111

TIL CL22
11111111
11111111
11111111
11111111
11111111
11111111
11111111
11111111

TIL CL23
00000011
00000011
00000011
00000011
00000011
00000011
00000011
00000011

TIL CL24
11111111
11111111
11111111
11111011
11110011
11100011
11000011
10000011

TIL CL27
00000001
00000010
00000100
00001000
00010000
00100000
01000000
10000000

TIL CLh
00000000
00000000
00000000
11111111
11111111
11111111
11111111
11111111

TIL CLi
11111111
11111111
11111111
11111111
11111111
11111111
11111111
11111111

TIL CLj
11111110
11111100
11111000
11110000
11100000
11000000
10000000
00000000

TIL CLo
11000000
11000000
11000000
11000000
11000000
11000000
11000000
11000000

TIL CLt
10000000
10000000
10000000
10000000
10000000
10000000
10000000
11111111

TIL CLx
00000000
00010000
00010000
01111100
00010000
00010000
00000000
00000000

TIL CLy
00000000
00100010
01111000
00001100
10101100
01111100
00110100
00000000

TIL CL1a
11111111
11111111
10111101
11100111
11100111
10111101
11111111
11111111

TIL CL1b
00010011
01111111
00101111
00100011
01010011
00000011
01111011
01010011

TIL CL1c
01100011
01010011
00000011
00011011
00000011
00001111
00000011
11100011

TIL CL1d
01000011
11100011
01001011
01100011
01011011
01010111
11111111
11111111

TIL CL1e
11010000
11001100
11010100
11010010
11101000
11010010
11111111
11111111

TIL CL1f
11000110
11011010
11001001
11001110
11011110
11000000
11110010
11000100

TIL CL1g
11001100
11000000
11000000
11010100
11000000
11100000
11000010
11000000

TIL CL1i
00000010
00000010
00000010
00000010
00000010
00000010
00000010
00000010

TIL CL1j
01111111
01111111
01111111
01111111
01111111
01111111
01111111
00000000

TIL CL1l
11111110
11111110
11111110
11111110
11111110
11111110
11111110
00000000

TIL CL1m
00000000
00000000
00000000
00000000
00000000
01111111
01111111
01111111

TIL CL1o
00000000
00000000
00000000
00000000
00000000
11111110
11111110
11111110

TIL CL1q
10000000
10000000
10000000
10000000
10000000
10000000
10000000
10000000

TIL CL1t
00000010
00000010
00000010
11111111
11111111
11111111
11111111
11111111

TIL CL1u
00000010
00000010
00000010
00000010
00000010
00000010
00000010
00000010

TIL CL1v
11000000
11000000
11000000
11000000
11000000
11000000
11000000
11000000

TIL CL1w
11111111
11111111
11000000
11000000
11000000
11000000
11000000
11000000

TIL CL1x
11111111
11111111
00000011
00000011
00000011
00000011
00000011
00000011

TIL CL1y
00000011
00000011
00000011
00000011
00000011
00000011
00000011
00000011

TIL CL1z
00000011
00000011
00000011
00000011
00000011
00000011
11111111
11111111

TIL CL2a
00000011
00000011
00000011
00000011
00110011
00000011
00000011
00000011

TIL CL2b
11111111
10000000
10001000
10001000
10111110
10001000
10001000
10000000

TIL CL2c
11111111
00000001
00000001
00111101
00101001
01100001
00101001
00111001

TIL CL2d
00111001
00100001
01100101
01000001
11010001
00101001
00010011
11111111

TIL CL2e
00001000
00001000
00111110
00001000
00001000
00000000
11111111
00000000

TIL CL2f
10000000
10000000
01111110
11000010
11000010
11111111
11111111
00000000

TIL CL2g
11111111
11111111
11111111
11111111
11111111
11111111
11111111
11111111

TIL CL2h
11111111
11111111
11111111
11111111
11111111
11111111
11111111
00000000

TIL CL2i
00000111
00000111
00000111
00001111
00010111
00110111
01101111
11011111

TIL CL2j
11111111
11111111
11111111
11111111
11111111
11111111
11111111
00000111

TIL CL2k
11111111
11111111
11111111
11111111
11111111
11111111
11111111
11000000

TIL CL2l
11000000
11011111
11011111
11011111
11011111
11001111
11100111
11110011

TIL CL2m
00000001
00000011
00000111
00001111
00011111
00111111
01111111
11111111

TIL CL2o
11000000
11000000
11000000
11000000
11000000
11000000
11000000
11000000

TIL CL2p
00000000
00000000
00000000
11110000
11100000
11000000
10000000
00000000

TIL CL2q
11111111
11111111
11000000
11010100
11000000
11001000
11010010
11010101

TIL CL2r
11000000
11010000
11010000
11011100
11000000
11110000
11001100
11000100

TIL CL2s
11111111
11111111
00000011
01100011
10010011
00010011
00100011
01000011

TIL CL2t
11111111
11111111
00000000
00000000
00000000
00000001
00000010
00000100

TIL CL2u
10000011
00000011
00000011
00000011
00000011
00000011
00000011
00000011

TIL CL2v
10000011
00001011
00011011
01100011
01100011
00010011
00010011
00000011

TIL CL2w
00011011
00000011
01100011
00000011
00110011
00000011
11111111
11111111

TIL CL2x
11111111
10000001
10111101
10100101
10100101
10111101
10000001
11111111

TIL cl2y
11000000
01000000
00100000
10100000
10110000
11001000
01111110
10111000
NAME key2_tile

TIL cl2z
00101010
00000001
10101000
00000101
10100000
00010101
10000000
01010100
NAME Fill in Room

TIL ty30
11100000
01000000
01000000
01000000
01000000
01000000
01000000
11101110
NAME Type1

TIL ty31
10100100
10101010
10101010
11101110
10101010
10101010
10101010
10101010
NAME Type2

TIL ty32
11000000
10100000
10100000
10100000
10100000
10100000
10100000
11001110
NAME Type3

TIL ty33
11100100
01001010
01001010
01001010
01001010
01001010
01001010
01000100
NAME Type4

TIL ty34
00001110
00001000
00001000
00001110
00001000
00001000
00001000
11101110
NAME Type5

TIL ty35
10101100
10101010
10101010
01001010
01001100
10101000
10101000
10101000
NAME Type6

TIL ty36
01000100
10101010
10101000
10100100
10100010
10100010
10101010
01000100
NAME Type7

TIL ty37
11100000
10000000
10000000
11100000
10000000
10000000
10000000
11101110
NAME Type8

TIL ty38
11101010
01001010
01001010
01001110
01001010
01001010
01001010
01001010
NAME Type9

TIL ty39
11100100
01001010
01001000
01000100
01000010
01000010
01001010
11100100
NAME Type10

TIL ty3a
10010010
10010101
11010101
10110101
10010101
10010101
10010101
10010010
NAME Type11

TIL ty3b
01110000
00100000
00100000
00100000
00100000
00100000
00100000
00100111
NAME Type12

TIL ty3c
00100100
01010100
01010110
01010101
01010100
01010100
01010100
00100100
NAME Type13

TIL ty3d
10100010
10100010
10100010
10100001
10100001
10100001
10100001
10111001
NAME Type14

TIL ty3e
10000011
10000010
10000010
00000011
00000010
00000010
00000010
00111010
NAME Type15

TIL ty3f
10010011
00101010
00101010
10101011
00101011
00101010
00101010
00010010
NAME Type16

TIL ty3g
00000011
10000001
10000001
10000001
00000001
10000001
10000001
10111001
NAME Type17

TIL ty3h
10101011
00101010
00101010
00111011
00101010
00101010
00101010
00101011
NAME Type18

TIL ty3i
10000011
00000001
00000001
10000001
00000001
00000001
00000001
10111001
NAME Type19

TIL ty3j
10110010
00101010
00101010
00111010
00110010
00101010
00101010
00101011
NAME Type20

TIL ty3k
10111010
10010010
10010010
10010011
10010010
10010010
10010010
10010010
NAME Type21

TIL ty3l
10000000
10000000
10000000
10000000
10000000
10000000
10000000
10000000
NAME Type22

TIL ty3m
11001010
10101010
10101010
11001010
10101010
10101010
10101010
11001110
NAME Type23

TIL ty3n
11100000
01000000
01000000
01000000
01000000
01000000
01000000
01001110
NAME Type24

TIL ty3o
01001000
10101000
10101000
11101000
10101000
10101000
10101000
10101110
NAME Type25

TIL ty3p
01000100
10101010
10001010
01001010
00101010
00101010
10101010
01000100
NAME Type26

TIL ty3q
00001110
00001000
00001000
00001110
00001000
00001000
00001000
11101000
NAME Type27

TIL ty3r
01001110
10101010
10101010
10101100
10101110
10101010
10101010
01001010
NAME Type28

TIL ty3s
00001110
00000100
00000100
00000100
00000100
00000100
00000100
11100100
NAME Type29

TIL ty3t
10101110
10101000
10101000
11101110
10101000
10101000
10101000
10101110
NAME Type30

TIL ty3u
00001010
00001010
00001010
00001010
00001010
00001010
00001010
11100100
NAME Type31

TIL ty3v
11101110
01001000
01001000
01001000
01001000
01001000
01001000
11101110
NAME Type32

TIL ty3w
11101110
01000100
01000100
01000100
01000100
01000100
01000100
01001110
NAME Type33

TIL ty3x
10100100
11101010
11101000
10100100
10100010
10100010
10101010
10100100
NAME Type34

TIL ty3y
00000000
00000000
00000000
00000000
00000000
00000000
00000000
10000000
NAME Type35

TIL p72
11111111
11111111
11111110
11111100
11111000
11110000
11100000
11000000

TIL p73
10000000
10000000
10000000
10000000
10000000
10000000
10000000
10000000
NAME L

TIL p74
00000001
00000001
00000001
00000001
00000001
00000001
00000001
00000001

TIL p75
00000001
00000011
00000111
00001111
00011111
00111111
01111111
11111111

TIL p76
11111111
11111111
00000000
00000000
00000000
00000000
00000000
00000000

TIL p77
11111111
11111111
01111111
00111111
00011111
00001111
00000111
00000011
NAME 

TIL p78
11111111
11111111
11111110
11111100
11111000
11110000
11100000
11111111

TIL p79
11111111
11111111
11111111
11111111
11111111
11111111
11111111
11111111
WAL true

TIL p81
10000000
11111111
00000000
00000000
00000000
00000000
00000000
00000000
NAME 

TIL p82
11111111
11111111
11111111
11111111
11111111
11111111
11111111
11111111
NAME 
WAL false

TIL p84
10000000
11000000
01100000
00110000
00011000
00001100
00000110
00000011
NAME 

TIL p85
10000000
10000000
10000000
10000000
10000000
10000000
10000000
10000000

TIL p86
11000000
11100000
10110000
10011000
10001100
10000110
10000011
10000001

TIL p87
10000000
10000000
10000000
10000000
10000000
10000000
10000000
10000000

TIL p88
00000001
00000011
00000110
00001100
00011000
00110000
01100000
11000000

TIL p89
10000000
11000000
01100000
00110000
00011000
00111000
01101000
11001000
NAME 

TIL p90
00000001
00000010
00000100
00001000
00010000
00100000
01000000
10000000

TIL p91
10000000
01000000
00100000
00010000
00001000
00000100
00000010
00000001

TIL p92
00000001
00000010
11110100
11111000
11110000
11110000
00000000
00000000

TIL p93
10000000
01000000
00101111
00011111
00001111
00001111
00000000
00000000

TIL p94
11111111
11111111
11111111
11111111
11111111
11111111
11111111
11111111
WAL true

TIL p95
10000000
10000000
10000000
10000000
10000000
10000000
10000000
10000000
NAME L

TIL p96
00000001
00000001
00000001
00000001
00000001
00000001
00000001
00000001

TIL p97
11111111
10000000
10000000
10000000
10000000
10000000
10000000
10000000
NAME 

TIL p98
11111111
00000001
00000001
00000001
00000001
00000001
00000001
00000001

TIL p99
11111111
00000000
00000000
00000000
00000000
00000000
00000000
00000000

TIL p80
00000001
11111111
00000000
00000000
00000000
00000000
00000000
00000000

TIL p7a
00000000
00000000
00000000
00000000
00000000
00000000
00000000
11111111

TIL p7b
10000000
00000000
00000000
00000000
00000000
00000000
11111111
11111111

TIL p7c
00000001
00000000
00000000
00000000
00000000
00000000
00000000
00000000

TIL p7d
10000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000

TIL p7e
00000000
00000000
00000000
11111111
10101010
10101010
10101010
11111111

TIL p7g
00000000
00000000
00000000
10000000
10000000
10000000
10000000
10000000

TIL pp7h
01111111
01111111
00000000
00000000
00000000
00000000
00000000
00000000
NAME 

TIL p7i
11111111
11111111
00000000
00000000
00000000
00000000
00000000
00000000

TIL p7j
11111110
11111110
00000000
00000000
00000000
00000000
00000000
00000000

TIL p7k
00011111
00011111
00111100
00111000
01110000
11100000
11000000
11000000

TIL p7l
11111000
11111000
00011100
00011110
00001110
00000111
00000011
00000011

TIL p7m
00000011
00000111
00001100
00011000
00011000
00011000
00011000
00011000

TIL p7n
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000001

TIL p7o
00000000
00000000
00000000
00000000
00000000
00000000
00000000
10000000

TIL p7p
11000000
01100000
00110000
00111000
00011000
00011000
00011000
00011000
NAME 

TIL p7q
00011000
00011000
00011000
00011000
00011000
00011000
00011000
00011000

TIL p7r
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000

TIL p7s
00011000
00011000
00011000
00011000
00011111
00011111
00000000
00000000
NAME Lii

TIL p7t
00011000
00011000
00011000
00011000
11111000
11111000
00000000
00000000

TIL p7u
00000000
00000000
00000000
00000000
11111111
11111111
00000000
00000000

TIL p7v
00000000
11111111
00000000
00000000
00000000
00000000
00000000
00000000

TIL p7w
00000000
11111111
10000000
10000000
10000000
10000000
10000000
10000000

TIL p7x
10000000
10000000
10000000
10000000
10000000
10000000
10000000
10000000
NAME 

TIL p7y
00000000
11111111
00000001
00000001
00000001
00000001
00000001
00000001
NAME 

TIL p7z
00000001
00000001
00000001
00000001
00000001
00000001
00000001
00000001

TIL p8a
00001000
00011000
00101000
01011000
10110000
01100000
11000000
10000000

TIL p8b
10000001
10000011
10000110
10001100
10011000
10110000
11100000
11000000
NAME 

TIL p8c
00000001
00000011
00000110
00001100
00011000
00011100
00010110
00010011

TIL p8d
00010000
00010000
00010000
00011000
00001100
00000110
00000011
00000001

TIL p8e
00101000
01011000
10101000
01001000
10110000
01100000
11000000
10000000

TIL p8f
00010101
00101011
01010110
10101100
01011000
10110000
01100000
11000000

TIL p8g
10010101
10101010
11010110
10101100
11011000
10110000
11100000
11000000

TIL p8h
00000001
00000011
00000110
00001100
00011001
00110010
01100101
11001010

TIL p8i
00000001
00000011
00000110
00001100
00011001
00110010
01100101
11001010

TIL p8j
10000000
11111000
01001100
01100110
10010010
00001010
00001110
00010011

TIL p8k
00001000
00010000
00100000
01010001
11001010
11100100
00111000
00110000

TIL p8l
00000000
00000000
00000000
00000000
00000000
00000001
00000010
00000100

TIL p8m
00100000
01000000
10000000
00000000
00000000
00000000
00000000
00000000

TIL p8n
00000000
00000000
00000000
00000011
00000111
00001101
00011111
00011111

TIL p8o
11110000
10110000
11100000
11000000
10000000
00000000
00000000
00000000

TIL p8p
00011111
00011011
00001111
00000111
00000011
00000000
00000000
00000000

TIL p8q
11111111
00000000
00000000
00000000
00000000
00000000
00000000
00000000
NAME 

TIL p8r
11111111
10000000
10000000
10000000
10000000
10000000
10000000
10000000

TIL p8s
11111111
00000001
00000001
00000001
00000001
00000001
00000001
00000001

TIL p8t
10000000
10000000
10000000
10000000
10000000
10000000
10000000
10000000

TIL p8u
00000001
00000001
00000001
00000001
00000001
00000001
00000001
00000001

TIL p8v
00000001
00000001
00000001
00000001
00000001
00000001
00000001
11111111

TIL p8w
10000000
10000000
10000000
10000000
10000000
10000000
10000000
11111111
NAME =

TIL p8x
00000000
00000000
00000000
00000000
00000000
00000000
00000000
11111111

TIL p8y
11111111
11000000
10100000
10010000
10001000
10000100
10000010
10000001

TIL p8z
11111111
00000011
00000101
00001001
00010001
00100001
01000001
10000001
NAME 

TIL p9a
00000001
11111111
10000000
01000000
00111111
00000000
00000000
00000000

TIL 9b
00000000
00000000
00000000
00000000
11111111
00000000
00000000
00000000

TIL p9d
00000001
10000010
10000100
01001000
11110000
00000000
00000000
00000000

TIL p9e
00000000
11111111
00000000
00000000
11111111
00000000
00000000
00000000

TIL p9f
00000011
00000111
00000110
00000110
00000110
00000000
00000000
00000000

TIL p9g
00000000
00000000
00000000
00000000
00000000
01111111
11111111
11000000

TIL p9h
00000000
00000000
00000000
00000000
00000000
00000000
00000001
00000011

TIL p9i
00000000
00000000
00000000
00000000
00000000
11100000
11110000
00111000

TIL p9j
00001100
00000110
00000110
00000110
00000110
00000110
00000110
00000110

TIL p9k
00001100
00001100
00011100
00011000
00111000
01110000
11100000
11000000

TIL p9l
00000000
00000000
00000000
00000000
00000000
00000000
00000011
00000011

TIL p9m
00000011
00000011
00000011
00000011
00000000
00000000
00000011
00000011

TIL p9n
00000011
00000011
00000011
00000000
00000000
00000000
00000000
00000000

TIL p9o
11111111
00000000
11111111
00000000
00000000
00000000
00000000
00000000
NAME 

TIL p9p
00000000
00000000
00000000
00000000
00000000
11111111
00000000
11111111

TIL p9q
11111111
10000000
10111111
10100000
10100000
10100000
10100000
10100000
NAME 

TIL p9r
10100000
10100000
10100000
10100000
10100000
10111111
10000000
11111111

TIL p9s
11111111
00000001
11111101
00000101
00000101
00000101
00000101
00000101
NAME T

TIL p9t
00000101
00000101
00000101
00000101
00000101
11111101
00000001
11111111

TIL p9u
00000101
00000101
00000101
00000101
00000101
00000101
00000101
00000101

TIL p9v
10100000
10100000
10100000
10100000
10100000
10100000
10100000
10100000

TIL p9w
00111100
01111110
01111110
11111111
11111111
01111110
01111110
11111111

TIL p9x
11111111
11111111
11111111
11111111
11111111
11111111
11111111
11111111

TIL p9y
00000111
00001111
00011111
00111111
00111111
00111111
00111111
00111111

TIL p9z
11000000
11100000
11111000
11111100
11111100
11111100
11111100
11111100

TIL pa0
00111111
00111111
00111111
00111111
00111111
00111111
00111111
00111111
NAME L

TIL pa1
11111100
11111100
11111100
11111100
11111100
11111100
11111100
11111100

TIL pa2
00000000
00000000
01111100
01111100
11111110
11111110
01111100
00111000

TIL pa3
00111000
01111100
11111110
11110010
11110010
11111110
11111110
11111110

TIL pa4
00011000
00111100
00111100
01111110
01111110
00111100
01011010
10011001

TIL pa5
00011000
00111100
01111110
01110111
11111111
11111111
11111111
11111111

TIL pa6
11111111
11011101
11111111
11110111
10111111
11111011
11111111
11011111
NAME i

TIL pa7
10000000
11000000
01000000
11100000
11110000
01111000
11011100
01110110

TIL pa8
00000001
00000010
00000111
00001111
00011011
00111111
01101101
11111111

TIL pa9
00000001
00000001
00000001
11000011
11000011
11000100
01100100
00111000

TIL paa
00000001
00000001
00000001
00000001
00000001
00000001
00000001
00000001

TIL pab
00001111
00011110
00011111
00001111
00001111
00000111
00000001
00000001

TIL pac
11000000
01100000
11100000
01000000
11000000
10000000
00000000
00000000

TIL pad
10000000
10000000
10000000
10000000
10000000
10000000
10000000
10000000

TIL pae
00000001
00000001
00000001
00000001
00000001
00000001
00000001
00000001

TIL paf
00000001
00000001
00000001
00000001
00000001
00000001
00000001
11111111

TIL pag
10000000
10000000
10000000
10000000
10000000
10000000
10000000
11111111

TIL pah
11111111
11111111
11111111
11111111
11111111
11111111
11111111
11111111
WAL true

TIL pai
11111111
10000000
10000000
10000000
10000000
10000000
10000000
10000000

TIL paj
11111111
00000001
00000001
00000001
00000001
00000001
00000001
00000001

TIL pak
11111111
00000000
00000000
00000000
00000000
00000000
00000000
00000000

TIL pal
00000000
00000000
00000000
00000000
00000000
00000000
00000000
11111111

TIL pam
00000000
00000000
00111111
00100000
00100000
00100000
00100000
00100000

TIL pan
00100000
00100000
00100000
00100000
00100000
00100000
00100000
00100000

TIL pao
00100000
00100000
00100000
00100000
00111111
00000000
00000000
00000000

TIL pap
00000000
00000000
00000000
00000000
11111111
00000000
00000000
00000000

TIL paq
00001000
00001000
00001000
00001000
11111000
00000000
00000000
00000000

TIL par
11111111
10000000
10000000
10000000
10000000
10000000
10000000
10000000

TIL pas
11111111
10000000
10000000
10001111
10001111
10011111
10011111
10001111

TIL pat
11111111
00000001
00000001
11000001
11000001
11100001
11100001
11000001

TIL pau
10001111
10000111
10000011
10000011
10001111
10011111
10111111
10111111

TIL pav
11000001
10000001
10000001
11000001
11100001
11110001
11111001
11111001

TIL paw
10111111
10111111
10111111
10111111
10011111
10000000
10000000
11111111

TIL pax
11111001
11111001
11111001
11110001
11110001
00000001
00000001
11111111

TIL pay
00000000
01111111
00000000
01111111
00000000
01111111
00000000
00000000

TIL paz
00000000
11111100
00000000
11111100
00000000
11111100
00000000
00000000

TIL pb0
00000000
11111111
00000000
11111111
00000000
11111111
00000000
00000000

TIL pb1
11111111
11111111
11111111
11111111
11111111
11111111
00000000
00000000

TIL pb2
11111111
11111111
11111111
11111111
11111111
11111111
11111111
11111111

TIL pb3
00000111
00001111
00011111
00111111
01111111
11111111
11111111
11111111

TIL pb4
11100000
11110000
11111000
11111100
11111110
11111111
11111111
11111111

TIL pb5
11000000
11000000
11000000
11000000
11000000
11000000
11000000
11000000

TIL pb6
00000011
00000011
00000011
00000011
00000011
00000011
00000011
00000011

TIL pb7
00000111
00001111
00111000
01100000
11000000
11000000
11000000
11000000

TIL pb8
11110000
11111000
00001100
00000110
00000011
00000011
00000011
00000011

TIL pb9
11111111
11111111
00000000
00000000
00000000
00000000
00000000
00000000

TIL pba
11111100
11111100
11111100
11000000
11000000
11000000
11111100
11111100

TIL pbb
00111111
00111111
00111111
00000011
00000011
00000011
00111111
00111111

TIL pbc
11111100
11111100
11111111
11111111
11111111
11111111
11111111
11111111

TIL pbd
00111111
00111111
11111111
11111111
11111111
11111111
11111111
11111111

TIL pbe
11111111
11111111
11111111
11111111
11111111
00000000
11111111
11111111

TIL pbf
11111111
10000000
10111111
10100000
10100000
10100000
10100000
10100000

TIL pbg
11111111
00000001
11111101
00000101
00000101
00000101
00000101
00000101

TIL pbh
11111111
00000000
11111111
00000000
00000000
00000000
00000000
00000000

TIL pbi
10100000
10100000
10100000
10100000
10100000
10100000
10100000
10100000

TIL pbj
00000101
00000101
00000101
00000101
00000101
00000101
00000101
00000101

TIL pbk
10100000
10100000
10100000
10100000
10100000
10111111
10000000
11111111

TIL pbl
00000101
00000101
00000101
00000101
00000101
11111101
00000001
11111111

TIL pbm
00000000
00000000
00000000
10111101
00000000
11111111
00000000
11111111

TIL pbn
00000111
00000111
00000111
00000111
00000111
00000111
00000111
00000111

TIL pbo
11110000
11110000
11110000
11110000
11110000
11110000
11110000
11110000

TIL pbp
00000111
00001111
00011111
00111111
01111111
11111111
11111111
00000000

TIL pbq
11110000
11111000
11111100
11111110
11111111
11111111
11111111
00000000

TIL pbr
01111111
01000000
01000000
01000000
01000000
01000000
01000000
01000000

TIL pbs
01000000
01000000
01000000
01000000
01000000
01000000
01000000
01000000

TIL pbt
01000000
01000000
01000000
01000000
01000000
01111111
00000000
00000000

TIL pbu
00000000
00000000
00000000
00000000
00000000
11111111
00000000
00000000

TIL pbv
00000100
00000100
00000100
00000100
00000100
11111100
00000000
00000000

TIL pbw
00000100
00000100
00000100
00000100
00000100
00000100
00000100
00000100

TIL pbx
11111100
00000100
00000100
00000100
00000100
00000100
00000100
00000100

TIL pby
11111111
00000000
00000000
00000000
00000000
00000000
00000000
00000000

TIL pbz
11111111
00000000
00111111
00000000
00111111
00000000
00111111
00000000

TIL pc0
11111111
00000000
11111111
00000000
11111111
00000000
11111111
00000000

TIL pc1
11111111
00000000
11111000
00000000
11111000
00000000
11111000
00000000

TIL pc2
01000000
01000000
01111111
01111111
01111111
01111111
01111111
01000000

TIL pc3
00000000
00000000
11111110
11111110
11111110
11111110
11111110
00000000

TIL pc4
00000000
01000010
00110000
00111111
00111111
10111111
00111110
00000010

TIL pc5
10000000
10101000
11111000
11110100
11110010
01111000
00011100
01000000

TIL pc6
00000100
11110100
11110100
11110100
00000100
11111100
00000000
00000000

TIL pc7
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000

TIL c8
11111111
00000000
00000000
00000000
00000000
00000000
00000000
00000000

TIL c9
11111111
10000000
10000000
10000000
10000000
10000000
10000000
10000000

TIL pca
10000000
10000000
10000000
10000000
10000000
10000000
10000000
10000000

TIL pcb
10000000
10000000
10000000
10000000
10000000
10000000
10000000
11111111

TIL pcc
00000000
00000000
00000000
00000000
00000000
00000000
00000000
11111111

TIL pcd
00000001
00000001
00000001
00000001
00000001
00000001
00000001
11111111

TIL pce
00000001
00000001
00000001
00000001
00000001
00000001
00000001
00000001

TIL pcf
00000000
00000000
00000000
11111111
00000001
00000001
00000001
00000001

TIL pcg
00000000
00000000
00000000
00111111
00100000
00100000
00100000
00100000

TIL pch
11100000
00000000
00000000
00000000
00000000
00000000
00000000
00000000

TIL pci
00000000
00000000
00000000
00000000
01111111
01111111
01111111
01111111

TIL pcj
00000000
00000000
00000000
00000000
11111111
11111111
11111111
11111111

TIL pck
00000000
00000000
00000000
00000000
11111111
11111111
11111111
11111111

TIL pcl
00000000
00000000
00000000
00000000
11111100
11111100
11111100
11111100

TIL pcm
00000000
00000000
00000000
00000000
00000000
00000000
11111111
00000001

TIL pcn
00000000
00000000
00000000
00000000
00000000
00000000
00011111
00010000

TIL pco
00010000
00010000
00010000
00010000
00010000
00010000
00010000
00010000

TIL pcp
00010000
00010000
00010000
00010000
00010000
00011111
00000000
00000000

TIL pcq
00000000
00000000
11111111
11111111
11111111
11111111
00000000
00000000

TIL pcr
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000

TIL pcs
11111111
10000000
11111111
11111111
11111111
11111111
10000000
11111111

TIL pct
11111111
00000001
11111111
11111111
11111111
11111111
00000001
11111111

TIL pcu
11111111
10000000
10000000
10000000
10000000
10000000
10000000
10000000

TIL pcv
10000000
10000000
10000000
10000000
10000000
10000000
10000000
10000000

TIL pcw
10000000
10000000
10000000
10000000
10000000
10000000
10000000
11111111

TIL pcx
00000000
00000000
00000000
00000000
00000000
00000000
00000000
11111111

TIL pcy
11111111
00000000
00000000
00000000
00000000
00000000
00000000
00000000

TIL pcz
11111111
00000001
00000001
00000001
00000001
00000001
00000001
00000001

TIL pd0
00000001
00000001
00000001
00000001
00000001
00000001
00000001
11111111

TIL pd1
00000001
00000001
00000001
00000001
00000001
00000001
00000001
00000001

TIL pd2
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000

TIL pd3
00000100
00000100
00000100
00000100
00000100
00000100
00000100
11111100

TIL pd4
00000100
00000100
00000100
00000100
00000100
00000100
00000100
00000100

TIL pd5
00000000
00000000
11111100
00000100
00000100
00000100
00000100
00000100

TIL pd6
00000000
00000000
11111111
00000000
00000000
00000000
00000000
00000000

TIL pd7
00000000
00000000
00001111
00001000
00001000
00001000
00001000
00001000

TIL pd8
11111111
00000000
11111111
00000000
00000000
00000000
00000000
00000000

TIL pd9
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000

TIL pda
11000001
00000001
11000001
00000001
00000001
00000001
00000001
00000001

TIL pdb
10000011
10000000
10000011
10000000
10000000
10000000
10000000
10000000

TIL pdc
11111111
11111111
11111111
11111111
00000000
00000000
00000000
00000000

TIL pdd
01111111
01111111
01111111
01111111
01111111
01111111
01111111
01111111

TIL pde
11100001
11100001
11100001
11100001
11100001
11100001
11100001
11100001

TIL pdf
00000000
00000000
11111111
00000000
11111111
00000000
11111111
00000000

TIL pdg
00000000
00000000
11111100
00000000
11111100
00000000
11111100
00000000

TIL pdh
10000000
10000000
10000000
10000000
10000000
10000000
10000000
10000000

TIL pdi
11111111
10000000
10000000
10000000
10000000
10000000
10000000
10000000

TIL pdj
11111111
00000000
00000000
00000000
00000000
00000000
00000000
00000000

TIL pdk
11111111
00000001
00000001
00000001
00000001
00000001
00000001
00000001

TIL pdl
00000001
00000001
00000001
00000001
00000001
00000001
00000001
00000001

TIL pdm
00000001
00000001
00000001
00000001
00000001
00000001
00000001
11111111

TIL pdn
10000000
10000000
10000000
10000000
10000000
10000000
10000000
11111111

TIL pdo
00000000
00000000
00000000
00000000
00000000
00000000
00000000
11111111

TIL pdp
00000000
00000000
00000000
00000000
01111000
10000110
10000010
10000001

TIL pdq
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000

TIL pdr
10000000
10000000
10000000
10000000
10111000
11000100
10000010
10000011

TIL pds
00000000
00000000
00000000
00000000
01111000
10000110
10000010
10000001

TIL pdt
10000000
01000000
00100000
00011111
00000000
00000000
00000000
00000000

TIL pdu
00000000
10101011
00000000
11111111
00000000
00000000
00000000
00000000

TIL pdv
00101000
10101000
00001000
11111000
00000000
00000000
00000000
00000000

TIL pdw
00101000
00001000
00101000
00001000
00101000
00001000
00101000
00101000

TIL pdx
00000000
00000000
00000000
11111000
00001000
00101000
00001000
00001000

TIL pdy
11111111
11111111
11111111
00000000
00000000
00000000
00000000
00000000

TIL pdz
11111101
11111101
11111101
00000001
00000001
00000001
00000001
00000001

TIL pe0
00000000
00000000
11111111
00000000
11111111
00000000
11111111
00000000

TIL pe1
10000000
10000000
10000000
11111111
10000000
11111111
10000000
11111111

TIL pe2
00000000
00000000
00000000
11111111
00000000
11111111
00000000
11111111

TIL pe3
00011000
00011111
00111111
00111111
01111111
11111111
11111111
11111111

TIL pe4
00000011
00010111
00001111
00011111
00111111
01111111
11111111
11111111

TIL pe5
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000001

TIL pe6
11111111
11111111
11111111
11111111
11111111
11111111
11111111
11111111

TIL pe7
00000000
11111111
11111111
11111111
11111111
11111111
11111111
11111111

TIL pe8
01100000
11110000
11110000
11111000
11111100
11111110
11111111
11111111

TIL pe9
10000000
11001000
11100000
11110000
11111000
11111100
11111110
11111111

TIL pea
01111111
01111111
11111111
11111111
11111111
11111111
00000000
00000000

TIL peb
11111110
11111110
11111111
11111111
11111111
11111111
00000000
00000000

TIL pec
11110000
11110000
11110000
11110000
11110000
11100000
00000000
00000000

TIL ped
00001111
00001111
00001111
00001111
00001111
00000011
00000000
00000000

TIL pee
00000000
00000000
00000000
00000000
00000011
00001111
00011111
00011111

TIL pef
00000011
00001111
00111111
01111111
11111110
11111000
11110000
11110000

TIL peg
11000000
11000000
00000000
00000000
00000000
00000000
00000000
00000000

TIL peh
00000000
00000000
00000000
00011111
00111111
01111111
11111000
11100000

TIL pei
00000000
00000000
00000000
11111111
11111111
11111111
00000000
00000000

TIL pej
00000000
00000000
00000000
11111100
11111111
11111111
00000001
00000001

TIL pek
00000000
00000000
00000000
00000000
00000000
11000000
11100000
11100000

TIL pel
11110000
11111000
11111100
01111110
00111110
00011111
00001111
00001111

TIL pem
00000000
00000000
00000000
00000000
10000000
11100000
11110000
11111000

TIL pen
11100000
11000000
10000000
00000000
00000000
00011000
00011000
00011000

TIL peo
00000001
00000000
00000000
00000000
00000000
01100000
01100000
01100000

TIL pep
11111111
11111100
11110000
11110000
11110000
11110000
11111000
11111111

TIL peq
11111111
00001111
00000111
00000011
00000011
00000111
00011111
11111111

TIL per
00000001
00000010
00000100
00001000
00010000
00010000
00010000
00001000

TIL pes
00001000
00001000
00000100
00000010
00000001
00000010
00000100
00001000

TIL pet
00001000
00001000
00000100
00001000
00010000
00100000
01000000
10000000

TIL peu
00000001
00000010
00000100
00001000
00010000
00100000
00100000
00010000

TIL pev
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000

TIL q2
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000011
NAME X-1

TIL q3
00000000
00000000
00000000
00000000
00000000
00000000
00000000
11111111
NAME X-2

TIL q4
00000000
00000000
00000000
00000000
00000000
00000000
00000000
11000000
NAME X-3

TIL q5
00000010
00000010
00000010
00000010
00000010
00000010
00000010
00000010
NAME X-4

TIL q6
00000000
00000000
01111111
01111111
01111111
01111111
01111111
01111111
NAME X-5

TIL q7
00000000
00000000
11111111
11111111
11111111
11111111
11111111
11111111
NAME X-6

TIL q8
00000000
00000000
11111110
11111110
11111110
11111110
11111110
11111110
NAME X-7

TIL q9
01000000
01000000
01000000
01000000
01000000
01000000
01000000
01000000
NAME X-8

TIL q10
11110111
11001111
11010111
11101011
11101011
11101011
11110011
11111101
NAME X-34

TIL q11
11111111
11111111
11111111
11111011
11110100
11101110
11101111
11111111
NAME X-35

TIL q12
11111111
11111111
11111111
11011111
00101111
01110111
11110111
11111111
NAME X-36

TIL q13
11101001
11110101
11101011
11011011
11010111
11010111
11001111
10111111
NAME X-37

TIL q14
11111101
11111110
11111111
11111111
11111111
11111111
11111111
11111111
NAME X-38

TIL q15
11110100
11111011
11111111
10111100
10111110
10111111
11110011
10111110
NAME X-39

TIL q16
00101111
11011111
11111111
00111101
01111101
11111101
11001111
01111101
NAME X-40

TIL q17
10111111
01111111
11111111
11111111
11111111
11111111
11111111
11111111
NAME X-41

TIL q18
11111111
11111111
11111111
11111110
11111110
11111101
11111001
11110001
NAME X-42

TIL q19
10111111
00111111
11111111
01111101
01111110
10111111
11011111
11101111
NAME X-43

TIL q20
01100000
01100000
01100000
01111111
01111111
01111111
00000000
11111111
NAME X-70

TIL q21
00000000
00000000
00000000
11111111
11111111
11111111
00000000
11111111
NAME X-71

TIL q22
00000000
00000000
00000000
11111111
11111111
11111111
00000000
11111111
NAME X-72

TIL q23
00000000
00000000
00000000
11111111
11111111
11111111
00000000
11111111
NAME X-73

TIL q24
00000000
00000000
00000000
11111111
11111111
11111111
00000000
11111111
NAME X-74

TIL q25
00000000
00000000
00000000
11111111
11111111
11111111
00000000
11111111
NAME X-75

TIL q26
00000000
00000000
00000000
11111111
11111111
11111111
00000000
11111111
NAME X-76

TIL q27
00000110
00000110
00000110
11111110
11111110
11111110
00000000
11111111
NAME X-77

TIL q28
10000000
10000000
10000000
10000000
10000000
10000000
10000000
10000000
NAME X-78

TIL qb
01111111
01111111
01111111
01111111
01111111
01111111
01111111
01111111
NAME X-9

TIL qc
11111111
11111111
11111111
11111111
11111111
11111111
11111111
11111111
NAME X-10

TIL qd
11111111
11111100
11111001
11111010
11111110
11110111
11110111
11110111
NAME X-11

TIL qe
11111111
11111100
11110111
11011111
10111111
01111111
11111111
11111111
NAME X-12

TIL qf
11111111
11111111
11100011
11111100
11111111
11111111
11111111
11111111
NAME X-13

TIL qg
11111111
11111111
11111111
00111111
11011111
11101111
11110111
11111011
NAME X-14

TIL qh
11111110
11111110
11111110
11111110
11111110
11111110
11111110
11111110
NAME X-15

TIL qi
11111111
11111111
11111111
11111111
11111110
11111110
11111101
11111101
NAME X-16

TIL qj
11011111
10111111
01111111
11111111
11111111
10111111
11111110
01111100
NAME X-17

TIL qk
11111111
11111111
11111111
11001111
11000111
01000111
01000011
00000011
NAME X-18

TIL ql
11111111
11111011
11111111
11111110
11111111
11111111
11111111
11111111
NAME X-19

TIL qm
11111110
11111110
11111111
11101011
01111101
10111101
11111111
10011111
NAME X-20

TIL qn
11111111
11111111
01111111
01111111
01111111
10111111
11001111
11100111
NAME X-21

TIL qo
11111101
11111101
11111111
11111101
11111101
11111101
11111111
11111001
NAME X-22

TIL qp
01111100
01111100
01111100
01111101
00110101
11111111
11111000
11110000
NAME X-23

TIL qq
01000011
00000011
00001011
11111111
11111011
00001011
00000101
01110111
NAME X-24

TIL qr
11111111
10111111
11011111
11101111
11111111
10000001
11000000
00101110
NAME X-25

TIL qs
11111111
11011111
11101111
11101111
11110110
11111111
00011101
00001111
NAME X-26

TIL qt
11101111
10110111
11100111
10011111
11111111
01111111
01111111
01111111
NAME X-27

TIL qu
11111000
11111001
11111101
11111010
11111011
11110110
11110100
11111111
NAME X-28

TIL qv
11111110
11111101
11111010
00001001
11001111
10111101
10010110
10011111
NAME X-29

TIL qw
01001111
11110111
00000011
11011111
10101111
10001111
00000110
00011110
NAME X-30

TIL qx
11110010
11101111
11000000
11101011
11110101
11110001
01100000
01111000
NAME X-31

TIL qy
01101111
10101111
01000000
10110010
11111011
10111110
01100100
11101010
NAME X-32

TIL qz
01111111
01111111
11111111
11111111
11111111
11111111
11111111
11111111
NAME X-33

TIL q1a
11111101
11111100
11111111
10111110
01111110
11111101
11111011
11110111
NAME X-44

TIL q1b
11111111
11111111
11111111
01111111
01111111
10111111
10011111
10001111
NAME X-45

TIL q1c
11111111
11111111
11111111
11111111
11111111
11111111
11111111
00000000
NAME X-46

TIL q1d
11111111
11111111
11111110
11111100
11110000
11110110
10000100
00000000
NAME X-47

TIL q1e
11000001
10011101
00000001
11010001
10000101
10000001
10111101
00000000
NAME X-48

TIL q1f
11110111
11111011
11111101
11111111
11111101
11111110
11111110
00000000
NAME X-49

TIL q1g
11101111
11011111
10111111
11111111
10111111
01111111
01111111
00000000
NAME X-50

TIL q1h
10110011
10100001
10100000
10001111
10000000
10111000
10000011
00000000
NAME X-51

TIL q1i
11111111
11111111
01111111
00111111
01101111
00000111
11010001
00000000
NAME X-52

TIL q1j
11111111
11111111
11111111
11111111
11111111
11111111
11111111
00000000
NAME X-53

TIL q1k
00000000
01111111
01111111
01100000
01100000
01100000
01100000
01100000
NAME X-54

TIL q1l
00000000
11111111
11111111
00000000
00000000
00000000
00000000
00000000
NAME X-55

TIL q1m
00000000
11111111
11111111
00000000
00000000
00000000
00000000
00000000
NAME X-56

TIL q1n
00000000
11111111
11111111
00000000
00000000
00000000
00000000
00000000
NAME X-57

TIL q1o
00000000
11111110
11111110
00000110
00000110
00000110
00000110
00000110
NAME X-58

TIL q1p
00000010
00000010
00000010
00000010
00000010
00000010
00000010
00000010
NAME X-59

TIL q1q
01111111
01111101
01111101
01111101
01111111
01111001
01111001
01111001
NAME X-60

TIL q1r
01100000
01100000
01100000
01100000
01100000
01100000
01100000
01100000
NAME X-61

TIL q1s
00000110
00000110
00000110
00000110
00000110
00000110
00000110
00000110
NAME X-62

TIL q1t
11111110
11111110
10111110
10111110
10011110
10111110
10011110
10011110
NAME X-63

TIL q1u
01000000
01000000
01000000
01000000
01000000
01000000
01000000
01000000
NAME X-64

TIL q1v
00000010
00000010
00000010
00000010
00000011
00000000
00000000
00000000
NAME X-65

TIL q1w
01110001
01110011
00000001
00000001
11111111
00000001
00000001
00000001
NAME X-66

TIL q1x
10101110
10001110
10000000
10000000
11111111
10000000
10000000
10000000
NAME X-67

TIL q1y
01000000
01000000
01000000
01000000
11000000
00000000
00000000
00000000
NAME X-68

TIL q1z
00000001
00000001
00000001
00000001
00000001
00000001
00000001
00000001
NAME X-69

TIL yy2
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000011
NAME y-1

TIL yy3
00000000
00000000
00000000
00000000
00000000
00000000
00000000
11111111
NAME y-2

TIL yy4
00000000
00000000
00000000
00000000
00000000
00000000
00000000
11000000
NAME y-3

TIL yy5
00000010
00000010
00000010
00000010
00000010
00000010
00000010
00000010
NAME y-4

TIL yy6
00000000
00000000
01111111
01111111
01111111
01111111
01111111
01111111
NAME y-5

TIL yy7
00000000
00000000
11111111
11111111
11111111
11111111
11111111
11111111
NAME y-6

TIL yy8
00000000
00000000
11111111
11111111
11111111
11111111
11111111
11111110
NAME y-7

TIL yy9
00000000
00000000
11111111
11111111
11111111
11111111
10000000
00001110
NAME y-8

TIL yy10
00000111
00000111
00000111
00000111
00000111
00000111
00000111
00000111
NAME y-35

TIL yy11
11111111
11111111
11111111
11111111
11101100
11110001
11111110
11111110
NAME y-36

TIL yy12
10000000
10000000
10000000
00000000
00000000
00000000
00000000
00000000
NAME y-37

TIL yy13
10000000
00000001
00000001
00000001
00000001
00000011
00000001
00000001
NAME y-38

TIL yy14
11111111
11111111
11111111
11111111
11111111
11111111
11111111
11111000
NAME y-39

TIL yy15
11111111
11111111
11111111
11111111
11111111
11111111
11111110
00011110
NAME y-40

TIL yy16
00000000
00000000
00000000
00000000
00000000
01000000
10000000
10000000
NAME y-41

TIL yy17
00000111
00000111
00000111
00000111
00000111
00000111
00000011
00000011
NAME y-42

TIL yy18
11111110
11111100
11111100
11111100
11111100
11111100
11111110
11111110
NAME y-43

TIL yy19
01000000
01000000
01000000
00000000
00000000
00000000
00000000
00000000
NAME y-44

TIL yy20
00000000
11111111
11111111
00000000
00000000
00000000
00000000
00000000
NAME y-71

TIL yy21
00000000
11111111
11111111
00000000
00000000
00000000
00000000
10000000
NAME y-72

TIL yy22
00000000
11111110
11111110
00000110
00000110
00000110
00000110
00000110
NAME y-73

TIL yy23
11111110
11111110
11111110
10111110
10111110
10011110
10011110
10001110
NAME y-74

TIL yy24
01110001
01100011
01101001
01000001
01000001
01000101
01111111
00000001
NAME y-75

TIL yy25
01100000
01100000
01100000
01100000
01100000
01100000
01100000
01100000
NAME y-76

TIL yy26
00000000
00000000
00000000
00000001
00000010
00000000
00000101
00000010
NAME y-77

TIL yy27
00000000
00100000
10010000
00100000
01000000
10010000
00100000
00000000
NAME y-78

TIL yy28
00000001
00000010
00000000
00000000
00001000
00000000
00000000
00010010
NAME y-79

TIL yy29
00000000
00000000
01000000
00000000
10000000
01000000
00000000
10000000
NAME y-80

TIL yya
11111111
10000001
10000001
10011001
10011001
10000001
10000001
11111111
NAME y-9

TIL yyb
00000000
00000000
11111111
11111111
11111111
11111111
00000001
00000000
NAME y-10

TIL yyc
00000000
00000000
11111111
11111111
11111111
11111111
11111111
01111111
NAME y-11

TIL yyd
00000000
00000000
11111110
11111110
11111110
11111110
11111110
11111110
NAME y-12

TIL yye
01000000
01000000
01000000
01000000
01000000
01000000
01000000
01000000
NAME y-13

TIL yyf
01111111
01111111
01111111
01111111
01111111
01111111
01111111
01111111
NAME y-14

TIL yyg
11111111
11111111
11111111
11111111
11111111
11111111
11111111
11111111
NAME y-15

TIL yyh
11111000
11110000
11100000
11000000
10000000
10000000
00000000
00000000
NAME y-16

TIL yyi
00001111
00000111
00001111
00000000
00100000
00000000
00000000
00000000
NAME y-17

TIL yyj
11100000
11000000
11000000
11000000
00000000
00000000
00000000
00000000
NAME y-18

TIL yyk
00011111
00001111
00000111
00000011
00000001
00000001
00000000
00000000
NAME y-19

TIL yyl
11111110
11111110
11111110
11111110
11111110
11111110
11111110
11111110
NAME y-20

TIL yym
11111110
11111110
11111110
11111100
11111100
11111100
11111000
11111000
NAME y-21

TIL yyn
00000000
00000000
00000000
00000000
00001000
00001000
00010000
00010000
NAME y-22

TIL yyo
00000000
00000000
00000000
00000000
00000000
00000000
00011111
00011111
NAME y-23

TIL yyp
00000000
00000000
00000000
00000000
00000000
00000000
11111000
11111000
NAME y-24

TIL yyq
01111111
01111111
01111111
00111111
00111111
00111111
00011111
00001111
NAME y-25

TIL yyr
11111000
11111000
11110000
11110000
11110000
11110000
11100000
11100000
NAME y-26

TIL yys
00010000
00110000
00100000
00100000
00100000
01000000
01000000
01000000
NAME y-27

TIL yyt
00011111
00011111
00011111
00011111
00011111
00001111
00000111
00011111
NAME y-28

TIL yyu
11111000
11111000
11111000
11111000
11111000
11110000
11100000
11111100
NAME y-29

TIL yyv
00001111
00001111
00000111
00000111
00000111
00000111
00000111
00000111
NAME y-30

TIL yyw
11100000
11100000
11000000
11000000
11000000
11000000
11000000
11000000
NAME y-31

TIL yyx
01000000
01000000
00000000
10000000
10000000
10000000
10000000
10000000
NAME y-32

TIL yyy
00011111
00001111
00000111
00111111
00111110
00011111
00111111
11111111
NAME y-33

TIL yyz
11111000
11110000
11110000
11111100
01111100
11111000
11111100
11111111
NAME y-34

TIL yy1a
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000001
NAME y-45

TIL yy1b
11111100
01111111
00111111
00011111
00001111
00000011
00001100
00001100
NAME y-46

TIL yy1c
00111101
11111110
11111100
11111000
11110000
11000000
00000011
00000011
NAME y-47

TIL yy1d
00000000
00000000
00000000
00000000
00000000
00000000
00000000
10000000
NAME y-48

TIL yy1e
00000001
00000000
00000000
00000000
00000001
00000001
00000001
00000000
NAME y-49

TIL yy1f
11111111
11111111
11111111
00111111
11001111
11111111
11111111
11111111
NAME y-50

TIL yy1g
01111111
01111111
01111111
01111111
01111111
01111110
01111111
01111111
NAME y-51

TIL yy1h
11111111
11111110
11111100
11111000
11000000
00000000
11100000
11000000
NAME y-52

TIL yy1i
00000000
00000000
00000000
00000000
00000000
00000000
00000000
01110000
NAME y-53

TIL yy1j
00000111
00000111
00000100
00000111
00000011
00000001
00000000
00000000
NAME y-54

TIL yy1k
00000000
10000000
11100000
10010000
11111111
11111111
01111110
00011111
NAME y-55

TIL yy1l
00000001
00000001
01100111
01101001
11111111
11101111
01111110
11111001
NAME y-56

TIL yy1m
11100000
11100000
00100000
11100000
11000000
10000000
00000000
00000000
NAME y-57

TIL yy1n
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00001110
NAME y-58

TIL yy1o
11111111
11111111
01111111
00011111
00000011
00000111
00000111
00000011
NAME y-59

TIL yy1p
10000000
10000000
10000000
00000000
00000000
00001000
00000000
11111111
NAME y-60

TIL yy1q
01100000
01100000
00000000
00000000
00000010
00000010
00000000
11111111
NAME y-61

TIL yy1r
00000000
00000000
00000000
00000000
00000000
00000001
10000001
11111111
NAME y-62

TIL yy1s
00000111
00001000
00000000
00000000
10000000
10000000
10000000
11111111
NAME y-63

TIL yy1t
11100001
00000000
00000000
00000000
01100000
01100000
00000000
11111111
NAME y-64

TIL yy1u
00000110
00000110
00000000
00000000
01000000
11000000
11100000
11111111
NAME y-65

TIL yy1v
00000001
00000001
00000001
00000000
00110000
00000000
00000000
11111111
NAME y-66

TIL yy1w
01111111
01111111
01111101
01111101
01111101
01111001
01111011
01110101
NAME y-67

TIL yy1x
00000000
01111111
01111111
01100000
01100000
01100000
01100000
01100000
NAME y-68

TIL yy1y
00000000
11111111
11111111
00000000
00000000
00000000
00000000
00000000
NAME y-69

TIL yy1z
00000000
11111111
11111111
00000000
00000000
00000000
00000000
00000000
NAME y-70

TIL yy2a
00000000
00000000
00000000
00000000
00000000
00000000
00000000
01000000
NAME y-81

TIL yy2b
00000110
00000110
00000110
00000110
00000110
00000110
00000110
00000110
NAME y-82

TIL yy2c
10001110
10000110
10000110
10000010
10000010
10000010
11111110
10000000
NAME y-83

TIL yy2d
00000010
00000010
00000010
00000011
00000000
00000000
00000000
00000000
NAME y-84

TIL yy2e
00000001
00000001
00000001
11111111
00000001
00000001
00000001
00000001
NAME y-85

TIL yy2f
01100000
01100000
01100000
01100000
01100001
01100110
01100000
01101000
NAME y-86

TIL yy2g
00001100
00001001
00100010
01000000
00000000
00000000
00000000
00000000
NAME y-87

TIL yy2h
01000000
00010100
01101011
00000000
00000000
00000000
00000000
00000000
NAME y-88

TIL yy2i
00110011
01001001
00100111
00000000
00000000
00000000
00000000
00000010
NAME y-89

TIL yy2j
10010100
10001101
10000000
00000000
00100000
01000000
00000000
00000000
NAME y-90

TIL yy2k
00011000
00001010
01100001
00000000
00011111
00000000
00000000
00000000
NAME y-91

TIL yy2l
10010000
10000000
00001110
00100000
00000000
00000000
00000000
00000000
NAME y-92

TIL yy2m
10000000
10000000
10000000
11111111
10000000
10000000
10000000
10000000
NAME y-93

TIL yy2n
01000000
01000000
01000000
11000000
00000000
00000000
00000000
00000000
NAME y-94

TIL yy2o
00000001
00000001
00000001
00000001
00000001
00000001
00000001
00000001
NAME y-95

TIL yy2p
01100000
01100000
01100000
01111111
01111111
01111111
00000000
11111111
NAME y-96

TIL yy2q
00000000
00000000
00000000
11111111
11111111
11111111
00000000
11111111
NAME y-97

TIL yy2r
00001000
00000000
00000000
11111111
11111111
11111111
00000000
11111111
NAME y-98

TIL yy2s
00000000
00000000
00000000
11111111
11111111
11111111
00000000
11111111
NAME y-99

TIL yy2t
00000110
00000110
00000110
11111110
11111110
11111110
00000000
11111111
NAME y-100
WAL false

TIL yy2u
10000000
10000000
10000000
10000000
10000000
10000000
10000000
10000000
NAME y-101

TIL jj2
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000011
NAME J-1

TIL jj3
00000000
00000000
00000000
00000000
00000000
00000000
00000000
11111111
NAME J-2

TIL jj4
00000000
00000000
00000000
00000000
00000000
00000000
00000000
11000000
NAME J-3

TIL jj5
00000010
00000010
00000010
00000010
00000010
00000010
00000010
00000010
NAME J-4

TIL jj6
00000000
00000000
01111111
01111111
01111111
01111111
01111111
01111111
NAME J-5

TIL jj7
00000000
00000000
11111111
11111111
11111111
11111111
11111111
11111111
NAME J-6

TIL jj8
00000000
11111111
11111111
11111111
11111111
11111111
11111111
11111110
NAME J-7

TIL jj9
00000000
00000000
11111111
11111111
11111111
11111111
10000000
00001110
NAME J-8

TIL jj10
00000111
00000111
00000111
00000111
00000111
00000111
00000111
00000111
NAME J-34

TIL jj11
11111111
11111111
11111111
11111111
11111100
11110001
11111110
11111110
NAME J-35

TIL jj12
10000000
10000000
10000000
00000000
00000000
00000000
00000000
00000000
NAME J-36

TIL jj13
10000000
00000001
00000001
00000001
00000001
00000011
00000001
00000001
NAME J-37

TIL jj14
11111111
11111111
11111111
11111111
11111111
11111111
11111111
11111000
NAME J-38

TIL jj15
11111111
11111111
11111111
11111111
11111111
11111111
11111110
00011110
NAME J-39

TIL jj16
00000000
00000000
00000000
00000000
00000000
01000000
10000000
10000000
NAME J-40

TIL jj17
00000111
00000111
00000111
00000111
00000111
00000111
00000011
00000011
NAME J-41

TIL jj18
11111110
11111100
11111100
11111100
11111100
11111100
11111110
11111110
NAME J-42

TIL jj19
01000000
01000000
01000000
00000000
00000000
00000000
00000000
00000000
NAME J-43

TIL jj20
11111111
11111111
11111111
00000000
00000000
00000000
00000000
00000000
NAME J-70

TIL jj21
11111111
11111111
11111111
00000000
00000000
00000000
00000000
10000000
NAME J-71

TIL jj22
11111110
11111110
11111110
01000110
00000110
00000110
00000110
00000110
NAME J-72

TIL jj23
11111110
11111110
11111110
10111110
10111110
10011110
10011110
10001110
NAME J-73

TIL jj24
01110001
01100011
01101001
01000001
01000001
01000101
00100001
00000001
NAME J-74

TIL jj25
01100000
01100000
01100000
01100000
01100000
01100000
01100000
01100000
NAME J-75

TIL jj26
00000000
00000000
00000000
00000001
00000010
00000000
00000101
00000010
NAME J-76

TIL jj27
00000000
00100000
10010000
00100000
01000000
10010000
00100000
00000000
NAME J-77

TIL jj28
00000001
00000010
00000000
00000000
00001000
00000000
00000000
00010010
NAME J-78

TIL jj29
00000000
00000000
01000000
00000000
10000000
01000000
00000000
10000000
NAME J-79

TIL jj30
00001111
00000111
00000011
00000011
00000001
00000000
00000000
00000000
NAME J-106

TIL jj31
11111111
11111110
11111110
11111110
11111110
11111110
11111100
11111101
NAME J-107

TIL jj32
00000000
00000000
00000000
00000000
00000100
00000111
00000000
00000000
NAME J-108

TIL jj33
00000000
00001011
00011111
11111111
11111111
00001111
00000111
00000111
NAME J-109

TIL jj34
00000000
11010000
11111000
11111111
11111111
11110000
11100000
11100000
NAME J-110

TIL jj35
00000000
00000000
00000000
00000000
00000000
11100000
00000000
00000000
NAME J-111

TIL jj36
11111111
01111111
01111111
01111111
01111111
01111111
00111111
10111111
NAME J-112

TIL jj37
00000001
00001100
01001000
10000011
10000011
10100100
10100111
10000000
NAME J-113

TIL jj38
11101001
00011101
00000101
00011100
00011100
00000100
11111101
00000011
NAME J-114

TIL jj39
10001011
10111000
10100000
00111000
00111000
00110000
10111111
10000000
NAME J-115

TIL jj40
00000000
11111110
11111110
00000110
00000110
00000110
00000110
00000110
NAME J-142

TIL jj41
00000010
00000010
00000010
00000010
00000010
00000010
00000010
00000010
NAME J-143

TIL jj42
01000000
01000000
01000000
01000000
01000000
01000000
01000000
01000000
NAME J-144

TIL jj43
00000010
00000010
00000010
00000010
00000011
00000000
00000000
00000000
NAME J-145

TIL jj44
01111111
01111111
00000001
00000001
11111111
00000001
00000001
00000001
NAME J-146

TIL jj45
11111110
11111110
10000000
10000000
11111111
10000000
10000000
10000000
NAME J-147

TIL jj46
01000000
01000000
01000000
01000000
11000000
00000000
00000000
00000000
NAME J-148

TIL jj47
00000001
00000001
00000001
00000001
00000001
00000001
00000001
00000001
NAME J-149

TIL jj48
01100000
01100000
01100000
01111111
01111111
01111111
00000000
11111111
NAME J-150

TIL jj49
00000000
00000000
00000000
11111111
11111111
11111111
00000000
11111111
NAME J-151

TIL jjb
00000000
00000000
11111111
11111111
11111111
11111111
00000001
00000000
NAME J-9

TIL jjc
00000000
00000000
11111111
11111111
11111111
11111111
11111111
01111111
NAME J-10

TIL jjd
00000000
00000000
11111110
11111110
11111110
11111110
11111110
11111110
NAME J-11

TIL jje
01000000
01000000
01000000
01000000
01000000
01000000
01000000
01000000
NAME J-12

TIL jjf
01111111
01111111
01111111
01111111
01111111
01111111
01111111
01111111
NAME J-13

TIL jjg
11111111
11111111
11111111
11111111
11111111
11111111
11111111
11111111
NAME J-14

TIL jjh
11111000
11110000
11100000
11000000
10000000
10000000
00000000
00000000
NAME J-15

TIL jji
00001111
00000111
00001111
00000000
00100000
00000000
00000000
00000000
NAME J-16

TIL jjj
11100000
11000000
11000000
11000000
00000000
00000000
00000000
00000000
NAME J-17

TIL jjk
00011111
00001111
00000111
00000011
00000001
00000001
00000000
00000000
NAME J-18

TIL jjl
11111110
11111110
11111110
11111110
11111110
11111110
11111110
11111110
NAME J-19

TIL jjm
11111110
11111110
11111110
11111100
11111100
11111100
11111000
11111000
NAME J-20

TIL jjn
00000000
00000000
00000000
00000000
00001000
00001000
00010000
00010000
NAME J-21

TIL jjo
00000000
00000000
00000000
00000000
00000000
00000000
00011111
00011111
NAME J-22

TIL jjp
00000000
00000000
00000000
00000000
00000000
00000000
11111000
11111000
NAME J-23

TIL jjq
01111111
01111111
01111111
00111111
00111111
00111111
00011111
00001111
NAME J-24

TIL jjr
11111000
11111000
11110000
11110000
11110000
11110000
11100000
11100000
NAME J-25

TIL jjs
00010000
00110000
00100000
00100000
00100000
01000000
01000000
01000000
NAME J-26

TIL jjt
00011111
00011111
00011111
00011111
00011111
00001111
00000111
00011111
NAME J-27

TIL jju
11111000
11111000
11111000
11111000
11111000
11110000
11100000
11111100
NAME J-28

TIL jjv
00001111
00001111
00000111
00000111
00000111
00000111
00000111
00000111
NAME J-29

TIL jjw
11100000
11100000
11000000
11000000
11000000
11000000
11000000
11000000
NAME J-30

TIL jjx
01000000
01000000
00000000
10000000
10000000
10000000
10000000
10000000
NAME J-31

TIL jjy
00011111
00001111
00000111
00111111
01111110
00011111
00111111
11111111
NAME J-32

TIL jjz
11111000
11110000
11110000
11111100
01111110
11111000
11111100
11111111
NAME J-33

TIL jj1a
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000001
NAME J-44

TIL jj1b
11111100
01111111
00111111
00011111
00001111
00000011
00001100
00001100
NAME J-45

TIL jj1c
00111101
11111110
11111100
11111000
11110000
11000000
00000011
00000011
NAME J-46

TIL jj1d
00000000
00000000
00000000
00000000
00000000
00000000
00000000
10000000
NAME J-47

TIL jj1e
00000001
00000000
00000000
00000000
00000001
00000001
00000001
00000000
NAME J-48

TIL jj1f
11111111
11111111
11111111
00111111
11001111
11111111
11111111
11111111
NAME J-49

TIL jj1g
01111111
01111111
01111111
01111111
01111111
01111110
01111111
01111111
NAME J-50

TIL jj1h
11111111
11111110
11111100
11111000
11000000
00000000
11100000
11000000
NAME J-21

TIL jj1i
00000000
00000000
00000000
00000000
00000000
00000000
00000000
01110000
NAME J-52

TIL jj1j
00000111
00000111
00000100
00000111
00000011
00000001
00000000
00000000
NAME J-53

TIL jj1k
00000000
10000000
11100000
10010000
11111111
11111111
01111110
00011111
NAME J-54

TIL jj1l
00000001
00000001
01100111
01101001
11111111
11111111
01111110
11111001
NAME J-55

TIL jj1m
11100000
11100000
00100000
11100000
11000000
10000000
00000000
00000000
NAME J-56

TIL jj1n
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00001110
NAME J-57

TIL jj1o
11111111
11111111
01111111
00011111
00000011
00000111
00000111
00000011
NAME J-58

TIL jj1p
10000000
10000000
10000000
00000000
00000000
00001000
11111111
10000000
NAME J-59

TIL jj1q
01100000
01100000
00000000
00000000
00000010
00000010
11111111
00000000
NAME J-60

TIL jj1r
00000000
00000000
00000000
00000000
00000000
00000001
10000001
00000000
NAME J-61

TIL jj1s
00000111
00001000
00000000
00000000
10000000
10000000
10000000
11111111
NAME J-62

TIL jj1t
11100001
00000000
00000000
00000000
01100000
01100000
00000000
11111111
NAME J-63

TIL jj1u
00000110
00000110
00000000
00000000
01000000
11000000
11100000
11111111
NAME J-64

TIL jj1v
00000001
00000001
00000001
00000000
00110000
00000000
11111100
11111111
NAME J-65

TIL jj1w
01111111
01111111
01111101
01111101
01111101
01111001
01111011
01110101
NAME J-66

TIL jj1x
00000000
01111111
01111111
01100000
01100000
01100000
01100000
01100000
NAME J-67

TIL jj1y
00000000
11111111
11111111
00000000
00000000
00000000
00000000
00000000
NAME J-68

TIL jj1z
00000011
11111111
11111111
00000000
00000000
00000000
00000000
00000000
NAME J-69

TIL jj2a
00000000
00000000
00000000
00000000
00000000
00000000
00000000
01000000
NAME J-80

TIL jj2b
00000110
00000110
00000110
00000110
00000110
00000110
00000110
00000110
NAME J-81

TIL jj2c
10001110
10010110
10000110
10000010
10000010
10000010
10000000
10000000
NAME J-82

TIL jj2d
00000010
00000000
00000010
00000111
00000000
00000000
00000000
00000000
NAME J-83

TIL jj2e
00000011
00010001
00000001
11111111
00000001
00000001
00000001
00000001
NAME J-84

TIL jj2f
01100000
01100000
01100000
01100000
01100001
01100110
01100000
01100000
NAME J-85

TIL jj2g
00001100
00001001
00100010
01000000
00000000
00000000
00000000
00000000
NAME J-86

TIL jj2h
01000000
00010100
01101011
00000000
00000000
00000000
00000000
00000000
NAME J-87

TIL jj2i
00110011
01001001
00100111
00000000
00000000
00000000
00000000
00000010
NAME J-88

TIL jj2j
10010100
10001101
10000000
00000000
00100000
01000000
00000000
00000000
NAME J-89

TIL jj2k
00011000
00001010
01100001
00000000
00011111
00000000
00000000
00000000
NAME J-90

TIL jj2l
10010000
10000000
00001110
00100000
00000000
00000000
00000000
00000000
NAME J-91

TIL jj2m
10000000
10000000
10000000
11111111
10000000
10000000
10000000
10000000
NAME J-92

TIL jj2n
01000000
01000000
01000000
11000000
00000000
00000000
00000000
00000000
NAME J-93

TIL jj2o
00000001
00000001
00000001
00000001
00000001
00000001
00000001
00000001
NAME J-94

TIL jj2p
01100000
01100000
01100000
01111111
01111111
01111111
00000000
11111111
NAME J-95

TIL jj2q
00000000
00000000
00000000
11111111
11111111
11111111
00000000
11111111
NAME J-96

TIL jj2r
00001000
00000000
00000000
11111111
11111111
11111111
00000000
11111100
NAME J-97

TIL jj2s
00000000
00000000
00000000
11111111
11111111
11111111
00000000
00000000
NAME J-98

TIL jj2t
00000110
00000110
00000110
11111110
11111110
11111110
00000000
11111111
NAME J-99

TIL jj2u
10000000
10000000
10000000
10000000
10000000
10000000
10000000
10000000
NAME J-100

TIL jj2v
11111111
11111111
11111111
11111111
11111111
11111111
11111000
11111000
NAME J-101

TIL jj2w
11111111
11111111
11111111
11111111
11000000
00000000
00000000
00000000
NAME J-102

TIL jj2x
11111111
11111111
11111111
11111111
00000111
00000000
00000000
00000000
NAME J-103

TIL jj2y
11111111
11111111
11111111
11111111
11111111
11111111
00011111
00011111
NAME J-104

TIL jj2z
11110000
11100000
11000000
11000000
10000000
00000000
00000000
00000000
NAME J-105

TIL jj3a
10000000
00110000
00010010
11000001
11000001
00100101
11100101
00000001
NAME J-116

TIL jj3b
10100111
10110111
11110111
11010111
11100111
11111111
11111011
11111011
NAME J-117

TIL jj3c
11111111
11111111
11111111
11111100
11111110
11111111
11111110
11111111
NAME J-118

TIL jj3d
11111111
11111111
11111111
00111111
01111111
11111111
01111111
11111111
NAME J-119

TIL jj3e
11100101
11101101
11101111
11101011
11100111
11111111
11011111
11011111
NAME J-120

TIL jj3f
11111001
11111000
11111110
11111111
11111111
11111111
11111110
11111001
NAME J-121

TIL jj3g
11111000
11111111
01111100
01111111
11111111
11010000
01110000
01111100
NAME J-122

TIL jj3h
00011111
11111111
00111110
11111110
11111111
00001011
00001110
00111110
NAME J-123

TIL jj3i
10011111
00011111
01111111
11111111
11111111
11111111
01111111
10011111
NAME J-124

TIL jj3j
11111111
11111111
11111111
11111110
11111100
11110010
11100100
11111101
NAME J-125

TIL jj3k
11111111
11111111
11111100
00000111
01111111
11111111
11111111
11111111
NAME J-126

TIL jj3l
11100110
10011001
01000111
11001111
10000101
10000111
10100111
10110111
NAME J-127

TIL jj3m
01101111
11111101
11111110
11110111
11111111
11111111
11111111
11111111
NAME J-128

TIL jj3n
11110110
10111111
01111111
11000001
11111110
11111111
11111111
11111111
NAME J-129

TIL jj3o
01100111
10011001
11100010
11110011
10100001
11100001
11100101
11101101
NAME J-130

TIL jj3p
11111111
11111111
00111111
11000000
11111110
11111111
11111111
11111111
NAME J-131

TIL jj3q
11111111
11111111
11111111
01111111
00111111
01001111
00100111
10111111
NAME J-132

TIL jj3r
11011101
11111011
10111011
01110011
01110111
01110111
11111111
00000000
NAME J-133

TIL jj3s
11111111
11111111
11111111
11111111
11111111
11111111
11111111
00000000
NAME J-134

TIL jj3t
10110011
10110001
00110010
00111011
00111001
00111001
00111101
00000000
NAME J-135

TIL jj3u
11111110
11111111
01111111
10011111
11100111
11111100
11111111
00000000
NAME J-136

TIL jj3v
01111111
11111111
11111110
11111001
11100111
00111111
11111111
00000000
NAME J-137

TIL jj3w
11001101
10001101
01001100
11011100
10011100
10011100
10111100
00000000
NAME J-138

TIL jj3x
11111111
11111111
11111111
11111111
11111111
11111111
11111111
00000000
NAME J-139

TIL jj3y
10111011
11011111
11011101
11001110
11101111
11101111
11110111
00000000
NAME J-140

TIL jj3z
00000000
11111111
11111111
00000000
00000000
00000000
00000000
00000000
NAME J-141

TIL jj4a
00000000
00000000
00000000
11111111
11111111
11111111
00000000
11111111
NAME J-152

TIL jj4b
00000000
00000000
00000000
11111111
11111111
11111111
00000000
11111111
NAME J-153

TIL jj4c
00000000
00000000
00000000
11111111
11111111
11111111
00000000
11111111
NAME J-154

TIL yy2v
01100000
01111100
01000010
01111111
01000000
01000000
01000000
01000000
NAME ReStart

TIL yy2w
00000000
01111100
01000100
01111100
01010000
01011000
01001100
01000110

TIL yy2x
00000000
00111110
00100000
00100000
00111110
00100000
00100000
00111110

TIL yy2y
00000000
01111000
01000100
01100000
00011000
01000100
01000100
00111100

TIL yy2z
00000000
01111100
00010000
00010000
00010000
00010000
00010000
00010000

TIL yy30
00000000
00011000
00100100
00111100
00100100
00100100
00100100
00100100

TIL yy31
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000

TIL yy32
00000000
01111110
01000000
01000000
01011110
01000010
01000010
01111110

TIL yy33
00000000
00111100
01000010
01000010
01000010
01000010
01000010
00111100

TIL yy34
00000000
01000010
01000010
01000010
01000010
01000010
01000010
01111110

TIL yy35
00000000
00111100
00100010
00100010
00111100
00100000
00100000
00100000

TIL yy36
00000000
00111110
00001000
00001000
00001000
00001000
00001000
00111110

TIL yy37
00000000
01000100
01100100
01010100
01010100
01001100
01000100
01000100

TIL yy38
00000000
00111100
00100000
00100000
00111100
00100000
00100000
00100000

TIL yy39
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
NAME End_block
WAL true

TIL yy3a
00000000
00000000
00000000
00000000
00000000
11111111
00000000
11111111
NAME W_EL2
WAL true

TIL yy3b
00000000
00000000
00000000
00000000
00111100
00000000
00000000
00000000
NAME pre_block

TIL yy3c
00000000
01111110
01000000
01000000
01000000
01000000
01111110
00000000

TIL yy3d
00000000
00111100
01000010
01000010
01000010
01000010
00111100
00000000

TIL yy3e
00000000
01100110
01111110
01011010
01000010
01000010
01000010
00000000

TIL yy3f
00000000
01111110
01000000
01111100
01000000
01000000
01111110
00000000

TIL yy3g
00000000
00111100
00100100
00100100
00111110
00100010
00111110
00000000

TIL yy3h
00000000
00011000
00100100
00100100
00111100
00100100
00100100
00000000

TIL yy3i
00000000
00100110
00101100
00111000
00111000
00101100
00100110
00000000

SPR A
00000000
00011000
00011000
00010000
00111100
00111110
00011000
00011000
>
00000000
00011000
00011000
00010010
00111100
01011000
00011000
00101000
POS startgamf 2,12

SPR a
00000000
00000000
01010001
01110001
01110010
01111100
00111100
00100100
NAME cat
DLG 3c
BLIP 1

SPR e
00000000
00000000
01111110
11111011
10000011
01110100
01111101
00000011

SPR f
11011111
00111111
11010000
11011111
11000000
11111111
11111111
11111111
NAME Rm1_Teleport1
DLG 6
POS 1 8,10

SPR g
11111111
11111111
11111111
11111111
11000000
11111111
11000000
11000000
NAME Rm1_Teleport2
DLG 6
POS 1 8,11

SPR h
11111111
11111111
11111111
11111111
00000000
11111111
00000000
00000000
NAME Rm1_Teleport3
DLG 6
POS 1 9,11

SPR i
11111010
11110101
11111011
11110111
01111110
11111101
01111111
01100000
NAME Rm1_Teleport4
DLG 6
POS 1 10,11

SPR j
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
NAME block_key
DLG b
POS 1 11,12

SPR f2
11011111
00111111
11010000
11011111
11000000
11111111
11111111
11111111
NAME Rm1_2_Teleport1
DLG 6
POS a 8,10

SPR g2
11111111
11111111
11111111
11111111
11000000
11111111
11000000
11000000
NAME Rm1_2_Teleport2
DLG 6

SPR h2
11111111
11111111
11111111
11111111
00000000
11111111
00000000
00000000
NAME Rm1_2_Teleport3
DLG 6

SPR i2
11111010
11110101
11111011
11110111
01111110
11111101
01111111
01100000
NAME Rm1_2_Teleport4
DLG 6
POS a 10,11

SPR f3
11011111
00111111
11010000
11011111
11000000
11111111
11111111
11111111
NAME Rm1_3_Teleport1
DLG 6

SPR g3
11111111
11111111
11111111
11111111
11000000
11111111
11000000
11000000
NAME Rm1_3_Teleport2
DLG 6
POS b 8,11

SPR h3
11111111
11111111
11111111
11111111
00000000
11111111
00000000
00000000
NAME Rm1_3_Teleport3
DLG 6
POS b 9,11

SPR i3
11111010
11110101
11111011
11110111
01111110
11111101
01111111
01100000
NAME Rm1_3_Teleport4
DLG 6
POS b 10,11

SPR Rm2ExtA1
11000011
11100111
01111110
00111100
00111100
01111110
11100111
11000011
>
01111110
10011100
11001001
11100011
11100011
11001001
10011100
00111110
NAME Rm2ExitA1
DLG g
POS 2 6,15

SPR Rm2ExtA2
11000011
11100111
01111110
00111100
00111100
01111110
11100111
11000011
>
01111110
10011100
11001001
11100011
11100011
11001001
10011100
00111110
NAME Rm2ExitA2
DLG g
POS 2 9,15

SPR Rm2ExtB1
11101100
11111011
10110110
01101100
11011011
00110110
01101101
11010011
>
10111011
01100100
11001001
10010011
01100100
11001001
10010111
10110111
NAME Rm2ExitB1
DLG g
POS 2 7,15

SPR Rm2ExtB2
11101100
11111011
10110110
01101100
11011011
00110110
01101101
11010011
>
10111011
01100100
11001001
10010011
01100100
11001001
10010111
10110111
NAME Rm2ExitB2
DLG g
POS 2 8,15

SPR Hid1
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
NAME Hidden Object1
DLG h
POS a 10,12

SPR Hid2
11101000
11101111
10100000
01111111
10101010
01010101
11111110
00000000
NAME Hidden object2
DLG i
POS a 11,11

SPR rm2extb3
00000000
01111110
01000010
01000010
01000110
01000010
01000010
01000010
NAME Hall_door1
DLG j
POS c 10,3

SPR rm2extb4
00000000
01111110
01000010
01000010
01000110
01000010
01000010
01000010
NAME Hall_door2
DLG k
POS c 10,7

SPR rm2extb5
00000000
01111110
01000010
01000010
01000110
01000010
01000010
01000010
NAME Hall_door3
DLG l
POS c 10,11

SPR rm2extb6
00011000
00111000
00001000
00001000
00001000
00001000
00001000
01111110
NAME ExitTohHaring1
DLG m

SPR rm2extb7
00000000
01111000
01001000
00001000
00011000
01110000
01111111
00000000
NAME ExitToHearing2

SPR rm5_NPC1
00000000
00011000
00011000
00111100
00111100
00111100
00010100
00010100
NAME rm5_NPC1
DLG 29
POS 5 2,7

SPR rm5_NPC2
00000000
00111000
00111000
00010000
00111000
01111100
01111100
00101000
NAME rm5_NPC2
DLG 27
POS 5 7,3

SPR rm5_NPC3
00000000
00011010
00111000
00011000
00111100
00111100
00111100
00101000
NAME rm5_NPC3
DLG 28

SPR rm2extb8
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
NAME rm6_up1
DLG 23
POS 6 1,0

SPR rm2extb9
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
NAME rm6_down1
DLG 23
POS StartGame 9,14

SPR rm2extba
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
NAME rm6_left1
DLG 23
POS 6 0,1

SPR rm2extbb
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
NAME rm6_right1
DLG 23
POS 6 2,1

SPR rm2extbs
00000000
00100100
00111100
11111111
11111111
11000011
11000011
11111111
NAME rm4_typing_exit
DLG 25
POS 4 6,8

SPR rm2extbt
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
NAME startSay1
DLG 2e
POS StartGame 1,13

SPR rm2extbu
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
NAME startSay2
DLG 2e
POS StartGame 0,14

SPR rm2extbv
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
NAME startSay3
DLG 2e
POS StartGame 1,15

SPR rm2extbw
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
NAME startSay4
DLG 2e
POS StartGame 2,14

SPR rm2extbx
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
NAME PatientSay1
DLG 2f
POS e 1,0

SPR rm2extby
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
NAME PatientSay2
DLG 2f
POS e 0,1

SPR rm2extbz
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
NAME PatientSay3
DLG 2f
POS e 1,2

SPR rm2extc0
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000011
NAME PatientSay4
DLG 2f
POS e 2,1

SPR rm2extc1
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
NAME DoctorSay1
DLG 2g
POS d 1,0

SPR rm2extc2
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
NAME DoctorSay2
DLG 2g
POS d 0,1

SPR rm2extc3
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
NAME DoctorSay3
DLG 2g
POS d 1,2

SPR rm2extc4
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000011
NAME DoctorSay4
DLG 2g
POS d 2,1

SPR rm2extc5
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
NAME JournalistSay1
DLG 2h
POS f 1,0

SPR rm2extc6
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
NAME JournalistSay2
DLG 2h
POS f 0,1

SPR rm2extc7
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
NAME JournalistSay3
DLG 2h
POS f 1,2

SPR rm2extc8
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000011
NAME JournalistSay4
DLG 2h
POS f 2,1

SPR rm2extc9
00001000
00001100
00001110
11111111
00001110
00001100
00001000
00000000
NAME mark

SPR rm2extca
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
NAME End_btn_restart
DLG 2j
POS EndGame 3,11

SPR rm2extcb
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
NAME End_btn_group
DLG 2i
POS EndGame 3,12

SPR rm2extcc
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
NAME cove_btn_start
DLG 2k
POS startgamf 3,11

SPR rm2extcd
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
NAME cove_btn_group
DLG 2l
POS startgamf 3,12

SPR rm2extch
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
>
00000000
00111000
00010000
00010000
00010000
00010000
00111000
00000000
NAME typing_ava

SPR rm2extci
00000000
00000000
00000000
00000000
00111100
00000000
00000000
00000000
NAME pre2
DLG 2x
POS 8 0,15

SPR rm2extcj
00000000
00000000
00000000
00000000
00111100
00000000
00000000
00000000
NAME pre3
DLG 2y
POS 9 1,15

SPR rm2extck
00000000
00000000
00000000
00000000
00111100
00000000
00000000
00000000
NAME pre4
DLG 2z
POS 10 2,15

SPR rm2extcl
00000000
00000000
00000000
00000000
00111100
00000000
00000000
00000000
NAME pre5
DLG 30
POS 11 3,15

SPR rm2extcm
00000000
00000000
00000000
00000000
00111100
00000000
00000000
00000000
NAME pre6
DLG 31
POS 12 4,15

SPR rm2extcn
00000000
00000000
00000000
00000000
00111100
00000000
00000000
00000000
NAME pre7
DLG 32
POS 13 5,15

SPR rm2extco
00000000
00000000
00000000
00000000
00111100
00000000
00000000
00000000
NAME pre8
DLG 33
POS 14 6,15

SPR rm2extcp
00000000
00000000
00000000
00000000
00111100
00000000
00000000
00000000
NAME pre9
DLG 34
POS 15 7,15

SPR rm2extcq
00000000
00000000
00000000
00000000
00111100
00000000
00000000
00000000
NAME pre10
DLG 35
POS 16 8,15

SPR rm2extcr
00000000
00000000
00000000
00000000
00111100
00000000
00000000
00000000
NAME pre11
DLG 36
POS 17 9,15

SPR rm2extcs
00000000
00000000
00000000
00000000
00111100
00000000
00000000
00000000
NAME pre12
DLG 37
POS 18 10,15

SPR rm2extct
00000000
00000000
00000000
00000000
00111100
00000000
00000000
00000000
NAME pre13
DLG 38
POS 19 11,15

SPR rm2extcu
00000000
00000000
00000000
00000000
00111100
00000000
00000000
00000000
NAME pre14
DLG 39
POS 20 12,15

SPR rm2extcv
00000000
00000000
00000000
00000000
00111100
00000000
00000000
00000000
NAME pre15
DLG 3a
POS 21 13,15

SPR rm2extcw
00000000
00000000
00000000
00000000
00111100
00000000
00000000
00000000
NAME pre16
DLG 3b
POS 22 14,15

SPR rm2extcx
00000000
00000000
00000000
00011000
00011000
00000000
00000000
00000000
NAME next2
DLG 3d
POS 8 2,15

SPR rm2extcy
00000000
00000000
00000000
00011000
00011000
00000000
00000000
00000000
NAME next3
DLG 3e
POS 9 3,15

SPR rm2extcz
00000000
00000000
00000000
00011000
00011000
00000000
00000000
00000000
NAME next4
DLG 3f
POS 10 4,15

SPR rm2extd0
00000000
00000000
00000000
00011000
00011000
00000000
00000000
00000000
NAME next5
DLG 3g
POS 11 5,15

SPR rm2extd1
00000000
00000000
00000000
00011000
00011000
00000000
00000000
00000000
NAME next6
DLG 3h
POS 12 6,15

SPR rm2extd2
00000000
00000000
00000000
00011000
00011000
00000000
00000000
00000000
NAME next7
DLG 3i
POS 13 7,15

SPR rm2extd3
00000000
00000000
00000000
00011000
00011000
00000000
00000000
00000000
NAME next8
DLG 3j
POS 14 8,15

SPR rm2extd4
00000000
00000000
00000000
00011000
00011000
00000000
00000000
00000000
NAME next9
DLG 3k
POS 15 9,15

SPR rm2extd5
00000000
00000000
00000000
00011000
00011000
00000000
00000000
00000000
NAME next10
DLG 3l
POS 16 10,15

SPR rm2extd6
00000000
00000000
00000000
00011000
00011000
00000000
00000000
00000000
NAME next11
DLG 3m
POS 17 11,15

SPR rm2extd7
00000000
00000000
00000000
00011000
00011000
00000000
00000000
00000000
NAME next12
DLG 3n
POS 18 12,15

SPR rm2extd8
00000000
00000000
00000000
00011000
00011000
00000000
00000000
00000000
NAME next13
DLG 3o
POS 19 13,15

SPR rm2extd9
00000000
00000000
00000000
00011000
00011000
00000000
00000000
00000000
NAME next14
DLG 3p
POS 20 14,15

SPR rm2extda
00000000
00000000
00000000
00011000
00011000
00000000
00000000
00000000
NAME next15
DLG 3q
POS 21 15,15

SPR rm2extdb
00000000
00000000
00000000
00011000
00011000
00000000
00000000
00000000
NAME next1
DLG 3r
POS 7 1,15

SPR rm2extdc
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
NAME Hidden1_ava

SPR rm2extdd
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
NAME overSay1
POS startgamh 1,0

SPR rm2extde
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
NAME overSay2
POS startgamh 0,1

SPR rm2extdf
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
NAME overSay3
POS startgamh 1,2

SPR rm2extdg
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
NAME overSay4
DLG 3s
POS startgamh 2,1

ITM 1_0
00101000
01111011
01101011
00111011
10000011
11111111
11111111
11111111
NAME glass
DLG 1

ITM 1_1
00000000
00111100
00100100
00111100
00010000
00011000
00010000
00011000
NAME old_key
DLG 2
BLIP 2

ITM 1_2
01110000
01110111
01110111
01110111
00000111
11111110
11111101
11111011
NAME notes
DLG 3

ITM 1_3
00000111
00001100
00010011
00010100
00101110
01111111
00000000
11000000
NAME key1
DLG 8

ITM 1_4
11000000
01000000
00100000
10100000
10110000
11001000
01111110
10111000
NAME key2
DLG a

ITM 1_5
00001110
00011101
00011101
00011101
00111101
11011101
01111111
11000000
NAME letter
DLG c

ITM 1_6
00000000
11111100
10000100
10110100
11111110
11111101
00000000
00000000
NAME photo
DLG 4

ITM 4_1
00000101
00000101
00000101
00000101
00000101
01110101
01010101
01110101
NAME rm4_1
DLG 1m

ITM 4_2
11010010
11011110
11000000
11000000
11011110
11111110
11111110
11111110
NAME rm4_2
DLG 1n

ITM 4_3
11111100
00000100
00000100
00000100
00000100
00000100
11111100
00000000
NAME rm4_3
DLG 1p

ITM 4_4
00000001
01111101
01000101
01000101
01000101
01000101
01000101
01111100
NAME rm4_4
DLG 1q

ITM 4_5
00001111
00000001
00111100
01111110
10000001
11111111
10000001
11111111
NAME rm4_5
DLG 1o

ITM c
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000

ITM d
10000001
01000010
00100100
00011000
00011000
00100100
01000010
10000001
NAME rm2_i1
DLG n

ITM e
10000001
01000010
00100100
00011000
00011000
00100100
01000010
10000001
NAME rm2_i2
DLG o

ITM f
10000001
01000010
00100100
00011000
00011000
00100100
01000010
10000001
NAME rm2_i3
DLG p

ITM g
10000001
01000010
00100100
00011000
00011000
00100100
01000010
10000001
NAME rm2_i4
DLG q

ITM 4_6
00000000
00000000
00000000
11111111
10000001
11010101
10000001
11111111
NAME rm4_6
DLG 24

ITM rm3_records1
11111111
10000000
10001000
10001000
10111110
10001000
10001000
10000000
NAME rm3_records1
DLG 2c

ITM rm3_records2
11111111
00000001
00000001
00111101
00101001
01100001
00101001
00111001
NAME rm3_records2
DLG 2c

ITM rm3_records3
10000000
10000000
10000000
10000000
10000000
10000000
10000000
11111111
NAME rm3_records3
DLG 2c

ITM rm3_records4
00111001
00100001
01100101
01000001
11010001
00101001
00010011
11111111
NAME rm3_records4
DLG 2c

ITM rm8
11111111
11111111
11111111
11111111
11111111
11111111
11111111
11111111
NAME rm3_pc1
DLG 2a

ITM rm9
11111111
11111111
11111111
11111111
11111111
11111111
11111111
00000000
NAME rm3_pc2
DLG 2a

ITM rma
11111111
11111111
11111111
11111111
11111111
11111111
11111111
00000111
NAME rm3_pc3
DLG 2a

ITM rmb
11111111
11111111
11111111
11111111
11111111
11111111
11111111
11000000
NAME rm3_pc4
DLG 2a

ITM rmc
00000000
00000000
00000000
00000000
00000000
01111111
01111111
01111111
NAME rm3_chest1
DLG 2d

ITM rmd
10000000
10000000
01111110
11000010
11000010
11111111
11111111
00000000
NAME rm3_chest2
DLG 2d

ITM rme
00000000
00000000
00000000
00000000
00000000
11111110
11111110
11111110
NAME rm3_chest3
DLG 2d

ITM rmf
01111111
01111111
01111111
01111111
01111111
01111111
01111111
00000000
NAME rm3_chest4
DLG 2d

ITM rmg
00001000
00001000
00111110
00001000
00001000
00000000
11111111
00000000
NAME rm3_chest5
DLG 2d

ITM rmh
11111110
11111110
11111110
11111110
11111110
11111110
11111110
00000000
NAME rm3_chest6
DLG 2d

ITM rmi
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000

ITM rmj
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000

ITM rmk
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000

ITM rml
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000

ITM rmm
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000

ITM rmn
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000

ITM rmo
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000

ITM rmp
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000

ITM rmq
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000

ITM rmr
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000

ITM rms
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000

ITM rmt
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000

ITM rmu
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000

ITM rmv
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000

ITM rmw
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000

ITM rmx
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000

ITM rmy
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000

ITM rmz
00000000
00000000
00000000
00011000
00011000
00000000
00000000
00000000
DLG 2w

DLG 1
{b = b + 1}{rbw}{wvy}Medicine Bottle x1{/wvy}{/rbw}{pg}The pain then swept over me like a tidal wave and almost overwhelmed me. I thought this bottle of medicine would bring relief, would get me back on my feet. I trusted it so much, as if it were the only salvation. Yet, what depths have I fallen into now?
NAME rm1 tea dialog

DLG 2
A key! {wvy}What does it open?{wvy}
NAME key dialog

DLG 3
{b = {b + 1}}{rbw}{wvy}Mary's Diary x1{/wvy}{/rbw}{pg}I just want to ease the pain, but right now it feels like I'm losing control. Everything is slipping into an unpredictable abyss. What exactly am I missing? Where the hell are those lost things?
NAME rm1 book dialog

DLG 4
{b = {b + 1}}{rbw}{wvy}Memory Photo x1{/wvy}{/rbw}{pg}When I look at this photo, the laughter I once had seems to still echo in my ears. The care and support of my friends, that warmth of being loved, is now so far away from me. How on earth did I get to this point?
NAME rm1 photo dialog

DLG 6
"""
{property locked true}{
  - b == 5 ?
    Sleep now!{pg}{exit "2" 8 7}
  - else ?
    I don't want to sleep. I'll look again. ({say b}/5)
}
"""
NAME rm1 teleport dialog

DLG 8
{b = {b + 1}}{rbw}{wvy}????? x1{/wvy}{/rbw}{pg}??????? ...... turned out to be here all along. It's the lost thing I mentioned in my diary. Perhaps it is more than just a key, it is the hope of finding oneself.
NAME rm1 key1 dialog

DLG 16
{exit "9" 2 15}
NAME rm7_blockSay dialog

DLG 20

NAME rm7_blockSay3 dialog

DLG 21

NAME rm7_blockSay4 dialog

DLG 22

NAME rm7_blockSay5 dialog

DLG 23
There was deafening quiet in the courtroom, and the sound of the gavel booming throughout the chamber was so powerful that it took his breath away.{pg}James Foster sat calmly in the back seat, clutching his notebook and watching everything.{pg}He realized that this was merely the beginning of the investigation, and that the true culprit remained unknown.{pg}The truth has not yet been fully revealed, and the story continues...{pg}To be continued.........{pg}End?????????{exit "EndGame" 2 12}
NAME Hearing dialog

DLG 24
"""
{
  - c == 6 ?
    Typing...........{pg}{exit "7" 0 15}
  - else ?
    It seems like something is missing... ({say c}/6)
}
"""
NAME rm4_6 dialog

DLG 25
"""
{
  - c >= 5 ?
    Typing...........Typing.....{pg}{exit "7" x y}
  - else ?
    It seems like something is missing... ({say c}/5)
}

"""
NAME rm4_typing_exit dialog

DLG 26
"""
{
  - {item "0"} >= 1 ?
    {property locked true}
  - else ?
    {property locked false}
}
"""
NAME locked exit 1

DLG 27
"""
{drws "A"} Why do you depend on these drugs?{pg}{drws "rm5_NPC2"} At first, it was only to relieve the agony... {pg}{drws "rm5_NPC2"} However, I gradually lost control. Every day, I consider acquiring more. {pg}{drws "rm5_NPC2"} I don't want to live this way, yet it has taken everything from me. {pg}{drws "rm5_NPC2"} Who will understand me? Who will save me?
{pg}{drws "rm5_NPC2"} (Emily Carter lowers her head.........) {pg}{drws "rm5_NPC2"} I am not the only victim... {pg}{drws "rm5_NPC2"} There are a lot of folks like myself in this town. {pg}{drws "rm5_NPC2"} We are enslaved by these medicines, and we have lost everything, even our health.
{
  - m2 >= 1 ?
    {
      - m >= 3 ?
        {exit "startgamh" 1 1}
      - else ?
        {drws "rm5_NPC2"} Please see what others say....
    }
  - else ?
    {
      - m2 == 0 ?
        {m2 = m2 + 1}{m = m + 1}{exit "23" 1 1}{pg}23{exit "24" 1 1}{pg}24{exit "25" 1 1}{pg}25{exit "26" 1 1}{pg}26{exit "27" 1 1}{pg}27{pg}{
          - m >= 3 ?
            {exit "startgamh" 1 1}
          - else ?
            {exit "5" 8 10}
        }
      - else ?
        {drws "rm5_NPC2"} .......
    }
}
"""
NAME rm5_NPCB dialog

DLG 28
"""
{drws "A"} How do you plan to expose this?{pg}{drws "rm5_NPC3"} The complexity of this case has surpassed my expectations.{pg}{drws "rm5_NPC3"} This is not only the tragedy of a doctor and a few patients; it is the collapse of the entire system.{pg}{drws "rm5_NPC3"} I must continue to pursue it and ensure that the true criminals are punished.{pg}{drws "rm5_NPC3"} The truth cannot stop here.{pg}{drws "rm5_NPC3"} I will tell everyone the truth about this calamity.{
  - m3 >= 1 ?
    {
      - m >= 3 ?
        {exit "startgamh" 1 1}
      - else ?
        {drws "rm5_NPC3"} Please see what others say....
    }
  - else ?
    {
      - m3 == 0 ?
        {m3 = m3 + 1}{m = m + 1}{exit "32" 1 1}{pg}32{exit "33" 1 1}{pg}33{exit "34" 1 1}{pg}34{exit "31" 1 1}{pg}31{pg}{
          - m >= 3 ?
            {exit "startgamh" 1 1}
          - else ?
            {exit "5" 8 10}
        }
      - else ?
        {drws "rm5_NPC3"} .......
    }
}
"""
NAME rm5_NPCC dialog

DLG 29
"""
{drws "A"} Why continue to prescribe this drug to your patients?{pg}{drws "rm5_NPC1"} I had some misgivings at first... However, the bottle had been certified by the US Pharmaceutical Regulatory Agency. {pg}{drws "rm5_NPC1"} I persuaded myself it was to ease the patient's pain.
{pg}{drws "rm5_NPC1"} You must recognize that pain is a tremendous burden, and it is our obligation as doctors to relieve it.{pg}{drws "rm5_NPC1"} But when this 'life-saving straw' turns into poison, I should have stopped.{pg}{drws "rm5_NPC1"} But I didnt... I let them keep coming back, and with each prescription, I knew I was hurting them.
{pg}{drws "rm5_NPC1"} .......{pg}{drws "rm5_NPC1"} Despite knowing it was addictive, I chose to ignore it. The more patients who relied on me, the greater my salary.{pg}{drws "rm5_NPC1"} Greed has corrupted me! I was likewise a victim of the system.
{pg}{
  - m1 >= 1 ?
    {
      - m >= 3 ?
        {exit "startgamh" 1 1}
      - else ?
        {drws "rm5_NPC1"} Please see what others say....
    }
  - else ?
    {
      - m1 == 0 ?
        {m1 = m1 + 1}{m = m + 1}{exit "28" 1 1}{pg}28{exit "29" 1 1}{pg}29{exit "30" 1 1}{pg}30{pg}{
          - m >= 3 ?
            {exit "startgamh" 1 1}
          - else ?
            {exit "5" 8 10}
        }
      - else ?
        {drws "rm5_NPC3"} .......
    }
}
"""
NAME rm5_NPCA dialog

DLG 30
{exit "10" {x = x - 1} y}
NAME pre5 dialog

DLG 31
{exit "11" {x = x - 1} y}
NAME pre6 dialog

DLG 32
{exit "12" {x = x - 1} y}
NAME pre7 dialog

DLG 33
{exit "13" {x = x - 1} y}
NAME pre8 dialog

DLG 34
{exit "14" {x = x - 1} y}
NAME pre9 dialog

DLG 35
{exit "15" {x = x - 1} y}
NAME pre10 dialog

DLG 36
{exit "16" {x = x - 1} y}
NAME pre11 dialog

DLG 37
{exit "17" {x = x - 1} y}
NAME pre12 dialog

DLG 38
{exit "18" {x = x - 1} y}
NAME pre13 dialog

DLG 39
{exit "19" {x = x - 1} y}
NAME pre14 dialog

DLG a
{exit "b" 13 12}
NAME rm1 key2 dialog

DLG b
"""
{
  - b == 2 ?
    {exit "a" 11 12}
  - else ?
    I seem to have missed something! ({say b}/2)
}
"""
NAME rm1 block_key dialog

DLG c
{b = {b + 1}}{rbw}{wvy}Doctor's Letter x1{/wvy}{/rbw}{pg}Doctor, I'm beginning to wonder if these drugs are really good for me. I no longer feel like I'm recovering, but another sinkhole. I have some concerns about your treatment plan, perhaps we need to re-evaluate.
NAME rm1 letter dialog

DLG g
"""
{
  - a == 4 ?
    Suddenly, a ray of light penetrated the darkness and stabbed into her eyes. She fought, and a familiar voice crept into her ears: "Carter, are you okay?{pg}{exit "startgamg" 7 10}{pg}She opened her eyes abruptly, and her eyesight gradually cleared. The doctor, Dr. Samuel Greene, sat by the bed, his look professional and serene. The air in the room was suffocatingly heavy, with the smell of medicine combined with the cool fragrance of disinfectant, surrounded by clean medical kits and equipment.{pg}{exit "d" 1 1}0987654357646435324353252355
  - else ?
    There were 4 things to check. Completed {say a}{pg} things.
}
"""
NAME rm2 teleport to rm3 dialog

DLG h
I think I saw something.
NAME rm1 hidden Object1 dialog

DLG i
I think I saw something.
NAME rm1 hidden object2 dialog

DLG j
{exit "1" 0 10}
NAME Hall_door1 dialog

DLG k
{exit "3" 12 8}
NAME Hall_door2 dialog

DLG l
{exit "4" 0 12}
NAME Hall_door3 dialog

DLG m
{exit "6" 8 12}
NAME ExitTohHaring dialog

DLG n
Where am I? Everything is hazy... The ache appears to be gone, yet I can still sense it developing softly in the depths. Is this true, or is it simply my imagination?{a = {a + 1}}
NAME rm2_i1 dialog

DLG o
As soon as the medicine enters my body, all pain seems to vanish. I'm freely floating in the air. Is this what freedom tastes like? It feels so light. Pain is no longer an enemy; it has become my shadow, my companion, necessary but no longer resisted.{a = {a + 1}}
NAME rm2_i2 dialog

DLG p
Although the medications provide temporary comfort, the pain inevitably returns. Every time I wake up, it is worse than the last, but I want for that moment of peace.{a = {a + 1}}
NAME rm2_i3 dialog

DLG q
You can't exist without me, Mary... Without me, you'll be consumed by sorrow." {pg}{blip "3"}Who am I? I am Carter...but I am no longer her. I am simply a combo of agony and medicines. Can I come back? Or am I already lost in this wild world?{a = {a + 1}}
NAME rm2_i4 dialog

DLG 1m
Secret Document: Scattered throughout these documents are clues to Brownlee's actions. If I can piece together all the pieces, I can guess his next move. I have to decide whether to expose the truth immediately or continue to infiltrate the investigation.{c = {c + 1}}
NAME rm4_1 dialog

DLG 1n
One newspaper wrote: The hidden dangers of drug addiction: the crisis in Portsmouth...........{c = {c + 1}}
NAME rm4_2 dialog

DLG 1o
Dialled Dr Smith's number......."Dr Smith, I'd like to get your opinion on the recent increase in Oxycontin prescriptions......"{c = {c + 1}}
NAME rm4_5 dialog

DLG 1p
"""
Note A: There seems to be some kind of connection between the clues.
Note 2: There seems to be some kind of connection between the clues. Maybe if I can put them together correctly, the truth will surface. I need to analyse every detail more carefull{c = c + 1}
"""
NAME rm4_3 dialog

DLG 1q
Note B: The reasons behind addiction are far more complex than what is seen on the surface. There are hidden chains of interest manipulating it all. If I can solve this mystery, I can reveal who's really behind it.{c = c + 1}
NAME rm4_4 dialog

DLG 1z

NAME rm7_blockSay2 dialog

DLG 2a
"""
{
  - e1 >= 1 ?
    {
      - e >= 3 ?
        {exit "f" 1 1}
      - else ?

    }
  - else ?
    {
      - e1 == 0 ?
        computer x1{pg}Carter's dependent symptoms are becoming increasingly visible. Her discomfort is managed with medication, but she keeps requesting bigger doses. Her family is concerned about her condition.
        I could have halted anything, but I know she was already deeply invested. But if I stop, she'll switch to someone else... This medicine has made me addicted.{e1 = e1 + 1}{e = e + 1}{pg}{
          - e >= 3 ?
            {exit "f" 1 1}
          - else ?

        }
      - else ?

    }
}
"""
NAME rm3_pc dialog

DLG 2c
"""
{
  - e2 >= 1 ?
    {
      - e >= 3 ?
        {exit "f" 1 1}
      - else ?

    }
  - else ?
    {
      - e2 == 0 ?
        medical records x1{pg}Patient's name: Emily Carter.{pg}Age: 17{pg}Symptoms: Chronic soreness from prolonged exercise{pg}Prescription: 10mg OxyContin once daily.{pg}Prescription: 10mg OxyContin once daily.{e2 = e2 + 1}{e = e + 1}{pg}{
          - e >= 3 ?
            {exit "f" 1 1}
          - else ?

        }
      - else ?

    }
}
"""
NAME rm3_records dialog

DLG 2d
"""
{
  - e3 >= 1 ?
    {
      - e >= 3 ?
        {exit "f" 1 1}
      - else ?

    }
  - else ?
    {
      - e3 == 0 ?
        medicine chest x1{pg}OxyContin......{pg}An opioid used to treat moderate to severe pain.{pg}Warning: This may lead to addiction, dependence, and abuse. Overdose can induce respiratory depression and death.{e3 = e3 + 1}{e = e + 1}{pg}{
          - e >= 3 ?
            {exit "f" 1 1}
          - else ?

        }
      - else ?

    }
}
"""
NAME rm3_chest dialog

DLG 2e
The use of OxyContin began to spread throughout the municipality of Portsmouth, USA, around 1996. It was touted as a "miracle drug" capable of effectively relieving pain, and as a result, an increasing number of individuals grew hooked on it. This is both a personal tragedy and a communal problem.{pg}As a player, you'll put together the reality of the drug problem from the views of several characters, illustrating the suffering and powerlessness that this country faces.{pg}{exit "e" 1 1}
NAME startSay dialog

DLG 2f
"""
{drws "rm5_NPC2"} I am Emily Carter...{pg}{drws "rm5_NPC2"} I was a cheerleader at Portsmouth High School, and I enjoyed laughing and sharing with my friends.{pg}{drws "rm5_NPC2"} But those good moments seem so long ago...{pg}{drws "rm5_NPC2"} My bones frequently pain, therefore the doctor recommended OxyContin for me.{pg}{drws "rm5_NPC2"} Initially, the medication provided significant relief from my pain.
{pg}{drws "rm5_NPC2"} However, I quickly realized that I couldn't live without it.{pg}{drws "rm5_NPC2"} I became increasingly dependent on the medicine, and when I didn't take it, it felt like my body was being torn apart.{pg}{drws "rm5_NPC2"} I lied, asked my relatives for money, and even stole items to obtain more.{pg}{drws "rm5_NPC2"} My friends gradually drifted away from me, and I was no longer the Mary they knew.
{pg}{drws "rm5_NPC2"} Now I have only the drug.{pg}{drws "rm5_NPC2"} I once longed to be free of the anguish, but it and the medication have kept me in an everlasting cage.{pg}{drws "rm5_NPC2"} Can I return to the past? Can I regain control over my life?{pg}{drws "rm5_NPC2"} My Room........{exit "1" 0 10}
"""
NAME PatientSay dialog

DLG 2g
{drws "rm5_NPC1"} I am the town doctor Dr. Samuel Greene, and for a long time, I believed I was helping my patients by easing their suffering and restoring their lives.{pg}{drws "rm5_NPC1"} That was my objective and original goal as a doctor.{pg}{drws "rm5_NPC1"} Until one day, an outside pharmaceutical salesman came into my clinic.{pg}{drws "rm5_NPC1"} He introduced me to a new medicine called OxyContin, which he said could effectively treat chronic pain.{pg}{drws "rm5_NPC1"} Initially, I was doubtful. After all, the medicine seemed too good to be true, almost eradicating chronic pain.{pg}{drws "rm5_NPC1"} My concerns were alleviated when I noticed the DEA certification seal on the bottle.{pg}{drws "rm5_NPC1"} At first, I regarded it as a novel therapy option to assist patients in true need, including Mary Henson.{pg}{drws "rm5_NPC1"} She was a girl who was in excruciating pain as a result of a long-term sports injury.{pg}{drws "rm5_NPC1"} OxyContin worked for her the first couple times.{pg}{drws "rm5_NPC1"} However, many patients, like Mary, developed drug dependence over time.{pg}{drws "rm5_NPC1"} With each prescription, I could make more money, and the more hooked they became, the more they relied on me.{pg}{drws "rm5_NPC1"} This provided me a newfound sense of authority while also increasing my earnings.{pg}{drws "rm5_NPC1"} I knew I had gone too far and that my professional ethics had been compromised.{pg}{drws "rm5_NPC1"} I was a good doctor, but now what? Was I saving or driving them over the edge?{pg}{drws "rm5_NPC1"} I could no longer tell. I knew Mary's condition was deteriorating, and she was becoming increasingly dependent on the medicine, but I continued to give it to her.{pg}{drws "rm5_NPC1"} Perhaps I was part of the nightmare, driving her over the edge.{pg}{drws "rm5_NPC1"} There seems to be something in my Clinic...... {exit "3" 11 7}
NAME DoctorSay dialog

DLG 2h
{drws "rm5_NPC3"} I am a journalist, My name is James Foster........{pg}{drws "rm5_NPC3"} 43564465464554634537{pg}{drws "rm5_NPC3"} 65644565436546657534{pg}{drws "rm5_NPC3"} My office.......{exit "4" 3 8}
NAME JournalistSay dialog

DLG 2i
"""
Shuxuan Zhang (59164191)
Xinyue Zheng (58248420)
LI Chun Wai (58896982)
Li Qiao (59147422)
"""
NAME End_btn_group dialog

DLG 2j
{a = 0}{b = 0}{c = 0}{m1 = 0}{m2 = 0}{m3 = 0}{m = 0}{e = 0}{e1 = 0}{e2 = 0}{e3 = 0}{x = 0}{y = 15}{exit "startgamg" 0 10}
NAME End_btn_restart dialog

DLG 2k
{a = 0}{b = 0}{c = 0}{m1 = 0}{m2 = 0}{m3 = 0}{m = 0}{e = 0}{e1 = 0}{e2 = 0}{e3 = 0}{x = 0}{y = 15}{exit "StartGame" 1 14}
NAME start_btn dialog

DLG 2l
"""
Shuxuan Zhang (59164191)
Xinyue Zheng (58248420)
LI Chun Wai (58896982)
Li Qiao (59147422)
"""
NAME sprite rm2extcd dialog

DLG 2o
{exit "21" 14 15}
NAME rm7_blockSay16 dialog

DLG 2w

NAME item rmz dialog

DLG 2x
{exit "7" {x = x - 1} y}
NAME pre2 dialog

DLG 2y
{exit "8" {x = x - 1} y}
NAME pre3 dialog

DLG 2z
{exit "9" {x = x - 1} y}
NAME pre4 dialog

DLG 3a
{exit "20" {x = x - 1} y}
NAME pre15 dialog

DLG 3b
{exit "21" {x = x - 1} y}
NAME pre16 dialog

DLG 3c

NAME cat dialog

DLG 3d
{exit "9" {x = x + 1} y}
NAME next2 dialog

DLG 3e
{exit "10" {x = x + 1} y}
NAME next3 dialog

DLG 3f
{exit "11" {x = x + 1} y}
NAME next4 dialog

DLG 3g
{exit "12" {x = x + 1} y}
NAME next5 dialog

DLG 3h
{exit "13" {x = x + 1} y}
NAME next6 dialog

DLG 3i
{exit "14" {x = x + 1} y}
NAME next7 dialog

DLG 3j
{exit "15" {x = x + 1} y}
NAME next8 dialog

DLG 3k
{exit "16" {x = x + 1} y}
NAME next9 dialog

DLG 3l
{exit "17" {x = x + 1} y}
NAME next10 dialog

DLG 3m
{exit "18" {x = x + 1} y}
NAME next11 dialog

DLG 3n
{exit "19" {x = x + 1} y}
NAME next12 dialog

DLG 3o
{exit "20" {x = x + 1} y}
NAME next13 dialog

DLG 3p
{exit "21" {x = x + 1} y}
NAME next14 dialog

DLG 3q
{exit "5" 8 10}
NAME next15 dialog

DLG 3r
{exit "8" {x = x + 1} y}
NAME next1 dialog

DLG 3s
I want the kind of "evidence gradually accumulates, and finally the day of trial arrives...{pg}{exit "6" 1 1}
NAME overSay dialog

VAR a
0

VAR b
0

VAR c
0

VAR m1
0

VAR m2
0

VAR m3
0

VAR m
0

VAR e
0

VAR e1
0

VAR e2
0

VAR e3
0

VAR x
0

VAR y
15

TUNE 1
3d,0,0,0,3d5,0,0,0,3l,0,0,0,3s,0,0,0
16d2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
>
4l,0,0,0,s,0,3l,0,0,0,2s,0,2m,0,2r,0
16m2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
>
3d,0,0,0,3d5,0,0,0,3l,0,0,0,3s,0,0,0
16l2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
>
3l,0,0,0,s,0,4m,0,0,0,4r,0,0,0,0,0
16s2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
NAME finale fanfare
KEY C,D,E,F,G,A,B d,r,m,s,l
TMP XFST
SQR P2 P8
ARP INT8

TUNE 2
0,0,2G,0,A,0,B,0,2C5,0,B,A,G,0,2G,0
G3,0,D,0,G3,0,D,0,2A3,0,E,0,C,0,E,0
>
2F#,0,G,0,A,0,F#,0,2E,0,F#,E,4D,0,0,0
2D,0,E,0,F#,0,D,0,2C,0,2G3,0,2F#3,0,D2,0
>
0,0,2G,0,A,0,B,0,2C5,0,B,A,G,0,G,0
2G2,0,D,D5,G3,G,D,0,2C2,0,E,E5,C3,C,E5,0
>
2D,0,C5,B,A,0,A,0,4A,0,0,0,F#,0,0,0
A2,0,E3,0,C3,0,E3,0,D3,0,A3,0,D,0,0,0
>
2E5,0,2G,0,2G5,0,2G,0,2F#5,0,2E5,0,2D5,0,2C5,0
2C3,0,2E,0,2E5,0,2C,0,2A3,0,2C,0,2F#,0,2E,0
>
3B,0,0,0,2E5,0,D5,0,4A,0,0,0,G,0,0,0
2G3,0,B3,0,2D,0,D3,0,2C3,0,G3,0,D#,0,0,0
>
0,0,2G,0,A,0,2B,0,C5,0,B,C5,A,0,G,0
A2,0,A3,0,C,0,2D,0,D#,0,D,E,C,0,C3,0
>
8B,0,0,0,0,0,0,0,A,0,2F#,0,E,0,D,0
D3,0,A3,0,F#,0,D,0,C,0,2D3,0,C3,0,F#3,0
NAME tuneful town
TMP FST
SQR P4 P2

TUNE 3
3F5,0,0,A#,0,2C#5,0,A#,3F5,0,0,F#5,0,0,2F5,0
A#3,C#,F,0,0,F,C#,F,A#3,C#,F,A#,0,A#,C#,F
>
3F5,0,0,A,0,2C#5,0,A,3F5,0,0,2A#5,0,A#,D#5,0
A3,C#,F,A3,0,F,C#,F,A,C#,F,0,D#,0,C#5,0
>
4F5,0,0,0,G#,2C#5,0,G#,3F5,0,0,D#5,0,F5,2C#5,0
G#3,C#,F,3F#,0,0,2F,0,G#3,C#,F,F#,B,A,F,D#
>
4D#5,0,0,0,0,0,2A#,0,4A#,0,0,0,0,0,A#,C5
G3,D#,F,G,0,D#,F,G,G3,D#,G,F,0,F,D#,C#3
>
4C#5,0,0,0,0,0,2C#5,0,3C#5,0,0,D#5,0,0,2C#5,0
F#2,C#,F#3,A#3,0,F#3,C#3,F#3,F#2,A,F#3,C#,0,F#3,A3,F#3
>
3C#5,0,0,F,3C5,0,0,C,3C5,0,0,D#,3A#,0,0,0
F2,D#3,A3,0,0,F3,C#,0,F#2,A#3,D#3,0,0,F#3,C#,C
>
3A#,0,0,0,C5,0,C#5,0,A#,0,C#,D#,G#,G#3,0,C#3
C3,A#3,C,E,A,0,A#,0,0,B2,B3,0,2F,0,0,0
>
A#,0,A#3,0,C#,0,F,0,A#,0,0,0,0,0,0,0
A#2,0,C#3,0,F3,0,A#3,0,D,0,0,0,0,F#3,0,F3
NAME rhythmic ruins
TMP MED
SQR P4 P4

BLIP 1
G5,F5,D5
NAME meow
ENV 115 123 9 178 65
BEAT 56 0
SQR P8

BLIP 2
A#3,A3,0
NAME pick up key
ENV 86 88 6 178 154
BEAT 42 0
SQR P8

BLIP 3
D2,0,0
NAME voice of drugs
ENV 51 5 7 94 6
BEAT 0 0
SQR P2


</script>

<style>
html {
	margin:0px;
	padding:0px;
}

body {
	margin:0px;
	padding:0px;
	overflow:hidden;
	background:#ffffff;
}

#game {
	background:black;
	width:100vw;
	max-width:100vh;
	margin:auto;
	display:block;
}
</style>

<!-- SCRIPTS -->
<script>
function startExportedGame() {
	var gameCanvas = document.getElementById("game");
	var gameData = document.getElementById("exportedGameData").text.slice(1);
	var defaultFontData = document.getElementById(defaultFontName).text.slice(1);
	loadGame(gameCanvas, gameData, defaultFontData);
	initSystem();
}
</script>

<!-- system -->
<script>
function InputSystem() {
	var self = this;

	this.Key = {
		LEFT: 37,
		RIGHT: 39,
		UP: 38,
		DOWN: 40,
		SPACE: 32,
		ENTER: 13,
		W: 87,
		A: 65,
		S: 83,
		D: 68,
		R: 82,
		SHIFT: 16,
		CTRL: 17,
		ALT: 18,
		CMD: 224
	};

	var pressed;
	var ignored;
	var touchState;

	var isRestartComboPressed = false;

	var SwipeDir = {
		None : -1,
		Up : 0,
		Down : 1,
		Left : 2,
		Right : 3,
	};

	function resetAll() {
		isRestartComboPressed = false;

		pressed = {};
		ignored = {};

		touchState = {
			isDown : false,
			startX : 0,
			startY : 0,
			curX : 0,
			curY : 0,
			swipeDistance : 30,
			swipeDirection : SwipeDir.None,
			tapReleased : false
		};
	}

	resetAll();

	function stopWindowScrolling(e) {
		if (e.keyCode == self.Key.LEFT || e.keyCode == self.Key.RIGHT || e.keyCode == self.Key.UP || e.keyCode == self.Key.DOWN || !isPlayerEmbeddedInEditor) {
			e.preventDefault();
		}
	}

	function isRestartCombo(e) {
		return (e.keyCode === self.Key.R && (e.getModifierState("Control")|| e.getModifierState("Meta")));
	}

	function eventIsModifier(event) {
		return (event.keyCode == self.Key.SHIFT || event.keyCode == self.Key.CTRL || event.keyCode == self.Key.ALT || event.keyCode == self.Key.CMD);
	}

	function isModifierKeyDown() {
		return (self.isKeyDown(self.Key.SHIFT) || self.isKeyDown(self.Key.CTRL) || self.isKeyDown(self.Key.ALT) || self.isKeyDown(self.Key.CMD));
	}

	this.ignoreHeldKeys = function() {
		for (var key in pressed) {
			if (pressed[key]) { // only ignore keys that are actually held
				ignored[key] = true;
				// bitsyLog("IGNORE -- " + key, "system");
			}
		}
	}

	this.onkeydown = function(event) {
		enableGlobalAudioContext();
		// bitsyLog("KEYDOWN -- " + event.keyCode, "system");

		stopWindowScrolling(event);

		isRestartComboPressed = isRestartCombo(event);

		// Special keys being held down can interfere with keyup events and lock movement
		// so just don't collect input when they're held
		{
			if (isModifierKeyDown()) {
				return;
			}

			if (eventIsModifier(event)) {
				resetAll();
			}
		}

		if (ignored[event.keyCode]) {
			return;
		}

		pressed[event.keyCode] = true;
		ignored[event.keyCode] = false;
	}

	this.onkeyup = function(event) {
		// bitsyLog("KEYUP -- " + event.keyCode, "system");
		pressed[event.keyCode] = false;
		ignored[event.keyCode] = false;

		isRestartComboPressed = false;
	}

	this.ontouchstart = function(event) {
		enableGlobalAudioContext();

		event.preventDefault();

		if( event.changedTouches.length > 0 ) {
			touchState.isDown = true;

			touchState.startX = touchState.curX = event.changedTouches[0].clientX;
			touchState.startY = touchState.curY = event.changedTouches[0].clientY;

			touchState.swipeDirection = SwipeDir.None;
		}
	}

	this.ontouchmove = function(event) {
		event.preventDefault();

		if( touchState.isDown && event.changedTouches.length > 0 ) {
			touchState.curX = event.changedTouches[0].clientX;
			touchState.curY = event.changedTouches[0].clientY;

			var prevDirection = touchState.swipeDirection;

			if( touchState.curX - touchState.startX <= -touchState.swipeDistance ) {
				touchState.swipeDirection = SwipeDir.Left;
			}
			else if( touchState.curX - touchState.startX >= touchState.swipeDistance ) {
				touchState.swipeDirection = SwipeDir.Right;
			}
			else if( touchState.curY - touchState.startY <= -touchState.swipeDistance ) {
				touchState.swipeDirection = SwipeDir.Up;
			}
			else if( touchState.curY - touchState.startY >= touchState.swipeDistance ) {
				touchState.swipeDirection = SwipeDir.Down;
			}

			if( touchState.swipeDirection != prevDirection ) {
				// reset center so changing directions is easier
				touchState.startX = touchState.curX;
				touchState.startY = touchState.curY;
			}
		}
	}

	this.ontouchend = function(event) {
		event.preventDefault();

		touchState.isDown = false;

		if( touchState.swipeDirection == SwipeDir.None ) {
			// tap!
			touchState.tapReleased = true;
		}

		touchState.swipeDirection = SwipeDir.None;
	}

	this.isKeyDown = function(keyCode) {
		return pressed[keyCode] != null && pressed[keyCode] == true && (ignored[keyCode] == null || ignored[keyCode] == false);
	}

	this.anyKeyDown = function() {
		var anyKey = false;

		for (var key in pressed) {
			if (pressed[key] && (ignored[key] == null || ignored[key] == false) &&
				!(key === self.Key.UP || key === self.Key.DOWN || key === self.Key.LEFT || key === self.Key.RIGHT) &&
				!(key === self.Key.W || key === self.Key.S || key === self.Key.A || key === self.Key.D)) {
				// detected that a key other than the d-pad keys are down!
				anyKey = true;
			}
		}

		return anyKey;
	}

	this.isRestartComboPressed = function() {
		return isRestartComboPressed;
	}

	this.swipeLeft = function() {
		return touchState.swipeDirection == SwipeDir.Left;
	}

	this.swipeRight = function() {
		return touchState.swipeDirection == SwipeDir.Right;
	}

	this.swipeUp = function() {
		return touchState.swipeDirection == SwipeDir.Up;
	}

	this.swipeDown = function() {
		return touchState.swipeDirection == SwipeDir.Down;
	}

	this.isTapReleased = function() {
		return touchState.tapReleased;
	}

	this.resetTapReleased = function() {
		touchState.tapReleased = false;
	}

	this.onblur = function() {
		// bitsyLog("~~~ BLUR ~~", "system");
		resetAll();
	}

	this.resetAll = resetAll;

	this.listen = function(canvas) {
		document.addEventListener('keydown', self.onkeydown);
		document.addEventListener('keyup', self.onkeyup);

		if (isPlayerEmbeddedInEditor) {
			canvas.addEventListener('touchstart', self.ontouchstart, {passive:false});
			canvas.addEventListener('touchmove', self.ontouchmove, {passive:false});
			canvas.addEventListener('touchend', self.ontouchend, {passive:false});
		}
		else {
			// creates a 'touchTrigger' element that covers the entire screen and can universally have touch event listeners added w/o issue.

			// we're checking for existing touchTriggers both at game start and end, so it's slightly redundant.
			var existingTouchTrigger = document.querySelector('#touchTrigger');

			if (existingTouchTrigger === null) {
				var touchTrigger = document.createElement("div");
				touchTrigger.setAttribute("id","touchTrigger");

				// afaik css in js is necessary here to force a fullscreen element
				touchTrigger.setAttribute(
					"style","position: absolute; top: 0; left: 0; width: 100vw; height: 100vh; overflow: hidden;"
				);

				document.body.appendChild(touchTrigger);

				touchTrigger.addEventListener('touchstart', self.ontouchstart);
				touchTrigger.addEventListener('touchmove', self.ontouchmove);
				touchTrigger.addEventListener('touchend', self.ontouchend);
			}
		}

		window.onblur = self.onblur;
	}

	this.unlisten = function(canvas) {
		document.removeEventListener('keydown', self.onkeydown);
		document.removeEventListener('keyup', self.onkeyup);

		if (isPlayerEmbeddedInEditor) {
			canvas.removeEventListener('touchstart', self.ontouchstart);
			canvas.removeEventListener('touchmove', self.ontouchmove);
			canvas.removeEventListener('touchend', self.ontouchend);
		}
		else {
			//check for touchTrigger and removes it

			var existingTouchTrigger = document.querySelector('#touchTrigger');

			if (existingTouchTrigger !== null) {
				existingTouchTrigger.removeEventListener('touchstart', self.ontouchstart);
				existingTouchTrigger.removeEventListener('touchmove', self.ontouchmove);
				existingTouchTrigger.removeEventListener('touchend', self.ontouchend);

				existingTouchTrigger.parentElement.removeChild(existingTouchTrigger);
			}
		}

		window.onblur = null;
	}
}
</script>

<script>
// init global audio context
var audioContext = new AudioContext();

function enableGlobalAudioContext() {
	audioContext.resume();
}

function SoundSystem() {
	var self = this;

	// volume
	var maxGain = 0.15;

	// curves for different pulse wave duties (ratios between on and off)
	var dutyCycle_1_8 = new Float32Array(256);
	for (var i = 0; i < 256; i++) {
		dutyCycle_1_8[i] = ((i / 256) * 2) - 1.75;
	}

	var dutyCycle_1_4 = new Float32Array(256);
	for (var i = 0; i < 256; i++) {
		dutyCycle_1_4[i] = ((i / 256) * 2) - 1.5;
	}

	var dutyCycle_1_2 = new Float32Array(256);
	for (var i = 0; i < 256; i++) {
		dutyCycle_1_2[i] = ((i / 256) * 2) - 1.0;
	}

	var dutyCycles = [
		dutyCycle_1_8,
		dutyCycle_1_4,
		dutyCycle_1_2 // square wave
	];

	function createPulseWidthModulator() {
		// the base oscillator: start with a sawtooth wave that we'll shape into a pulse wave
		var oscillator = audioContext.createOscillator();
		oscillator.type = "sawtooth";

		// create a gain node to control the volume of the sound
		var volumeControl = audioContext.createGain();
		volumeControl.gain.value = 0;

		// create a wave shaper that turns the sawtooth wave into a pulse
		// by mapping any negative value to -1 and any positive value to 1
		var pulseCurve = new Float32Array(256);
		for (var i = 0; i < 128; i++) {
			pulseCurve[i] = -1;
		}
		for (var i = 128; i < 256; i++) {
			pulseCurve[i] = 1;
		}

		var pulseShaper = audioContext.createWaveShaper();
		pulseShaper.curve = pulseCurve;

		var dutyShaper = audioContext.createWaveShaper();
		dutyShaper.curve = dutyCycle_1_2;

		oscillator.connect(dutyShaper);
		dutyShaper.connect(pulseShaper);
		pulseShaper.connect(volumeControl);
		volumeControl.connect(audioContext.destination);
		oscillator.start();

		return {
			oscillator: oscillator,
			volumeControl: volumeControl,
			dutyShaper: dutyShaper
		};
	}

	var pulseChannels = [createPulseWidthModulator(), createPulseWidthModulator()];

	this.setPulse = function(channel, pulse) {
		var pulseChannel = pulseChannels[channel];
		pulseChannel.dutyShaper.curve = dutyCycles[pulse];
	}

	this.setFrequency = function(channel, frequencyHz) {
		var pulseChannel = pulseChannels[channel];
		// set frequency in hertz
		pulseChannel.oscillator.frequency.setValueAtTime(frequencyHz, audioContext.currentTime);
	}

	this.setVolume = function(channel, volumeNorm) {
		var pulseChannel = pulseChannels[channel];
		pulseChannel.volumeControl.gain.value = volumeNorm * maxGain;
	}

	this.mute = function() {
		for (var i = 0; i < pulseChannels.length; i++) {
			pulseChannels[i].volumeControl.gain.value = 0;
		}
	}
}

var sound = new SoundSystem();
</script>

<script>
function GraphicsSystem() {
	var self = this;

	var canvas;
	var ctx;

	var scale;
	var textScale;
	var palette = [];
	var images = [];
	var imageFillColors = [];

	function makeFillStyle(color, isTransparent) {
		var i = color * 3;
		if (isTransparent) {
			return "rgba(" + palette[i + 0] + "," + palette[i + 1] + "," + palette[i + 2] + ", 0)";
		}
		else {
			return "rgb(" + palette[i + 0] + "," + palette[i + 1] + "," + palette[i + 2] + ")";
		}
	}

	this._images = images;
	this._getPalette = function() {
		return palette;
	};

	// todo : do I really need to pass in size here?
	this.attachCanvas = function(c, size) {
		canvas = c;
		canvas.width = size * scale;
		canvas.height = size * scale;
		ctx = canvas.getContext("2d");
	};

	this.getCanvas = function() {
		return canvas;
	};

	this.getContext = function() {
		return ctx;
	};

	this.setScale = function(s) {
		scale = s;
	};

	this.setTextScale = function(s) {
		textScale = s;
	};

	this.getTextScale = function() {
		return textScale;
	};

	this.setPalette = function(p) {
		palette = p;
	};

	// todo : rename this since it doesn't always create a totally new canvas?
	this.createImage = function(id, width, height, pixels, useTextScale) {
		var imageScale = useTextScale === true ? textScale : scale;
		var widthScaled = width * imageScale;
		var heightScaled = height * imageScale;

		// try to use an existing image canvas if it is the right size,
		// instead of expensively creating a new one
		var imageCanvas = images[id];
		if (imageCanvas === undefined || imageCanvas.width != widthScaled || imageCanvas.height != heightScaled) {
			imageCanvas = document.createElement("canvas");
			imageCanvas.width = widthScaled;
			imageCanvas.height = heightScaled;
		}

		var imageCtx = imageCanvas.getContext("2d");

		// if we know the fill color for this image, we can speed things up
		// by filling the whole image with that color
		var fillColor;
		if (imageFillColors[id] != undefined) {
			fillColor = imageFillColors[id];
			var isTransparent = (fillColor === 0);
			if (isTransparent) {
				imageCtx.clearRect(0, 0, imageCanvas.width, imageCanvas.height);
			}
			else {
				imageCtx.fillStyle = makeFillStyle(fillColor, isTransparent);
				imageCtx.fillRect(0, 0, imageCanvas.width, imageCanvas.height);
			}
		}

		for (var i = 0; i < pixels.length; i++) {
			var x = i % width;
			var y = Math.floor(i / width);
			var color = pixels[i];
			if (color != fillColor) {
				var isTransparent = (color === 0);
				imageCtx.fillStyle = makeFillStyle(color, isTransparent);
				imageCtx.fillRect(x * imageScale, y * imageScale, imageScale, imageScale);
			}
		}

		images[id] = imageCanvas;
	};

	this.setImageFill = function(id, color) {
		imageFillColors[id] = color;
	};

	this.drawImage = function(id, x, y, destId) {
		if (!images[id]) {
			bitsyLog("image doesn't exist: " + id, "graphics");
			return;
		}

		var destCtx = ctx;
		if (destId != undefined) {
			// if there's a destination ID, that means we're drawing this image *onto* another image canvas
			var destCanvas = images[destId];
			destCtx = destCanvas.getContext("2d");
		}

		destCtx.drawImage(images[id], x * scale, y * scale, images[id].width, images[id].height);
	};

	this.hasImage = function(id) {
		return images[id] != undefined;
	};

	this.getImage = function(id) {
		return images[id];
	};

	this.deleteImage = function(id) {
		delete images[id];
		delete imageFillColors[id];
	};

	this.getCanvas = function() {
		return canvas;
	};

	this.clearCanvas = function(color) {
		bitsyLog("pal? " + palette.length + " / " + color, "graphics");
		ctx.fillStyle = makeFillStyle(color);
		ctx.fillRect(0, 0, canvas.width, canvas.height);
	};
}
</script>

<script>
/* LOGGING */
var DebugLogCategory = {
	// system
	input: false,
	sound: false,
	graphics: false,
	system: false,

	// engine
	bitsy: false,

	// editor
	editor: false,

	// tools
	room: false,
	tune: false,
	blip: false,
};

var isLoggingVerbose = false;

function bitsyLog(message, category) {
	if (!category) {
		category = "bitsy";
	}

	var summary = category + "::" + message;

	if (DebugLogCategory[category] === true) {
		if (isLoggingVerbose) {
			console.group(summary);

			console.dir(message);

			console.group("stack")
			console.trace();
			console.groupEnd();

			console.groupEnd();
		}
		else {
			console.log(summary);
		}
	}
}

/* GLOBALS */
var tilesize = 8;
var mapsize = 16;
var width = mapsize * tilesize;
var height = mapsize * tilesize;
var scale = 4;
var textScale = 2;

/* SYSTEM */
var updateInterval = null;
var prevTime = 0;
var deltaTime = 0;

function initSystem() {
	prevTime = Date.now();
	updateInterval = setInterval(updateSystem, 16);
}

function updateSystem() {
	var curTime = Date.now();
	deltaTime = curTime - prevTime;

	// update all active processes
	for (var i = 0; i < processes.length; i++) {
		bitsy = processes[i].system;
		if (bitsy._active) {
			bitsyLog(bitsy._name + " img count: " + bitsy._graphics._images.length, "system");
			var shouldContinue = bitsy._update(deltaTime);
			if (!shouldContinue) {
				// todo : do I really care about this _exit thing?
				if (bitsy._name != "bitsy") {
					bitsy._exit();
				}
			}
		}
	}

	bitsy = mainProcess.system;
	prevTime = curTime;
}

function loadGame(canvas, gameData, defaultFontData) {
	bitsyLog("load!", "system");
	// initialize bitsy system
	bitsy._attachCanvas(canvas);
	bitsy._write(bitsy._gameDataBlock, gameData);
	bitsy._write(bitsy._fontDataBlock, defaultFontData);
	bitsy._start();
}

function quitGame() {
	// hack to press the menu button to force game over state
	bitsy._injectPreLoop = function() { bitsy._poke(bitsy._buttonBlock, bitsy.BTN_MENU, 1); };

	// one last update to clean up (a little hacky to do this here?)
	bitsy._update(0);
	bitsy._exit();

	// clean up this gross hack
	bitsy._injectPreLoop = null;
}

/* GRAPHICS */
var canvas; // can I get rid of these?
var ctx;

function attachCanvas(c) {
	// hack : tes tnew system
	bitsy._attachCanvas(c);
	// extra hacky
	canvas = bitsy._getCanvas();
	ctx = bitsy._getContext();
}

/* PROCESSES */
var processes = [];

function addProcess(name) {
	var proc = {};
	proc.system = new BitsySystem(name);

	processes.push(proc);

	return proc;
}

/* == SYSTEM v0.2 === */
function BitsySystem(name) {
	var self = this;

	if (!name) {
		name = "bitsy";
	}

	// memory
	var memory = {
		blocks: [],
		changed: []
	};

	// input
	var input = new InputSystem();

	// sound
	var sound = new SoundSystem();
	var soundDurationIndex = 0;
	var soundFrequencyIndex = 1;
	var soundVolumeIndex = 2;
	var soundPulseIndex = 3;
	var maxVolume = 15;

	// graphics
	var graphics = new GraphicsSystem();
	graphics.setScale(scale);
	graphics.setTextScale(textScale);
	var initialPaletteSize = 64;
	var tilePoolStart = null;
	var tilePoolSize = 512;
	// hack!!! (access for debugging)
	this._graphics = graphics;

	function updateTextScale() {
		// make sure the text scale matches the text mode
		var textMode = self._peek(modeBlock, 1);
		var textModeScale = (textMode === self.TXT_LOREZ) ? scale : textScale;
		if (graphics.getTextScale() != textModeScale) {
			graphics.setTextScale(textModeScale);
			memory.changed[self.TEXTBOX] = true;
		}
	}

	function updateInput() {
		// update input flags
		self._poke(self._buttonBlock, self.BTN_UP,
			(input.isKeyDown(input.Key.UP) || input.isKeyDown(input.Key.W) || input.swipeUp()) ? 1 : 0);

		self._poke(self._buttonBlock, self.BTN_DOWN,
			(input.isKeyDown(input.Key.DOWN) || input.isKeyDown(input.Key.S) || input.swipeDown()) ? 1 : 0);

		self._poke(self._buttonBlock, self.BTN_LEFT,
			(input.isKeyDown(input.Key.LEFT) || input.isKeyDown(input.Key.A) || input.swipeLeft()) ? 1 : 0);

		self._poke(self._buttonBlock, self.BTN_RIGHT,
			(input.isKeyDown(input.Key.RIGHT) || input.isKeyDown(input.Key.D) || input.swipeRight()) ? 1 : 0);

		self._poke(self._buttonBlock, self.BTN_OK,
			(input.anyKeyDown() || input.isTapReleased()) ? 1 : 0);

		self._poke(self._buttonBlock, self.BTN_MENU,
			(input.isRestartComboPressed()) ? 1 : 0);

		input.resetTapReleased();
	}

	function updateSound(dt) {
		var changed0 = memory.changed[self.SOUND1];
		var changed1 = memory.changed[self.SOUND2];

		// update sound channel timers
		var timer0 = self._peek(self.SOUND1, soundDurationIndex);
		timer0 -= dt;
		if (timer0 <= 0) {
			timer0 = 0;
			if (self._peek(self.SOUND1, soundVolumeIndex) > 0) {
				self._poke(self.SOUND1, soundVolumeIndex, 0);
				changed0 = true;
			}
		}
		self._poke(self.SOUND1, soundDurationIndex, timer0);

		var timer1 = self._peek(self.SOUND2, soundDurationIndex);
		timer1 -= dt;
		if (timer1 <= 0) {
			timer1 = 0;
			if (self._peek(self.SOUND2, soundVolumeIndex) > 0) {
				self._poke(self.SOUND2, soundVolumeIndex, 0);
				changed1 = true;
			}
		}
		self._poke(self.SOUND2, soundDurationIndex, timer1);

		// send updated channel attributes to the sound system
		if (changed0) {
			sound.setPulse(0, self._peek(self.SOUND1, soundPulseIndex));

			var freq = self._peek(self.SOUND1, soundFrequencyIndex);
			var freqHz = freq / 100;
			sound.setFrequency(0, freqHz);

			var volume = self._peek(self.SOUND1, soundVolumeIndex);
			volume = Math.max(0, Math.min(volume, maxVolume));
			volumeNorm = (volume / maxVolume);
			sound.setVolume(0, volumeNorm);
		}

		if (changed1) {
			sound.setPulse(1, self._peek(self.SOUND2, soundPulseIndex));

			var freq = self._peek(self.SOUND2, soundFrequencyIndex);
			var freqHz = freq / 100;
			sound.setFrequency(1, freqHz);

			var volume = self._peek(self.SOUND2, soundVolumeIndex);
			volume = Math.max(0, Math.min(volume, maxVolume));
			volumeNorm = (volume / maxVolume);
			sound.setVolume(1, volumeNorm);
		}
	}

	function updateGraphics() {
		if (self._enableGraphics === false) {
			return;
		}

		bitsyLog("update graphics", "system");

		if (memory.changed[paletteBlock]) {
			graphics.setPalette(self._dump()[paletteBlock]);
		}

		if (tilePoolStart != null) {
			for (var i = 0; i < tilePoolSize; i++) {
				var tile = tilePoolStart + i;
				if (memory.blocks[tile] != undefined && memory.changed[tile]) {
					bitsyLog("tile changed? " + tile, "system");
					// update tile image
					graphics.createImage(tile, self.TILE_SIZE, self.TILE_SIZE, self._dump()[tile]);
				}
			}
		}

		var textboxChanged = memory.changed[self.TEXTBOX] || memory.changed[textboxAttributeBlock];
		if (textboxChanged) {
			// todo : should this be optimized in some way?
			// update textbox image
			var w = self._peek(textboxAttributeBlock, 3); // todo : need a variable to store this index?
			var h = self._peek(textboxAttributeBlock, 4);
			if (w > 0 && h > 0) {
				bitsyLog("textbox changed! " + memory.changed[self.TEXTBOX] + " " + memory.changed[textboxAttributeBlock] + " " + w + " " + h, "system");
				var useTextBoxScale = true; // todo : check mode here?
				graphics.createImage(self.TEXTBOX, w, h, self._dump()[self.TEXTBOX], useTextBoxScale);
			}
		}

		var mode = self._peek(modeBlock, 0);
		if (mode === self.GFX_VIDEO) {
			if (memory.changed[self.VIDEO]) {
				graphics.clearCanvas(0);
				// update screen image
				graphics.createImage(self.VIDEO, self.VIDEO_SIZE, self.VIDEO_SIZE, self._dump()[self.VIDEO]);
				// render screen onto canvas
				graphics.drawImage(self.VIDEO, 0, 0);
			}
		}
		else if (mode === self.GFX_MAP) {
			// redraw any changed layers
			var layers = self._getTileMapLayers();
			var anyMapLayerChanged = false;
			for (var i = 0; i < layers.length; i++) {
				var layerId = layers[i];
				if (memory.changed[layerId]) {
					// need to redraw this map layer
					anyMapLayerChanged = true;
					// clear layer canvas
					graphics.setImageFill(layerId, 0); // fill transparent
					graphics.createImage(layerId, self.VIDEO_SIZE, self.VIDEO_SIZE, []);
					// render tiles onto layer canvas
					var layerData = self._dump()[layerId];
					for (var ty = 0; ty < self.MAP_SIZE; ty++) {
						for (var tx = 0; tx < self.MAP_SIZE; tx++) {
							var tileIndex = (ty * self.MAP_SIZE) + tx;
							var tile = layerData[tileIndex];
							if (tile > 0) {
								graphics.drawImage(tile, tx * self.TILE_SIZE, ty * self.TILE_SIZE, layerId);
							}
						}
					}
				}
			}

			// redraw the main canvas
			if (textboxChanged || anyMapLayerChanged) {
				bitsyLog("map changed? " + memory.changed[self.MAP1] + " " + memory.changed[self.MAP2], "system");
				graphics.clearCanvas(0);

				for (var i = 0; i < layers.length; i++) {
					var layerId = layers[i];
					// draw the layer's image canvas onto the main canvas
					graphics.drawImage(layerId, 0, 0);
				}

				// draw textbox onto canvas
				var visible = self._peek(textboxAttributeBlock, 0)
				var x = self._peek(textboxAttributeBlock, 1);
				var y = self._peek(textboxAttributeBlock, 2);
				var w = self._peek(textboxAttributeBlock, 3);
				var h = self._peek(textboxAttributeBlock, 4);
				if (visible > 0 && w > 0 && h > 0) {
					graphics.drawImage(self.TEXTBOX, x, y);
				}
			}
		}
	}

	/* == PRIVATE / DEBUG == */
	this._name = name;

	this._active = false;

	this._attachCanvas = function(c) {
		graphics.attachCanvas(c, self.VIDEO_SIZE);
	};

	this._getCanvas = graphics.getCanvas;
	this._getContext = graphics.getContext;

	this._start = function() {
		input.listen(graphics.getCanvas());
		updateTextScale();
		self._active = true;
	};

	// hacky...
	this._startNoInput = function() {
		updateTextScale();
		self._active = true;
	};

	this._exit = function() {
		// disable graphics
		var canvas = graphics.getCanvas();
		if (canvas) {
			input.unlisten(canvas);	
		}

		// disable sound
		sound.mute();

		self._active = false;
	};

	// hacky....
	this._injectPreLoop = null;
	this._injectPostDraw = null;

	this._update = function(dt) {
		var shouldContinue = false;

		updateInput();

		// too hacky???
		if (self._injectPreLoop) {
			self._injectPreLoop();
		}

		// run main loop
		if (onLoopFunction) {
			shouldContinue = onLoopFunction(dt);
		}

		if (memory.changed[modeBlock]) {
			updateTextScale();
		}

		// update output systems
		updateSound(dt);
		updateGraphics();

		if (self._injectPostDraw) {
			self._injectPostDraw();
		}

		// reset memory block changed flags
		for (var i = 0; i < memory.changed.length; i++) {
			memory.changed[i] = false;
		}

		// todo : should the _exit() call go in here?

		return shouldContinue;
	};

	this._updateGraphics = updateGraphics;

	this._allocate = function(args) {
		// find next available block in range
		var next = (args && args.start) ? args.start : 0;
		var count = (args && args.max) ? args.max : -1;
		while (memory.blocks[next] != undefined && count != 0) {
			next++;
			count--;
		}

		if (count == 0) {
			// couldn't find any available block
			return null;
		}

		if (args && args.str) {
			memory.blocks[next] = args.str;
		}
		else {
			var size = args && args.size ? args.size : 0;
			memory.blocks[next] = [];
			for (var i = 0; i < size; i++) {
				memory.blocks[next].push(0);
			}
		}

		memory.changed[next] = false;

		return next;
	};

	this._free = function(block) {
		delete memory.blocks[block];
		delete memory.changed[block];
	};

	this._peek = function(block, index) {
		var memoryBlock = memory.blocks[block];
		if (typeof(memoryBlock) === "string") {
			return memoryBlock.charCodeAt(index);
		}
		else {
			return memoryBlock[index];
		}
	};

	this._poke = function(block, index, value) {
		var memoryBlock = memory.blocks[block];
		if (typeof(memoryBlock) === "string") {
			memory.blocks[block] = memoryBlock.substring(0, index) + String.fromCharCode(value) + memoryBlock.substring(index + 1);
		}
		else {
			var value = parseInt(value);
			if (!isNaN(value)) {
				memoryBlock[index] = value;
			}
		}
		memory.changed[block] = true;
	};

	this._read = function(block) {
		var memoryBlock = memory.blocks[block];
		if (typeof(memoryBlock) === "string") {
			return memoryBlock;
		}
		else {
			var str = "";
			for (var i = 0; i < memoryBlock.length; i++) {
				str += String.fromCharCode(memoryBlock[i]);
			}
			return str;
		}
	};

	this._write = function(block, str) {
		var memoryBlock = memory.blocks[block];
		if (typeof(memoryBlock) === "string") {
			memory.blocks[block] = str;
		}
		else {
			memory.blocks[block] = [];
			for (var i = 0; i < str.length; i++) {
				memory.blocks[block][i] = str.charCodeAt(i);
			}
		}
		memory.changed[block] = true;
	};

	this._dump = function() {
		return memory.blocks;
	};

	// convenience methods for hacking around with map layers
	var tileMapLayers = [];
	this._getTileMapLayers = function() {
		return tileMapLayers;
	};
	this._addTileMapLayer = function() {
		var layer = self._allocate({
			start: (tilePoolStart + tilePoolSize),
			size: (self.MAP_SIZE * self.MAP_SIZE)
		});

		tileMapLayers.push(layer);

		return layer;
	};

	/* == CONSTANTS == */
	// memory blocks (these will be initialized below)
	this.VIDEO;
	this.TEXTBOX;
	this.MAP1;
	this.MAP2;
	this.SOUND1;
	this.SOUND2;

	// graphics modes
	this.GFX_VIDEO = 0;
	this.GFX_MAP = 1;

	// text modes
	this.TXT_HIREZ = 0; // 2x resolution
	this.TXT_LOREZ = 1; // 1x resolution

	// size
	this.TILE_SIZE = tilesize;
	this.MAP_SIZE = mapsize;
	this.VIDEO_SIZE = width;
	// todo : should text scale have a constant?

	// button codes
	this.BTN_UP = 0;
	this.BTN_DOWN = 1;
	this.BTN_LEFT = 2;
	this.BTN_RIGHT = 3;
	this.BTN_OK = 4;
	this.BTN_MENU = 5;

	// pulse waves
	this.PULSE_1_8 = 0;
	this.PULSE_1_4 = 1;
	this.PULSE_1_2 = 2;

	/* == IO == */
	this.log = function(message) {
		bitsyLog(message, name);
	};

	this.button = function(code) {
		return self._peek(buttonBlock, code) > 0;
	};

	this.getGameData = function() {
		return self._read(gameDataBlock);
	};

	this.getFontData = function() {
		return self._read(fontDataBlock);
	};

	/* == GRAPHICS == */
	this.graphicsMode = function(mode) {
		// todo : store the mode flag indices somewhere?
		if (mode != undefined) {
			self._poke(modeBlock, 0, mode);
		}

		return self._peek(modeBlock, 0);
	};

	this.textMode = function(mode) {
		// todo : test whether the requested mode is supported!
		if (mode != undefined) {
			self._poke(modeBlock, 1, mode);
		}

		return self._peek(modeBlock, 1);
	};

	this.color = function(color, r, g, b) {
		self._poke(paletteBlock, (color * 3) + 0, r);
		self._poke(paletteBlock, (color * 3) + 1, g);
		self._poke(paletteBlock, (color * 3) + 2, b);

		// mark all graphics as changed
		memory.changed[self.VIDEO] = true;
		memory.changed[self.TEXTBOX] = true;
		memory.changed[self.MAP1] = true;
		memory.changed[self.MAP2] = true;

		if (tilePoolStart != null) {
			for (var i = 0; i < tilePoolSize; i++) {
				if (memory.blocks[tilePoolStart + i] != undefined) {
					memory.changed[tilePoolStart + i] = true;
				}
			}
		}
	};

	this.tile = function() {
		return self._allocate({
			start: tilePoolStart,
			max: tilePoolSize,
			size: (self.TILE_SIZE * self.TILE_SIZE)
		});
	};

	this.delete = function(tile) {
		if (graphics.hasImage(tile)) {
			graphics.deleteImage(tile);
		}

		self._free(tile);
	};

	this.fill = function(block, value) {
		var len = memory.blocks[block].length;
		for (var i = 0; i < len; i++) {
			self._poke(block, i, value);
		}

		var isImage = (block === self.VIDEO) ||
			(block === self.TEXTBOX) ||
			(block >= tilePoolStart && block < (tilePoolStart + tilePoolSize));

		// optimize rendering by notifying the graphics system what the fill color is for this image
		if (isImage) {
			graphics.setImageFill(block, value);
		}
	};

	this.set = function(block, index, value) {
		self._poke(block, index, value);
	};

	this.textbox = function(visible, x, y, w, h) {
		if (visible != undefined) {
			self._poke(textboxAttributeBlock, 0, (visible === true) ? 1 : 0);
		}
		
		if (x != undefined) {
			self._poke(textboxAttributeBlock, 1, x);
		}
		
		if (y != undefined) {
			self._poke(textboxAttributeBlock, 2, y);
		}

		var prevWidth = self._peek(textboxAttributeBlock, 3);
		var prevHeight = self._peek(textboxAttributeBlock, 4);

		if (w != undefined) {
			self._poke(textboxAttributeBlock, 3, w);
		}
		
		if (h != undefined) {
			self._poke(textboxAttributeBlock, 4, h);
		}

		if (w != undefined && h != undefined && (prevWidth != w || prevHeight != h)) {
			// re-allocate the textbox block (should I have a helper function for this?)
			memory.blocks[self.TEXTBOX] = [];
			for (var i = 0; i < (w * h); i++) {
				memory.blocks[self.TEXTBOX].push(0);
			}
			memory.changed[self.TEXTBOX] = true;
		}
	};

	/* == SOUND == */
	// duration is in milliseconds (ms)
	this.sound = function(channel, duration, frequency, volume, pulse) {
		self._poke(channel, soundDurationIndex, duration);
		self._poke(channel, soundFrequencyIndex, frequency);
		self._poke(channel, soundVolumeIndex, volume);
		self._poke(channel, soundPulseIndex, pulse);
	};

	// frequency is in decihertz (dHz)
	this.frequency = function(channel, frequency) {
		self._poke(channel, soundFrequencyIndex, frequency);
	};

	// volume: min = 0, max = 15
	this.volume = function(channel, volume) {
		self._poke(channel, soundVolumeIndex, volume);
	};

	/* == EVENTS == */
	this.loop = function(fn) {
		onLoopFunction = fn;
	};

	/* == INTERNAL == */
	// initialize memory blocks
	var gameDataBlock = this._allocate({ str: "" });
	var fontDataBlock = this._allocate({ str: "" });
	this.VIDEO = this._allocate({ size: self.VIDEO_SIZE * self.VIDEO_SIZE });
	this.TEXTBOX = this._allocate();
	this.MAP1 = this._allocate({ size: self.MAP_SIZE * self.MAP_SIZE });
	tileMapLayers.push(this.MAP1);
	this.MAP2 = this._allocate({ size: self.MAP_SIZE * self.MAP_SIZE });
	tileMapLayers.push(this.MAP2);
	var paletteBlock = this._allocate({ size: initialPaletteSize * 3 });
	var buttonBlock = this._allocate({ size: 8 });
	this.SOUND1 = this._allocate({ size: 4 });
	this.SOUND2 = this._allocate({ size: 4 });
	var modeBlock = this._allocate({ size: 8 });
	var textboxAttributeBlock = this._allocate({ size: 8 });

	tilePoolStart = (textboxAttributeBlock + 1);

	// access for debugging
	this._gameDataBlock = gameDataBlock;
	this._fontDataBlock = fontDataBlock;
	this._buttonBlock = buttonBlock;

	// events
	var onLoopFunction = null;
}

var mainProcess = addProcess();
var bitsy = mainProcess.system;
</script>

<!-- engine -->
<script>
/* BITSY VERSION */
// is this the right place for this to live?
var version = {
	major: 8, // major changes
	minor: 12, // smaller changes
	devBuildPhase: "RELEASE",
};
function getEngineVersion() {
	return version.major + "." + version.minor;
}

/* TEXT CONSTANTS */
var titleDialogId = "title";

// todo : where should this be stored?
var tileColorStartIndex = 16;

var TextDirection = {
	LeftToRight : "LTR",
	RightToLeft : "RTL"
};

var defaultFontName = "ascii_small";

/* TUNE CONSTANTS */
var barLength = 16; // sixteenth notes
var minTuneLength = 1;
var maxTuneLength = 16;

// chromatic notes
var Note = {
	NONE 		: -1,
	C 			: 0,	// C
	C_SHARP 	: 1,	// C sharp / D flat
	D 			: 2,	// D
	D_SHARP 	: 3,	// D sharp / E flat
	E 			: 4,	// E
	F 			: 5,	// F
	F_SHARP 	: 6,	// F sharp / G flat
	G 			: 7,	// G
	G_SHARP 	: 8,	// G sharp / A flat
	A 			: 9,	// A
	A_SHARP 	: 10,	// A sharp / B flat
	B 			: 11,	// B
	COUNT 		: 12
};

// solfa notes
var Solfa = {
	NONE 	: -1,
	D 		: 0,	// Do
	R 		: 1,	// Re
	M 		: 2,	// Mi
	F 		: 3,	// Fa
	S 		: 4,	// Sol
	L 		: 5,	// La
	T 		: 6,	// Ti
	COUNT 	: 7
};

var Octave = {
	NONE: -1,
	2: 0,
	3: 1,
	4: 2, // octave 4: middle C octave
	5: 3,
	COUNT: 4
};

var Tempo = {
	SLW: 0, // slow
	MED: 1, // medium
	FST: 2, // fast
	XFST: 3 // extra fast (aka turbo)
};

var SquareWave = {
	P8: 0, // pulse 1 / 8
	P4: 1, // pulse 1 / 4
	P2: 2, // pulse 1 / 2
	COUNT: 3
};

var ArpeggioPattern = {
	OFF: 0,
	UP: 1, // ascending triad chord
	DWN: 2, // descending triad chord
	INT5: 3, // 5 step interval
	INT8: 4 // 8 setp interval
};

function createWorldData() {
	return {
		room : {},
		tile : {},
		sprite : {},
		item : {},
		dialog : {},
		end : {}, // pre-7.0 ending data for backwards compatibility
		palette : { // start off with a default palette
			"default" : {
				name : "default",
				colors : [[0,0,0],[255,255,255],[255,255,255]]
			}
		},
		variable : {},
		tune : {},
		blip : {},
		versionNumberFromComment : -1, // -1 indicates no version information found
		fontName : defaultFontName,
		textDirection : TextDirection.LeftToRight,
		flags : createDefaultFlags(),
		names : {},
		// source data for all drawings (todo: better name?)
		drawings : {},
	};
}

// creates a drawing data structure with default property values for the type
function createDrawingData(type, id) {
	// the avatar's drawing id still uses the sprite prefix (for back compat)
	var drwId = (type === "AVA" ? "SPR" : type) + "_" + id;

	var drawingData = {
		type : type,
		id : id,
		name : null,
		drw : drwId,
		col : (type === "TIL") ? 1 : 2, // foreground color
		bgc : 0, // background color
		animation : {
			isAnimated : false,
			frameIndex : 0,
			frameCount : 1,
		},
	};

	// add type specific properties
	if (type === "TIL") {
		// default null value indicates it can vary from room to room (original version)
		drawingData.isWall = null;
	}

	if (type === "AVA" || type === "SPR") {
		// default sprite location is "offstage"
		drawingData.room = null;
		drawingData.x = -1;
		drawingData.y = -1;
		drawingData.inventory = {};
	}

	if (type === "AVA" || type === "SPR" || type === "ITM") {
		drawingData.dlg = null;
		drawingData.blip = null;
	}

	return drawingData;
}

function createTuneData(id) {
	var tuneData = {
		id : id,
		name : null,
		melody : [],
		harmony : [],
		key: null, // a null key indicates a chromatic scale (all notes enabled)
		tempo: Tempo.MED,
		instrumentA : SquareWave.P2,
		instrumentB : SquareWave.P2,
		arpeggioPattern : ArpeggioPattern.OFF,
	};
	return tuneData;
}

function createTuneBarData() {
	var bar = [];
	for (var i = 0; i < barLength; i++) {
		bar.push({ beats: 0, note: Note.C, octave: Octave[4] });
	}
	return bar;
}

function createTuneKeyData() {
	var key = {
		notes: [], // mapping of the solfa scale degrees to chromatic notes
		scale: []  // list of solfa notes that are enabled for this key
	};

	// initialize notes
	for (var i = 0; i < Solfa.COUNT; i++) {
		key.notes.push(Note.NONE);
	}

	return key;
}

function createBlipData(id) {
	var blipData = {
		id: id,
		name: null,
		pitchA: { beats: 0, note: Note.C, octave: Octave[4] },
		pitchB: { beats: 0, note: Note.C, octave: Octave[4] },
		pitchC: { beats: 0, note: Note.C, octave: Octave[4] },
		envelope: {
			attack: 0, // attack time in ms
			decay: 0, // decay time in ms
			sustain: 0, // sustain volume
			length: 0, // sustain time in ms
			release: 0 // release time in ms
		},
		beat : {
			time: 0, // time in ms between pitch changes
			delay: 0 // time in ms *before* first pitch change
		},
		instrument: SquareWave.P2,
		doRepeat: false
		// TODO : consider for future update
		// doSlide: false,
	};

	return blipData;
}

function createDefaultFlags() {
	return {
		// version
		VER_MAJ: -1, // major version number (-1 = no version information found)
		VER_MIN: -1, // minor version number (-1 = no version information found)
		// compatibility
		ROOM_FORMAT: 0, // 0 = non-comma separated (original), 1 = comma separated (default)
		DLG_COMPAT: 0, // 0 = default dialog behavior, 1 = pre-7.0 dialog behavior
		// config
		TXT_MODE: 0 // 0 = HIREZ (2x - default), 1 = LOREZ (1x)
	};
}

function createDialogData(id) {
	return {
		src : "",
		name : null,
		id : id,
	};
}

function parseWorld(file) {
	bitsy.log("create world data");

	var world = createWorldData();

	bitsy.log("init parse state");

	var parseState = {
		lines : file.split("\n"),
		index : 0,
		spriteStartLocations : {}
	};

	bitsy.log("start reading lines");

	while (parseState.index < parseState.lines.length) {
		var i = parseState.index;
		var lines = parseState.lines;
		var curLine = lines[i];

		// bitsy.log("LN " + i + " xx " + curLine);

		if (i == 0) {
			i = parseTitle(parseState, world);
		}
		else if (curLine.length <= 0 || curLine.charAt(0) === "#") {
			// collect version number from a comment (hacky but required for pre-8.0 compatibility)
			if (curLine.indexOf("# BITSY VERSION ") != -1) {
				world.versionNumberFromComment = parseFloat(curLine.replace("# BITSY VERSION ", ""));
			}

			//skip blank lines & comments
			i++;
		}
		else if (getType(curLine) === "PAL") {
			i = parsePalette(parseState, world);
		}
		else if (getType(curLine) === "ROOM" || getType(curLine) === "SET") { // SET for back compat
			i = parseRoom(parseState, world);
		}
		else if (getType(curLine) === "TIL") {
			i = parseTile(parseState, world);
		}
		else if (getType(curLine) === "SPR") {
			i = parseSprite(parseState, world);
		}
		else if (getType(curLine) === "ITM") {
			i = parseItem(parseState, world);
		}
		else if (getType(curLine) === "DLG") {
			i = parseDialog(parseState, world);
		}
		else if (getType(curLine) === "END") {
			// parse endings for back compat
			i = parseEnding(parseState, world);
		}
		else if (getType(curLine) === "VAR") {
			i = parseVariable(parseState, world);
		}
		else if (getType(curLine) === "DEFAULT_FONT") {
			i = parseFontName(parseState, world);
		}
		else if (getType(curLine) === "TEXT_DIRECTION") {
			i = parseTextDirection(parseState, world);
		}
		else if (getType(curLine) === "FONT") {
			i = parseFontData(parseState, world);
		}
		else if (getType(curLine) === "TUNE") {
			i = parseTune(parseState, world);
		}
		else if (getType(curLine) === "BLIP") {
			i = parseBlip(parseState, world);
		}
		else if (getType(curLine) === "!") {
			i = parseFlag(parseState, world);
		}
		else {
			i++;
		}

		parseState.index = i;
	}

	world.names = createNameMapsForWorld(world);

	placeSprites(parseState, world);

	if ((world.flags.VER_MAJ <= -1 || world.flags.VER_MIN <= -1) && world.versionNumberFromComment > -1) {
		var versionNumberStr = "" + world.versionNumberFromComment;
		versionNumberStr = versionNumberStr.split(".");
		world.flags.VER_MAJ = parseFloat(versionNumberStr[0]);
		world.flags.VER_MIN = parseFloat(versionNumberStr[1]);
	}

	// starting in version v7.0, there were two major changes to dialog behavior:
	// 1) sprite dialog was no longer implicitly linked by the sprite and dialog IDs matching
	//    (see this commit: 5e1adb29faad4e50603c689d2dac143074117b4e)
	// 2) ending dialogs no longer had their own world data type ("END")
	// for the v7.x versions I tried to automatically convert old dialog to the new format,
	// however, that process can be unreliable and lead to weird bugs.
	// with v8.0 and above I will no longer attempt to convert old files, and instead will use
	// a flag to indicate files that need to use the backwards compatible behavior -
	// this is more reliable & configurable (at the cost of making pre-7.0 games a bit harder to edit)
	if (world.flags.VER_MAJ < 7) {
		world.flags.DLG_COMPAT = 1;
	}

	return world;
}

function parseTitle(parseState, world) {
	var i = parseState.index;
	var lines = parseState.lines;

	var results;
	if (scriptUtils) {
		results = scriptUtils.ReadDialogScript(lines,i);
	}
	else {
		results = { script: lines[i], index: (i + 1) };
	}

	world.dialog[titleDialogId] = createDialogData(titleDialogId);
	world.dialog[titleDialogId].src = results.script;

	i = results.index;
	i++;

	return i;
}

function parsePalette(parseState, world) {
	var i = parseState.index;
	var lines = parseState.lines;

	var id = getId(lines[i]);
	i++;
	var colors = [];
	var name = null;
	while (i < lines.length && lines[i].length > 0) { //look for empty line
		var args = lines[i].split(" ");
		if (args[0] === "NAME") {
			name = lines[i].split(/\s(.+)/)[1];
		}
		else {
			var col = [];
			lines[i].split(",").forEach(function(i) {
				col.push(parseInt(i));
			});
			colors.push(col);
		}
		i++;
	}
	world.palette[id] = {
		id : id,
		name : name,
		colors : colors
	};
	return i;
}

function createRoomData(id) {
	return {
		id: id,
		name: null,
		tilemap: [],
		walls: [],
		exits: [],
		endings: [],
		items: [],
		pal: null,
		ava: null,
		tune: "0"
	};
}

function createExitData(x, y, destRoom, destX, destY, transition, dlg) {
	return {
		x: x,
		y: y,
		dest: {
			room: destRoom,
			x: destX,
			y: destY
		},
		transition_effect: transition,
		dlg: dlg,
	};
}

function createEndingData(id, x, y) {
	return {
		id: id,
		x: x,
		y: y
	};
}

function parseRoom(parseState, world) {
	var i = parseState.index;
	var lines = parseState.lines;
	var id = getId(lines[i]);

	var roomData = createRoomData(id);

	i++;

	// create tile map
	if (world.flags.ROOM_FORMAT === 0) {
		// old way: no commas, single char tile ids
		var end = i + bitsy.MAP_SIZE;
		var y = 0;
		for (; i < end; i++) {
			roomData.tilemap.push([]);
			for (x = 0; x < bitsy.MAP_SIZE; x++) {
				roomData.tilemap[y].push(lines[i].charAt(x));
			}
			y++;
		}
	}
	else if (world.flags.ROOM_FORMAT === 1) {
		// new way: comma separated, multiple char tile ids
		var end = i + bitsy.MAP_SIZE;
		var y = 0;
		for (; i < end; i++) {
			roomData.tilemap.push([]);
			var lineSep = lines[i].split(",");
			for (x = 0; x < bitsy.MAP_SIZE; x++) {
				roomData.tilemap[y].push(lineSep[x]);
			}
			y++;
		}
	}

	while (i < lines.length && lines[i].length > 0) { //look for empty line
		// bitsy.log(getType(lines[i]));
		if (getType(lines[i]) === "SPR") {
			/* NOTE SPRITE START LOCATIONS */
			var sprId = getId(lines[i]);
			if (sprId.indexOf(",") == -1 && lines[i].split(" ").length >= 3) { //second conditional checks for coords
				/* PLACE A SINGLE SPRITE */
				var sprCoord = lines[i].split(" ")[2].split(",");
				parseState.spriteStartLocations[sprId] = {
					room : id,
					x : parseInt(sprCoord[0]),
					y : parseInt(sprCoord[1])
				};
			}
			else if ( world.flags.ROOM_FORMAT == 0 ) { // TODO: right now this shortcut only works w/ the old comma separate format
				/* PLACE MULTIPLE SPRITES*/ 
				//Does find and replace in the tilemap (may be hacky, but its convenient)
				var sprList = sprId.split(",");
				for (row in roomData.tilemap) {
					for (s in sprList) {
						var col = roomData.tilemap[row].indexOf( sprList[s] );
						//if the sprite is in this row, replace it with the "null tile" and set its starting position
						if (col != -1) {
							roomData.tilemap[row][col] = "0";
							parseState.spriteStartLocations[ sprList[s] ] = {
								room : id,
								x : parseInt(col),
								y : parseInt(row)
							};
						}
					}
				}
			}
		}
		else if (getType(lines[i]) === "ITM") {
			var itmId = getId(lines[i]);
			var itmCoord = lines[i].split(" ")[2].split(",");
			var itm = {
				id: itmId,
				x : parseInt(itmCoord[0]),
				y : parseInt(itmCoord[1])
			};
			roomData.items.push( itm );
		}
		else if (getType(lines[i]) === "WAL") {
			/* DEFINE COLLISIONS (WALLS) */
			roomData.walls = getId(lines[i]).split(",");
		}
		else if (getType(lines[i]) === "EXT") {
			/* ADD EXIT */
			var exitArgs = lines[i].split(" ");
			//arg format: EXT 10,5 M 3,2 [AVA:7 LCK:a,9] [AVA 7 LCK a 9]
			var exitCoords = exitArgs[1].split(",");
			var destName = exitArgs[2];
			var destCoords = exitArgs[3].split(",");
			var ext = createExitData(
				/* x 			*/ parseInt(exitCoords[0]),
				/* y 			*/ parseInt(exitCoords[1]),
				/* destRoom 	*/ destName,
				/* destX 		*/ parseInt(destCoords[0]),
				/* destY 		*/ parseInt(destCoords[1]),
				/* transition 	*/ null,
				/* dlg 			*/ null);

			// optional arguments
			var exitArgIndex = 4;
			while (exitArgIndex < exitArgs.length) {
				if (exitArgs[exitArgIndex] == "FX") {
					ext.transition_effect = exitArgs[exitArgIndex+1];
					exitArgIndex += 2;
				}
				else if (exitArgs[exitArgIndex] == "DLG") {
					ext.dlg = exitArgs[exitArgIndex+1];
					exitArgIndex += 2;
				}
				else {
					exitArgIndex += 1;
				}
			}

			roomData.exits.push(ext);
		}
		else if (getType(lines[i]) === "END") {
			/* ADD ENDING */
			var endId = getId(lines[i]);

			var endCoords = getCoord(lines[i], 2);
			var end = createEndingData(
				/* id */ endId,
				/* x */ parseInt(endCoords[0]),
				/* y */ parseInt(endCoords[1]));

			roomData.endings.push(end);
		}
		else if (getType(lines[i]) === "PAL") {
			/* CHOOSE PALETTE (that's not default) */
			roomData.pal = getId(lines[i]);
		}
		else if (getType(lines[i]) === "AVA") {
			// change avatar appearance per room
			roomData.ava = getId(lines[i]);
		}
		else if (getType(lines[i]) === "TUNE") {
			roomData.tune = getId(lines[i]);
		}
		else if (getType(lines[i]) === "NAME") {
			roomData.name = getNameArg(lines[i]);
		}

		i++;
	}

	world.room[id] = roomData;

	return i;
}

function parseTile(parseState, world) {
	var i = parseState.index;
	var lines = parseState.lines;

	var id = getId(lines[i]);
	var tileData = createDrawingData("TIL", id);

	i++;

	// read & store tile image source
	i = parseDrawingCore(lines, i, tileData.drw, world);

	// update animation info
	tileData.animation.frameCount = getDrawingFrameCount(world, tileData.drw);
	tileData.animation.isAnimated = tileData.animation.frameCount > 1;

	// read other properties
	while (i < lines.length && lines[i].length > 0) { // look for empty line
		if (getType(lines[i]) === "COL") {
			tileData.col = parseInt(getId(lines[i]));
		}
		else if (getType(lines[i]) === "BGC") {
			var bgcId = getId(lines[i]);
			if (bgcId === "*") {
				// transparent background
				tileData.bgc = (-1 * tileColorStartIndex);
			}
			else {
				tileData.bgc = parseInt(bgcId);
			}
		}
		else if (getType(lines[i]) === "NAME") {
			/* NAME */
			tileData.name = getNameArg(lines[i]);
		}
		else if (getType(lines[i]) === "WAL") {
			var wallArg = getArg(lines[i], 1);
			if (wallArg === "true") {
				tileData.isWall = true;
			}
			else if (wallArg === "false") {
				tileData.isWall = false;
			}
		}

		i++;
	}

	// store tile data
	world.tile[id] = tileData;

	return i;
}

function parseSprite(parseState, world) {
	var i = parseState.index;
	var lines = parseState.lines;

	var id = getId(lines[i]);
	var type = (id === "A") ? "AVA" : "SPR";
	var spriteData = createDrawingData(type, id);

	// bitsy.log(spriteData);

	i++;

	// read & store sprite image source
	i = parseDrawingCore(lines, i, spriteData.drw, world);

	// update animation info
	spriteData.animation.frameCount = getDrawingFrameCount(world, spriteData.drw);
	spriteData.animation.isAnimated = spriteData.animation.frameCount > 1;

	// read other properties
	while (i < lines.length && lines[i].length > 0) { // look for empty line
		if (getType(lines[i]) === "COL") {
			/* COLOR OFFSET INDEX */
			spriteData.col = parseInt(getId(lines[i]));
		}
		else if (getType(lines[i]) === "BGC") {
			/* BACKGROUND COLOR */
			var bgcId = getId(lines[i]);
			if (bgcId === "*") {
				// transparent background
				spriteData.bgc = (-1 * tileColorStartIndex);
			}
			else {
				spriteData.bgc = parseInt(bgcId);
			}
		}
		else if (getType(lines[i]) === "POS") {
			/* STARTING POSITION */
			var posArgs = lines[i].split(" ");
			var roomId = posArgs[1];
			var coordArgs = posArgs[2].split(",");
			parseState.spriteStartLocations[id] = {
				room : roomId,
				x : parseInt(coordArgs[0]),
				y : parseInt(coordArgs[1])
			};
		}
		else if(getType(lines[i]) === "DLG") {
			spriteData.dlg = getId(lines[i]);
		}
		else if (getType(lines[i]) === "NAME") {
			/* NAME */
			spriteData.name = getNameArg(lines[i]);
		}
		else if (getType(lines[i]) === "ITM") {
			/* ITEM STARTING INVENTORY */
			var itemId = getId(lines[i]);
			var itemCount = parseFloat(getArg(lines[i], 2));
			spriteData.inventory[itemId] = itemCount;
		}
		else if (getType(lines[i]) == "BLIP") {
			var blipId = getId(lines[i]);
			spriteData.blip = blipId;
		}

		i++;
	}

	// store sprite data
	world.sprite[id] = spriteData;

	return i;
}

function parseItem(parseState, world) {
	var i = parseState.index;
	var lines = parseState.lines;

	var id = getId(lines[i]);
	var itemData = createDrawingData("ITM", id);

	i++;

	// read & store item image source
	i = parseDrawingCore(lines, i, itemData.drw, world);

	// update animation info
	itemData.animation.frameCount = getDrawingFrameCount(world, itemData.drw);
	itemData.animation.isAnimated = itemData.animation.frameCount > 1;

	// read other properties
	while (i < lines.length && lines[i].length > 0) { // look for empty line
		if (getType(lines[i]) === "COL") {
			/* COLOR OFFSET INDEX */
			itemData.col = parseInt(getArg(lines[i], 1));
		}
		else if (getType(lines[i]) === "BGC") {
			/* BACKGROUND COLOR */
			var bgcId = getId(lines[i]);
			if (bgcId === "*") {
				// transparent background
				itemData.bgc = (-1 * tileColorStartIndex);
			}
			else {
				itemData.bgc = parseInt(bgcId);
			}
		}
		else if (getType(lines[i]) === "DLG") {
			itemData.dlg = getId(lines[i]);
		}
		else if (getType(lines[i]) === "NAME") {
			/* NAME */
			itemData.name = getNameArg(lines[i]);
		}
		else if (getType(lines[i]) == "BLIP") {
			var blipId = getId(lines[i]);
			itemData.blip = blipId;
		}

		i++;
	}

	// store item data
	world.item[id] = itemData;

	return i;
}

function parseDrawingCore(lines, i, drwId, world) {
	var frameList = []; //init list of frames
	frameList.push( [] ); //init first frame
	var frameIndex = 0;
	var y = 0;
	while (y < bitsy.TILE_SIZE) {
		var line = lines[i + y];
		var row = [];

		for (x = 0; x < bitsy.TILE_SIZE; x++) {
			row.push(parseInt(line.charAt(x)));
		}

		frameList[frameIndex].push(row);
		y++;

		if (y === bitsy.TILE_SIZE) {
			i = i + y;
			if (lines[i] != undefined && lines[i].charAt(0) === ">") {
				// start next frame!
				frameList.push([]);
				frameIndex++;

				//start the count over again for the next frame
				i++;
				y = 0;
			}
		}
	}

	storeDrawingData(world, drwId, frameList);

	return i;
}

function parseDialog(parseState, world) {
	var i = parseState.index;
	var lines = parseState.lines;

	// hacky but I need to store this so I can set the name below
	var id = getId(lines[i]);

	i = parseScript(lines, i, world.dialog);

	if (i < lines.length && lines[i].length > 0 && getType(lines[i]) === "NAME") {
		world.dialog[id].name = getNameArg(lines[i]);
		i++;
	}

	return i;
}

// keeping this around to parse old files where endings were separate from dialogs
function parseEnding(parseState, world) {
	var i = parseState.index;
	var lines = parseState.lines;

	return parseScript(lines, i, world.end);
}

function parseScript(lines, i, data) {
	var id = getId(lines[i]);
	i++;

	var results;
	if (scriptUtils) {
		results = scriptUtils.ReadDialogScript(lines,i);
	}
	else {
		results = { script: lines[i], index: (i + 1)};
	}

	data[id] = createDialogData(id);
	data[id].src = results.script;

	i = results.index;

	return i;
}

function parseVariable(parseState, world) {
	var i = parseState.index;
	var lines = parseState.lines;
	var id = getId(lines[i]);
	i++;
	var value = lines[i];
	i++;
	world.variable[id] = value;
	return i;
}

function parseFontName(parseState, world) {
	var i = parseState.index;
	var lines = parseState.lines;
	world.fontName = getArg(lines[i], 1);
	i++;
	return i;
}

function parseTextDirection(parseState, world) {
	var i = parseState.index;
	var lines = parseState.lines;
	world.textDirection = getArg(lines[i], 1);
	i++;
	return i;
}

function parseFontData(parseState, world) {
	var i = parseState.index;
	var lines = parseState.lines;

	// NOTE : we're not doing the actual parsing here --
	// just grabbing the block of text that represents the font
	// and giving it to the font manager to use later

	var localFontName = getId(lines[i]);
	var localFontData = lines[i];
	i++;

	while (i < lines.length && lines[i] != "") {
		localFontData += "\n" + lines[i];
		i++;
	}

	var localFontFilename = localFontName + fontManager.GetExtension();
	fontManager.AddResource( localFontFilename, localFontData );

	return i;
}

function parseTune(parseState, world) {
	var i = parseState.index;
	var lines = parseState.lines;

	var id = getId(lines[i]);
	i++;

	var tuneData = createTuneData(id);

	var barIndex = 0;
	while (barIndex < maxTuneLength) {
		// MELODY
		var melodyBar = createTuneBarData();
		var melodyNotes = lines[i].split(",");
		for (var j = 0; j < barLength; j++) {
			// default to a rest
			var pitch = { beats: 0, note: Note.C, octave: Octave[4], };

			if (j < melodyNotes.length) {
				var pitchSplit = melodyNotes[j].split("~");
				var pitchStr = pitchSplit[0];
				pitch = parsePitch(melodyNotes[j]);

				// look for effect added to the note
				if (pitchSplit.length > 1) {
					var blipId = pitchSplit[1];
					pitch.blip = blipId;
				}
			}

			melodyBar[j] = pitch;
		}
		tuneData.melody.push(melodyBar);
		i++;

		// HARMONY
		var harmonyBar = createTuneBarData();
		var harmonyNotes = lines[i].split(",");
		for (var j = 0; j < barLength; j++) {
			// default to a rest
			var pitch = { beats: 0, note: Note.C, octave: Octave[4], };

			if (j < harmonyNotes.length) {
				var pitchSplit = harmonyNotes[j].split("~");
				var pitchStr = pitchSplit[0];
				pitch = parsePitch(harmonyNotes[j]);

				// look for effect added to the note
				if (pitchSplit.length > 1) {
					var blipId = pitchSplit[1];
					pitch.blip = blipId;
				}
			}

			harmonyBar[j] = pitch;
		}
		tuneData.harmony.push(harmonyBar);
		i++;

		// check if there's another bar after this one
		if (lines[i] === ">") {
			// there is! increment the index
			barIndex++;
			i++;
		}
		else {
			// we've reached the end of the tune!
			barIndex = maxTuneLength;
		}
	}

	// parse other tune properties
	while (i < lines.length && lines[i].length > 0) { // look for empty line
		if (getType(lines[i]) === "KEY") {
			tuneData.key = createTuneKeyData();

			var keyNotes = getArg(lines[i], 1);
			if (keyNotes) {
				keyNotes = keyNotes.split(",");
				for (var j = 0; j < keyNotes.length && j < tuneData.key.notes.length; j++) {
					var pitch = parsePitch(keyNotes[j]);
					tuneData.key.notes[j] = pitch.note;
				}
			}

			var keyScale = getArg(lines[i], 2);
			if (keyScale) {
				keyScale = keyScale.split(",");
				for (var j = 0; j < keyScale.length; j++) {
					var pitch = parsePitch(keyScale[j]);
					if (pitch.note > Solfa.NONE && pitch.note < Solfa.COUNT) {
						tuneData.key.scale.push(pitch.note);
					}
				}
			}
		}
		else if (getType(lines[i]) === "TMP") {
			var tempoId = getId(lines[i]);
			if (Tempo[tempoId] != undefined) {
				tuneData.tempo = Tempo[tempoId];
			}
		}
		else if (getType(lines[i]) === "SQR") {
			// square wave instrument settings
			var squareWaveIdA = getArg(lines[i], 1);
			if (SquareWave[squareWaveIdA] != undefined) {
				tuneData.instrumentA = SquareWave[squareWaveIdA];
			}

			var squareWaveIdB = getArg(lines[i], 2);
			if (SquareWave[squareWaveIdB] != undefined) {
				tuneData.instrumentB = SquareWave[squareWaveIdB];
			}
		}
		else if (getType(lines[i]) === "ARP") {
			var arp = getId(lines[i]);
			if (ArpeggioPattern[arp] != undefined) {
				tuneData.arpeggioPattern = ArpeggioPattern[arp];
			}
		}
		else if (getType(lines[i]) === "NAME") {
			var name = lines[i].split(/\s(.+)/)[1];
			tuneData.name = name;
			// todo : add to map?
		}

		i++;
	}

	world.tune[id] = tuneData;

	return i;
}

function parseBlip(parseState, world) {
	var i = parseState.index;
	var lines = parseState.lines;

	var id = getId(lines[i]);
	i++;

	var blipData = createBlipData(id);

	// blip pitches
	var notes = lines[i].split(",");
	if (notes.length >= 1) {
		blipData.pitchA = parsePitch(notes[0]);
	}
	if (notes.length >= 2) {
		blipData.pitchB = parsePitch(notes[1]);
	}
	if (notes.length >= 3) {
		blipData.pitchC = parsePitch(notes[2]);
	}
	i++;

	// blip parameters
	while (i < lines.length && lines[i].length > 0) { // look for empty line
		if (getType(lines[i]) === "ENV") {
			// envelope
			blipData.envelope.attack = parseInt(getArg(lines[i], 1));
			blipData.envelope.decay = parseInt(getArg(lines[i], 2));
			blipData.envelope.sustain = parseInt(getArg(lines[i], 3));
			blipData.envelope.length = parseInt(getArg(lines[i], 4));
			blipData.envelope.release = parseInt(getArg(lines[i], 5));
		}
		else if (getType(lines[i]) === "BEAT") {
			// pitch beat length
			blipData.beat.time = parseInt(getArg(lines[i], 1));
			blipData.beat.delay = parseInt(getArg(lines[i], 2));
		}
		else if (getType(lines[i]) === "SQR") {
			// square wave
			var squareWaveId = getArg(lines[i], 1);
			if (SquareWave[squareWaveId] != undefined) {
				blipData.instrument = SquareWave[squareWaveId];
			}
		}
		// TODO : consider for future update
		// else if (getType(lines[i]) === "SLD") {
		// 	// slide mode
		// 	if (parseInt(getArg(lines[i], 1)) === 1) {
		// 		blipData.doSlide = true;
		// 	}
		// }
		else if (getType(lines[i]) === "RPT") {
			// repeat mode
			if (parseInt(getArg(lines[i], 1)) === 1) {
				blipData.doRepeat = true;
			}
		}
		else if (getType(lines[i]) === "NAME") {
			var name = lines[i].split(/\s(.+)/)[1];
			blipData.name = name;
		}

		i++;
	}

	world.blip[id] = blipData;

	return i;
}

function parsePitch(pitchStr) {
	var pitch = { beats: 1, note: Note.C, octave: Octave[4], };
	var i;

	// beats
	var beatsToken = "";
	for (i = 0; i < pitchStr.length && ("0123456789".indexOf(pitchStr[i]) != -1); i++) {
		beatsToken += pitchStr[i];
	}
	if (beatsToken.length > 0) {
		pitch.beats = parseInt(beatsToken);
	}

	// note
	var noteType;
	var noteName = "";
	if (i < pitchStr.length) {
		if (pitchStr[i] === pitchStr[i].toUpperCase()) {
			// uppercase letters represent chromatic notes
			noteType = Note;
			noteName += pitchStr[i];
			i++;

			// check for sharp
			if (i < pitchStr.length && pitchStr[i] === "#") {
				noteName += "_SHARP";
				i++;
			}
		}
		else {
			// lowercase letters represent solfa notes
			noteType = Solfa;
			noteName += pitchStr[i].toUpperCase();
			i++;
		}
	}

	if (noteType != undefined && noteType[noteName] != undefined) {
		pitch.note = noteType[noteName];
	}

	// octave
	var octaveToken = "";
	if (i < pitchStr.length) {
		octaveToken += pitchStr[i];
	}

	if (Octave[octaveToken] != undefined) {
		pitch.octave = Octave[octaveToken];
	}

	return pitch;
}

function parseFlag(parseState, world) {
	var i = parseState.index;
	var lines = parseState.lines;
	var id = getId(lines[i]);
	var valStr = lines[i].split(" ")[2];
	world.flags[id] = parseInt( valStr );
	i++;
	return i;
}

function getDrawingFrameCount(world, drwId) {
	return world.drawings[drwId].length;
}

function storeDrawingData(world, drwId, drawingData) {
	world.drawings[drwId] = drawingData;
}

function placeSprites(parseState, world) {
	for (id in parseState.spriteStartLocations) {
		world.sprite[id].room = parseState.spriteStartLocations[id].room;
		world.sprite[id].x = parseState.spriteStartLocations[id].x;
		world.sprite[id].y = parseState.spriteStartLocations[id].y;
	}
}

function createNameMapsForWorld(world) {
	var nameMaps = {};

	function createNameMap(objectStore) {
		var map = {};

		for (id in objectStore) {
			if (objectStore[id].name != undefined && objectStore[id].name != null) {
				map[objectStore[id].name] = id;
			}
		}

		return map;
	}

	nameMaps.room = createNameMap(world.room);
	nameMaps.tile = createNameMap(world.tile);
	nameMaps.sprite = createNameMap(world.sprite);
	nameMaps.item = createNameMap(world.item);
	nameMaps.dialog = createNameMap(world.dialog);
	nameMaps.palette = createNameMap(world.palette);
	nameMaps.tune = createNameMap(world.tune);
	nameMaps.blip = createNameMap(world.blip);

	return nameMaps;
}

function getType(line) {
	return getArg(line,0);
}

function getId(line) {
	return getArg(line,1);
}

function getCoord(line,arg) {
	return getArg(line,arg).split(",");
}

function getArg(line,arg) {
	return line.split(" ")[arg];
}

function getNameArg(line) {
	var name = line.split(/\s(.+)/)[1];
	return name;
}
</script>

<script>
/* PITCH HELPER FUNCTIONS */
function pitchToSteps(pitch) {
	return (pitch.octave * Note.COUNT) + pitch.note;
}

function stepsToPitch(steps) {
	var pitch = { beats: 1, note: Note.C, octave: Octave[2], };

	while (steps >= Note.COUNT) {
		pitch.octave = (pitch.octave + 1) % Octave.COUNT;
		steps -= Note.COUNT;
	}

	pitch.note += steps;

	// make sure pitch isn't outside a valid range
	if (pitch.note <= Note.NONE) {
		pitch.note = Note.C;
	}
	else if (pitch.note >= Note.COUNT) {
		pitch.note = Note.B;
	}

	if (pitch.octave <= Octave.NONE) {
		pitch.octave = Octave[2];
	}
	else if (pitch.octave >= Octave.COUNT) {
		pitch.octave = Octave[5];
	}

	return pitch;
}

function adjustPitch(pitch, stepDelta) {
	return stepsToPitch(pitchToSteps(pitch) + stepDelta);
}

function pitchDistance(pitchA, pitchB) {
	return pitchToSteps(pitchB) - pitchToSteps(pitchA);
}

function isMinPitch(pitch) {
	return pitchToSteps(pitch) <= pitchToSteps({ note: Note.C, octave: Octave[2] });
}

function isMaxPitch(pitch) {
	return pitchToSteps(pitch) >= pitchToSteps({ note: Note.B, octave: Octave[5] });
}

function SoundPlayer() {
	// frequencies (in hertz) for octave 0 (or is it octave 4?)
	var frequencies = [
		261.7, // middle C
		277.2,
		293.7,
		311.2,
		329.7,
		349.3,
		370.0,
		392.0,
		415.3,
		440.0,
		466.2,
		493.9,
	];

	// tempos are calculated as the duration of a 16th note, rounded to the nearest millisecond
	var tempos = {};
	tempos[Tempo.SLW] = 250; // 60bpm (adagio)
	tempos[Tempo.MED] = 188; // ~80bpm (andante) [exact would be 187.5 ms]
	tempos[Tempo.FST] = 125; // 120bpm (moderato)
	tempos[Tempo.XFST] = 94; // ~160bpm (allegro) [exact would be 93.75 ms]

	// arpeggio patterns expressed in scale degrees
	var arpeggioPattern = {};
	arpeggioPattern[ArpeggioPattern.UP] = [0, 2, 4, 7];
	arpeggioPattern[ArpeggioPattern.DWN] = [7, 4, 2, 0];
	arpeggioPattern[ArpeggioPattern.INT5] = [0, 4];
	arpeggioPattern[ArpeggioPattern.INT8] = [0, 7];

	this.getArpeggioSteps = function(tune) { return arpeggioPattern[tune.arpeggioPattern]; };

	function isPitchPlayable(pitch, key) {
		if (pitch.beats <= 0) {
			return false;
		}

		if (key === undefined || key === null) {
			return true;
		}

		// test if note is in the scale
		return (key.scale.indexOf(pitch.note) > -1)
			&& (key.notes[pitch.note] > Note.NONE)
			&& (key.notes[pitch.note] < Note.COUNT);
	}

	function pitchToChromatic(pitch, key) {
		if (pitch === undefined || pitch === null) {
			return null;
		}

		if (key === undefined || key === null) {
			return pitch;
		}

		// convert from solfa
		var octaveOffset = (pitch.note >= Solfa.COUNT) ? 1 : 0;

		return {
			beats: pitch.beats,
			octave: pitch.octave + octaveOffset,
			// todo : what about the scale limits?
			note: key.notes[(pitch.note % Solfa.COUNT)],
			blip: pitch.blip
		};
	}

	function makePitchFrequency(pitch) {
		// todo : this clamp shouldn't be required.. there's a bug in the pitch shifting somewhere
		var note = Math.max(0, pitch.note);
		var octave = (pitch.octave != undefined ? pitch.octave : Octave[4]);

		var octaveMin = Octave[2];
		var octaveMax = Octave[5];

		// make sure octave is in valid range
		octave = Math.max(octaveMin, Math.min(octave, octaveMax));
		var distFromMiddleC = octave - 2;

		var freq = frequencies[note] * Math.pow(2, distFromMiddleC);

		if (isNaN(freq)) {
			bitsy.log("invalid frequency " + pitch, "sound");
		}

		return freq;
	}

	var maxVolume = 15; // todo : should this be a system constant?
	var noteVolume = 5;

	var curTune = null;
	var isTunePaused = false;
	var barIndex = -1;
	var curArpeggio = [];

	var beat16 = 0;
	var beat16Timer = 0;
	var beat16Index = 0;

	// special settings
	var isLooping = false;
	var isMelodyMuted = false;
	var maxBeatCount = null;
	var muteTimer = 0; // allow temporary muting of all notes

	function arpeggiateBar(bar, key, pattern) {
		var arpeggio = [];

		if (key != undefined && key != null && isPitchPlayable(bar[0], key)) {
			for (var i = 0; i < arpeggioPattern[pattern].length; i++) {
				var pitch = { beats: 1, note: bar[0].note + arpeggioPattern[pattern][i], octave: bar[0].octave };
				arpeggio.push(pitchToChromatic(pitch, key));
			}
		}

		for (var i = 0; i < arpeggio.length; i++) {
			bitsy.log(i + ": " + serializeNote(arpeggio[i].note));
		}

		return arpeggio;
	};

	function playNote(pitch, instrument, options) {
		if (pitch.beats <= 0) {
			return;
		}

		var channel = bitsy.SOUND1;
		if (options != undefined && options.channel != undefined) {
			channel = options.channel;
		}

		var key = null;
		if (options != undefined && options.key != undefined) {
			key = options.key;
		}

		var beatLen = beat16;
		if (options != undefined && options.beatLen != undefined) {
			beatLen = options.beatLen;
		}

		if (isPitchPlayable(pitch, key)) {
			var freq = makePitchFrequency(pitchToChromatic(pitch, key));
			bitsy.sound(channel, (pitch.beats * beatLen), freq * 100, noteVolume, instrument);
		}
	}

	function sfxFrequencyAtTime(sfx, time) {
		var beatDelay = sfx.blip.beat.delay;
		var beatTime = sfx.blip.beat.time;
		var delta = Math.max(0, time - beatDelay) / beatTime;

		var pitchDelta = sfx.blip.doRepeat
			? (delta % sfx.frequencies.length)
			: Math.min(delta, sfx.frequencies.length - 1);

		sfx.pitchIndex = Math.floor(pitchDelta);
		var curFreq = sfx.frequencies[sfx.pitchIndex];

		// TODO : consider for future update
		// if (sfx.blip.doSlide) {
		// 	var nextPitchIndex = (sfx.pitchIndex + 1) % sfx.frequencies.length;
		// 	var nextFreq = sfx.frequencies[nextPitchIndex];
		// 	var d = pitchDelta - sfx.pitchIndex;
		// 	curFreq = curFreq + ((nextFreq - curFreq) * d);
		// }

		return curFreq;
	}

	function sfxVolumeAtTime(sfx, time) {
		var volume = 0;

		// use envelope settings to calculate volume
		var attack = sfx.blip.envelope.attack;
		var decay = sfx.blip.envelope.decay;
		var length = sfx.blip.envelope.length;
		var release = sfx.blip.envelope.release;
		if (time < attack) {
			// attack
			var t = time / attack;
			volume = Math.floor(sfxPeakVolume * t);
		}
		else if (time < attack + decay) {
			// decay
			var t = (time - attack) / decay;
			var d = sfx.blip.envelope.sustain - sfxPeakVolume;
			volume = Math.floor(sfxPeakVolume + (d * t));
		}
		else if (time < attack + decay + length) {
			// sustain
			volume = sfx.blip.envelope.sustain;
		}
		else if (time < attack + decay + length + release) {
			// release
			var t = (time - (attack + decay + length)) / release;
			volume = Math.floor(sfx.blip.envelope.sustain * (1 - t));
		}
		else {
			volume = 0;
		}

		return volume;
	}

	function updateSfx(dt) {
		// try limiting the max change per frame
		dt = Math.min(dt, 32);
		var isAnyBlipPlaying = false;

		if (activeSfx != null) {
			isAnyBlipPlaying = true;
			var sfx = activeSfx;

			sfx.timer += dt;
			if (sfx.timer >= sfx.duration) {
				sfx.timer = sfx.duration;
			}

			if (sfx.frequencies.length > 0) {
				// update pitch
				var prevPitchIndex = sfx.pitchIndex;
				var freq = sfxFrequencyAtTime(sfx, sfx.timer);
				if (prevPitchIndex != sfx.pitchIndex) {
					// pitch changed!
					bitsy.frequency(bitsy.SOUND1, freq * 100);
				}

				// update volume envelope
				bitsy.volume(bitsy.SOUND1, sfxVolumeAtTime(sfx, sfx.timer));
			}

			if (sfx.timer >= sfx.duration) {
				// turn off sound
				bitsy.volume(bitsy.SOUND1, 0);
				activeSfx = null;
			}
		}

		if (isMusicPausedForBlip && !isAnyBlipPlaying) {
			isMusicPausedForBlip = false;
		}
	}

	function updateTune(dt) {
		if (curTune === undefined || curTune === null) {
			return;
		}

		beat16Timer += dt;

		if (muteTimer > 0) {
			muteTimer -= dt;
		}

		if (beat16Timer >= beat16) {
			beat16Timer = 0;
			beat16Index++;

			if (beat16Index >= 16) {
				beat16Index = 0;

				if (!isLooping) {
					barIndex = (barIndex + 1) % curTune.melody.length;

					if (curTune.arpeggioPattern != ArpeggioPattern.OFF && curTune.key != null) {
						curArpeggio = arpeggiateBar(curTune.harmony[barIndex], curTune.key, curTune.arpeggioPattern);
					}
				}
			}

			if (muteTimer <= 0) {
				if (!isMelodyMuted) {
					// melody note
					var pitchA = curTune.melody[barIndex][beat16Index];
					if (pitchA.beats > 0) {
						// since they're played on the same channel, any melody note will cancel a blip
						activeSfx = null;
					}

					if (pitchA.blip != undefined && pitchA.beats > 0) {
						playBlip(blip[pitchA.blip], { interruptMusic: false, pitch: pitchA, key: curTune.key });
					}
					else {
						playNote(pitchA, curTune.instrumentA, { channel: bitsy.SOUND1, key: curTune.key });
					}
				}

				if (curTune.arpeggioPattern === ArpeggioPattern.OFF) {
					// harmony note
					var pitchB = curTune.harmony[barIndex][beat16Index];
					if (pitchB.blip != undefined && pitchB.beats > 0) {
						playBlip(blip[pitchB.blip], { interruptMusic: false, pitch: pitchB, key: curTune.key });
					}
					else {
						playNote(pitchB, curTune.instrumentB, { channel: bitsy.SOUND2, key: curTune.key });
					}
				}
				else {
					var arpPitch = curArpeggio[beat16Index % curArpeggio.length];
					if (arpPitch != undefined && arpPitch.beats > 0) {
						playNote(arpPitch, curTune.instrumentB, { channel: bitsy.SOUND2, beatLen: beat16 });
					}
				}
			}

			if (maxBeatCount != null && beat16Index >= (maxBeatCount - 1)) {
				// stop playback early
				curTune = null;
			}
		}
	}

	this.update = function(dt) {
		updateSfx(dt);
		if (!isTunePaused && !isMusicPausedForBlip) {
			updateTune(dt);
		}
	};

	this.playTune = function(tune, options) {
		curTune = tune;
		beat16Timer = 0;
		beat16Index = -1;
		barIndex = 0;

		isLooping = false;
		isMelodyMuted = false;
		maxBeatCount = null;

		// special options for the editor
		if (options != undefined) {
			if (options.barIndex != undefined) {
				barIndex = options.barIndex;
			}

			if (options.loop != undefined) {
				isLooping = options.loop;
			}

			if (options.melody != undefined) {
				isMelodyMuted = !options.melody;
			}

			if (options.beatCount != undefined) {
				maxBeatCount = options.beatCount;
			}
		}

		// update tempo
		beat16 = tempos[curTune.tempo];

		if (curTune.arpeggioPattern != ArpeggioPattern.OFF && curTune.key != null) {
			curArpeggio = arpeggiateBar(curTune.harmony[barIndex], curTune.key, curTune.arpeggioPattern);
		}
	};

	this.isTunePlaying = function() {
		return curTune != null;
	};

	this.getCurTuneId = function() {
		if (curTune) {
			return curTune.id;
		}

		return null;
	};

	this.stopTune = function() {
		curTune = null;
	};

	this.pauseTune = function() {
		isTunePaused = true;
	};

	this.resumeTune = function() {
		isTunePaused = false;
	};

	this.getBeat = function() {
		if (curTune == null) {
			return null;
		}

		return {
			bar : barIndex,
			beat : beat16Index,
		};
	};

	this.getBlipState = function() {
		return activeSfx;
	};

	this.playNote = function(pitch, instrument, channel, key) {
		beat16 = tempos[Tempo.SLW];
		muteTimer = beat16;
		playNote(pitch, instrument, { channel: channel, key: key });
	};

	this.setTempo = function(tempo) {
		beat16 = tempos[tempo];
	};

	this.setLooping = function(looping) {
		isLooping = looping;
	};

	/* SOUND EFFECTS */
	var sfxPeakVolume = 10; // todo : is this a good value?
	var activeSfx = null;
	var isMusicPausedForBlip = false;

	function createSfxState(blip, pitch, isPitchRandomized) {
		// bitsy.log("init sfx blip: " + blip.id);

		var sfxState = {
			blip : blip,
			pitchIndex : -1,
			frequencies : [],
			timer : 0,
			duration : 0,
		};

		// is it weird to track this both in the system *AND* the engine?
		sfxState.duration = (blip.envelope.attack + blip.envelope.decay + blip.envelope.length + blip.envelope.release);

		// adjust starting pitch
		var step = 0;
		if (pitch != null) {
			step = pitchDistance(blip.pitchA, pitch);
		}
		else if (isPitchRandomized > 0) {
			step = Math.floor(Math.random() * 6);
		}

		if (blip.pitchA.beats > 0) {
			sfxState.frequencies.push(makePitchFrequency(adjustPitch(blip.pitchA, step)));
		}
		if (blip.pitchB.beats > 0) {
			sfxState.frequencies.push(makePitchFrequency(adjustPitch(blip.pitchB, step)));
		}
		if (blip.pitchC.beats > 0) {
			sfxState.frequencies.push(makePitchFrequency(adjustPitch(blip.pitchC, step)));
		}

		return sfxState;
	}

	function playBlip(blip, options) {
		// default to pausing music while the blip plays (except when playing a blip as *part* of music)
		isMusicPausedForBlip = (options === undefined || options.interruptMusic === undefined) ? true : options.interruptMusic;

		// always play blips on channel 1
		var channel = bitsy.SOUND1;

		// other options
		var pitch = (options === undefined || options.pitch === undefined) ? null : options.pitch;
		var isPitchRandomized = (options === undefined || options.isPitchRandomized === undefined) ? false : options.isPitchRandomized;
		var key = (options != undefined && options.key != undefined) ? options.key : null;

		activeSfx = createSfxState(blip, pitchToChromatic(pitch, key), isPitchRandomized);
		bitsy.log("play blip: " + activeSfx.frequencies);

		bitsy.sound(
			channel,
			activeSfx.duration * 10, // HACK : mult by 10 is to avoid accidentally turning off early
			activeSfx.frequencies.length > 0 ? (activeSfx.frequencies[0] * 100) : 0,
			0, // volume
			activeSfx.blip.instrument);
	};

	this.playBlip = playBlip;

	this.isBlipPlaying = function() {
		return isMusicPausedForBlip; // todo : rename this variable?
	};

	// todo : should any of this stuff be moved into the tool code?
	this.sampleBlip = function(blip, sampleCount) {
		var sfx = createSfxState(blip, null, false);

		var minFreq = makePitchFrequency({ note: Note.C, octave: Octave[2] });
		var maxFreq = makePitchFrequency({ note: Note.B, octave: Octave[5] });

		// sample the frequency of the sound
		var frequencySamples = [];
		for (var i = 0; i < sampleCount; i++) {
			if (sfx.frequencies.length > 0) {
				var t = Math.floor((i / sampleCount) * sfx.duration);
				// get frequency at time
				var freq = sfxFrequencyAtTime(sfx, t);
				// normalize the sample
				freq = freq / (maxFreq - minFreq);

				frequencySamples.push(freq);
			}
			else {
				frequencySamples.push(0);
			}
		}

		// sample the volume envelope
		var amplitudeSamples = [];
		for (var i = 0; i < sampleCount; i++) {
			var t = Math.floor((i / sampleCount) * sfx.duration);
			amplitudeSamples.push(sfxVolumeAtTime(sfx, t) / maxVolume);
		}

		return {
			frequencies: frequencySamples,
			amplitudes: amplitudeSamples
		};
	};
}
</script>

<script>
/*
TODO:
- can I simplify this more now that I've removed the external resources stuff?
*/

function FontManager(packagedFontNames) {

var self = this;

var fontExtension = ".bitsyfont";
this.GetExtension = function() {
	return fontExtension;
}

// place to store font data
var fontResources = {};

// load fonts from the editor
if (packagedFontNames != undefined && packagedFontNames != null && packagedFontNames.length > 0
		&& Resources != undefined && Resources != null) {

	for (var i = 0; i < packagedFontNames.length; i++) {
		var filename = packagedFontNames[i];
		fontResources[filename] = Resources[filename];
	}
}

// manually add resource
this.AddResource = function(filename, fontdata) {
	fontResources[filename] = fontdata;
}

this.ContainsResource = function(filename) {
	return fontResources[filename] != null;
}

function GetData(fontName) {
	return fontResources[fontName + fontExtension];
}
this.GetData = GetData;

function Create(fontData) {
	return new Font(fontData);
}
this.Create = Create;

this.Get = function(fontName) {
	var fontData = self.GetData(fontName);
	return self.Create(fontData);
}

function Font(fontData) {
	bitsy.log("create font");

	var name = "unknown";
	var width = 6; // default size so if you have NO font or an invalid font it displays boxes
	var height = 8;
	var chardata = {};

	// create invalid char data at default size in case the font is missing
	var invalidCharData = {};
	updateInvalidCharData();

	this.getName = function() {
		return name;
	}

	this.getData = function() {
		return chardata;
	}

	this.getWidth = function() {
		return width;
	}

	this.getHeight = function() {
		return height;
	}

	this.hasChar = function(char) {
		var codepoint = char.charCodeAt(0);
		return chardata[codepoint] != null;
	}

	this.getChar = function(char) {

		var codepoint = char.charCodeAt(0);

		if (chardata[codepoint] != null) {
			return chardata[codepoint];
		}
		else {
			return invalidCharData;
		}
	}

	this.allCharCodes = function() {
		var codeList = [];
		for (var code in chardata) {
			codeList.push(code);
		}
		return codeList;
	}

	function createCharData() {
		return { 
			width: width,
			height: height,
			offset: {
				x: 0,
				y: 0
			},
			spacing: width,
			data: [],
		};
	}

	function updateInvalidCharData() {
		invalidCharData = createCharData();
		for (var y = 0; y < height; y++) {
			for (var x = 0; x < width; x++) {
				if (x < width-1 && y < height-1) {
					invalidCharData.data.push(1);
				}
				else {
					invalidCharData.data.push(0);
				}
			}
		}
	}

	function parseFont(fontData) {
		if (fontData == null) {
			return;
		}

		bitsy.log("split font lines");
		// NOTE: this is where we run out of memory - split creates a lot of memory issues
		// var lines = fontData.split("\n");
		bitsy.log("after split lines");

		var isReadingChar = false;
		var isReadingCharProperties = false;
		var curCharLineCount = 0;
		var curCharCode = 0;

		var lineStart = 0;
		var lineEnd = fontData.indexOf("\n", lineStart) != -1
			? fontData.indexOf("\n", lineStart)
			: fontData.length;

		// for (var i = 0; i < lines.length; i++) {
		// 	var line = lines[i];
		while (lineStart < fontData.length) {
			var line = fontData.substring(lineStart, lineEnd);
			// bitsy.log("parse font xx " + line);

			if (line[0] === "#") {
				// skip comment lines
			}
			else if (!isReadingChar) {
				// READING NON CHARACTER DATA LINE
				var args = line.split(" ");
				if (args[0] == "FONT") {
					name = args[1];
				}
				else if (args[0] == "SIZE") {
					width = parseInt(args[1]);
					height = parseInt(args[2]);
				}
				else if (args[0] == "CHAR") {
					isReadingChar = true;
					isReadingCharProperties = true;

					curCharLineCount = 0;
					curCharCode = parseInt(args[1]);
					chardata[curCharCode] = createCharData();
				}
			}
			else {
				// CHAR PROPERTIES
				if (isReadingCharProperties) {
					var args = line.split(" ");
					if (args[0].indexOf("CHAR_") == 0) { // Sub-properties start with "CHAR_"
						if (args[0] == "CHAR_SIZE") {
							// Custom character size - overrides the default character size for the font
							chardata[curCharCode].width = parseInt(args[1]);
							chardata[curCharCode].height = parseInt(args[2]);
							chardata[curCharCode].spacing = parseInt(args[1]); // HACK : assumes CHAR_SIZE is always declared first
						}
						else if (args[0] == "CHAR_OFFSET") {
							// Character offset - shift the origin of the character on the X or Y axis
							chardata[curCharCode].offset.x = parseInt(args[1]);
							chardata[curCharCode].offset.y = parseInt(args[2]);
						}
						else if (args[0] == "CHAR_SPACING") {
							// Character spacing:
							// specify total horizontal space taken up by the character
							// lets chars take up more or less space on a line than its bitmap does
							chardata[curCharCode].spacing = parseInt(args[1]);
						}
					}
					else {
						isReadingCharProperties = false;
					}
				}

				// CHAR DATA
				if (!isReadingCharProperties) {
					// READING CHARACTER DATA LINE
					for (var j = 0; j < chardata[curCharCode].width; j++)
					{
						chardata[curCharCode].data.push( parseInt(line[j]) );
					}

					curCharLineCount++;
					if (curCharLineCount >= chardata[curCharCode].height) {
						isReadingChar = false;
					}
				}
			}

			lineStart = lineEnd + 1;
			lineEnd = fontData.indexOf("\n", lineStart) != -1
				? fontData.indexOf("\n", lineStart)
				: fontData.length;
		}

		// re-init invalid character box at the actual font size once it's loaded
		updateInvalidCharData();
	}

	bitsy.log("parse font");
	parseFont(fontData);

	bitsy.log("create font");
}

} // FontManager

</script>

<script>
var TransitionManager = function() {
	var transitionStart = null;
	var transitionEnd = null;

	var isTransitioning = false;
	var transitionTime = 0; // milliseconds
	var minStepTime = 125; // cap the frame rate
	var curStep = 0;

	this.BeginTransition = function(startRoom, startX, startY, endRoom, endX, endY, effectName) {
		bitsy.log("--- START ROOM TRANSITION ---");

		curEffect = effectName;

		var tmpRoom = player().room;
		var tmpX = player().x;
		var tmpY = player().y;

		if (transitionEffects[curEffect].showPlayerStart) {
			player().room = startRoom;
			player().x = startX;
			player().y = startY;
		}
		else {
			player().room = "_transition_none"; // kind of hacky!!
		}

		var startRoomPixels = createRoomPixelBuffer(room[startRoom]);
		var startPalette = getPal(room[startRoom].pal);
		var startImage = new PostProcessImage(startRoomPixels);
		transitionStart = new TransitionInfo(startImage, startPalette, startX, startY);

		if (transitionEffects[curEffect].showPlayerEnd) {
			player().room = endRoom;
			player().x = endX;
			player().y = endY;
		}
		else {
			player().room = "_transition_none";
		}

		var endRoomPixels = createRoomPixelBuffer(room[endRoom]);
		var endPalette = getPal(room[endRoom].pal);
		var endImage = new PostProcessImage(endRoomPixels);
		transitionEnd = new TransitionInfo(endImage, endPalette, endX, endY);

		isTransitioning = true;
		transitionTime = 0;
		curStep = 0;

		player().room = endRoom;
		player().x = endX;
		player().y = endY;

		bitsy.graphicsMode(bitsy.GFX_VIDEO);
	}

	this.UpdateTransition = function(dt) {
		if (!isTransitioning) {
			return;
		}

		transitionTime += dt;

		var maxStep = transitionEffects[curEffect].stepCount;

		if (transitionTime >= minStepTime) {
			curStep++;

			var step = curStep;
			bitsy.log("transition step " + step);

			if (transitionEffects[curEffect].paletteEffectFunc) {
				var colors = transitionEffects[curEffect].paletteEffectFunc(transitionStart, transitionEnd, (step / maxStep));
				updatePaletteWithTileColors(colors);
			}

			bitsy.fill(bitsy.VIDEO, tileColorStartIndex);

			for (var y = 0; y < bitsy.VIDEO_SIZE; y++) {
				for (var x = 0; x < bitsy.VIDEO_SIZE; x++) {
					var color = transitionEffects[curEffect].pixelEffectFunc(transitionStart, transitionEnd, x, y, (step / maxStep));
					bitsy.set(bitsy.VIDEO, (y * bitsy.VIDEO_SIZE) + x, color);
				}
			}

			transitionTime = 0;
		}

		if (curStep >= (maxStep - 1)) {
			isTransitioning = false;
			transitionTime = 0;
			transitionStart = null;
			transitionEnd = null;
			curStep = 0;

			if (transitionCompleteCallback != null) {
				transitionCompleteCallback();
			}
			transitionCompleteCallback = null;

			bitsy.graphicsMode(bitsy.GFX_MAP);
		}
	}

	this.IsTransitionActive = function() {
		return isTransitioning;
	}

	// todo : should this be part of the constructor?
	var transitionCompleteCallback = null;
	this.OnTransitionComplete = function(callback) {
		if (isTransitioning) { // TODO : safety check necessary?
			transitionCompleteCallback = callback;
		}
	}

	var transitionEffects = {};
	var curEffect = "none";
	this.RegisterTransitionEffect = function(name, effect) {
		transitionEffects[name] = effect;
	}

	this.RegisterTransitionEffect("none", {
		showPlayerStart : false,
		showPlayerEnd : false,
		paletteEffectFunc : function() {},
		pixelEffectFunc : function() {},
	});

	this.RegisterTransitionEffect("fade_w", { // TODO : have it linger on full white briefly?
		showPlayerStart : false,
		showPlayerEnd : true,
		stepCount : 6,
		pixelEffectFunc : function(start, end, pixelX, pixelY, delta) {
			return delta < 0.5 ? start.Image.GetPixel(pixelX, pixelY) : end.Image.GetPixel(pixelX, pixelY);
		},
		paletteEffectFunc : function(start, end, delta) {
			var colors = [];

			if (delta < 0.5) {
				delta = delta / 0.5;

				for (var i = 0; i < start.Palette.length; i++) {
					colors.push(lerpColor(start.Palette[i], [255, 255, 255], delta));
				}
			}
			else {
				delta = ((delta - 0.5) / 0.5);

				for (var i = 0; i < end.Palette.length; i++) {
					colors.push(lerpColor([255, 255, 255], end.Palette[i], delta));
				}
			}

			return colors;
		},
	});

	this.RegisterTransitionEffect("fade_b", {
		showPlayerStart : false,
		showPlayerEnd : true,
		stepCount : 6,
		pixelEffectFunc : function(start, end, pixelX, pixelY, delta) {
			return delta < 0.5 ? start.Image.GetPixel(pixelX, pixelY) : end.Image.GetPixel(pixelX, pixelY);
		},
		paletteEffectFunc : function(start, end, delta) {
			var colors = [];

			if (delta < 0.5) {
				delta = delta / 0.5;

				for (var i = 0; i < start.Palette.length; i++) {
					colors.push(lerpColor(start.Palette[i], [0, 0, 0], delta));
				}
			}
			else {
				delta = ((delta - 0.5) / 0.5);

				for (var i = 0; i < end.Palette.length; i++) {
					colors.push(lerpColor([0, 0, 0], end.Palette[i], delta));
				}
			}

			return colors;
		},
	});

	this.RegisterTransitionEffect("wave", {
		showPlayerStart : true,
		showPlayerEnd : true,
		stepCount : 12,
		pixelEffectFunc : function(start, end, pixelX, pixelY, delta) {
			var waveDelta = delta < 0.5 ? delta / 0.5 : 1 - ((delta - 0.5) / 0.5);

			var offset = (pixelY + (waveDelta * waveDelta * 0.2 * start.Image.Height));
			var freq = 4;
			var size = 2 + (14 * waveDelta);
			pixelX += Math.floor(Math.sin(offset / freq) * size);

			if (pixelX < 0) {
				pixelX += start.Image.Width;
			}
			else if (pixelX >= start.Image.Width) {
				pixelX -= start.Image.Width;
			}

			var curImage = delta < 0.5 ? start.Image : end.Image;
			return curImage.GetPixel(pixelX, pixelY);
		},
		paletteEffectFunc : function(start, end, delta) {
			return delta < 0.5 ? start.Palette : end.Palette;
		},
	});

	this.RegisterTransitionEffect("tunnel", {
		showPlayerStart : true,
		showPlayerEnd : true,
		stepCount : 12,
		pixelEffectFunc : function(start, end, pixelX, pixelY, delta) {
			if (delta <= 0.4) {
				var tunnelDelta = 1 - (delta / 0.4);

				var xDist = start.PlayerCenter.x - pixelX;
				var yDist = start.PlayerCenter.y - pixelY;
				var dist = Math.sqrt((xDist * xDist) + (yDist * yDist));

				if (dist > start.Image.Width * tunnelDelta) {
					return 0;
				}
				else {
					return start.Image.GetPixel(pixelX, pixelY);
				}
			}
			else if (delta <= 0.6) {
				return 0;
			}
			else {
				var tunnelDelta = (delta - 0.6) / 0.4;

				var xDist = end.PlayerCenter.x - pixelX;
				var yDist = end.PlayerCenter.y - pixelY;
				var dist = Math.sqrt((xDist * xDist) + (yDist * yDist));

				if (dist > end.Image.Width * tunnelDelta) {
					return 0;
				}
				else {
					return end.Image.GetPixel(pixelX, pixelY);
				}
			}
		},
		paletteEffectFunc : function(start, end, delta) {
			return delta < 0.5 ? start.Palette : end.Palette;
		},
	});

	function lerpPalettes(start, end, delta) {
		var colors = [];

		var maxLength = (start.Palette.length > end.Palette.length) ?
			start.Palette.length : end.Palette.length;

		for (var i = 0; i < maxLength; i++) {
			if (i < start.Palette.length && i < end.Palette.length) {
				colors.push(lerpColor(start.Palette[i], end.Palette[i], delta));
			}
			else if (i < start.Palette.length) {
				colors.push(lerpColor(
					start.Palette[i],
					end.Palette[end.Palette.length - 1],
					delta));
			}
			else if (i < end.Palette.length) {
				colors.push(lerpColor(
					start.Palette[start.Palette.length - 1],
					end.Palette[i],
					delta));
			}
		}

		return colors;
	}

	this.RegisterTransitionEffect("slide_u", {
		showPlayerStart : false,
		showPlayerEnd : true,
		stepCount : 8,
		pixelEffectFunc : function(start, end, pixelX, pixelY, delta) {
			var pixelOffset = -1 * Math.floor(start.Image.Height * delta);
			var slidePixelY = pixelY + pixelOffset;

			if (slidePixelY >= 0) {
				return start.Image.GetPixel(pixelX, slidePixelY);
			}
			else {
				slidePixelY += start.Image.Height;
				return end.Image.GetPixel(pixelX, slidePixelY);
			}
		},
		paletteEffectFunc : lerpPalettes,
	});

	this.RegisterTransitionEffect("slide_d", {
		showPlayerStart : false,
		showPlayerEnd : true,
		stepCount : 8,
		pixelEffectFunc : function(start, end, pixelX, pixelY, delta) {
			var pixelOffset = Math.floor(start.Image.Height * delta);
			var slidePixelY = pixelY + pixelOffset;

			if (slidePixelY < start.Image.Height) {
				return start.Image.GetPixel(pixelX, slidePixelY);
			}
			else {
				slidePixelY -= start.Image.Height;
				return end.Image.GetPixel(pixelX, slidePixelY);
			}
		},
		paletteEffectFunc : lerpPalettes,
	});

	this.RegisterTransitionEffect("slide_l", {
		showPlayerStart : false,
		showPlayerEnd : true,
		stepCount : 8,
		pixelEffectFunc : function(start, end, pixelX, pixelY, delta) {
			var pixelOffset = -1 * Math.floor(start.Image.Width * delta);
			var slidePixelX = pixelX + pixelOffset;

			if (slidePixelX >= 0) {
				return start.Image.GetPixel(slidePixelX, pixelY);
			}
			else {
				slidePixelX += start.Image.Width;
				return end.Image.GetPixel(slidePixelX, pixelY);
			}
		},
		paletteEffectFunc : lerpPalettes,
	});

	this.RegisterTransitionEffect("slide_r", {
		showPlayerStart : false,
		showPlayerEnd : true,
		stepCount : 8,
		pixelEffectFunc : function(start, end, pixelX, pixelY, delta) {
			var pixelOffset = Math.floor(start.Image.Width * delta);
			var slidePixelX = pixelX + pixelOffset;

			if (slidePixelX < start.Image.Width) {
				return start.Image.GetPixel(slidePixelX, pixelY);
			}
			else {
				slidePixelX -= start.Image.Width;
				return end.Image.GetPixel(slidePixelX, pixelY);
			}
		},
		paletteEffectFunc : lerpPalettes,
	});

	// todo : move to Renderer()?
	function createRoomPixelBuffer(room) {
		var pixelBuffer = [];

		for (var i = 0; i < bitsy.VIDEO_SIZE * bitsy.VIDEO_SIZE; i++) {
			pixelBuffer.push(tileColorStartIndex);
		}

		var drawTileInPixelBuffer = function(sourceData, frameIndex, colorIndex, tx, ty, pixelBuffer) {
			var frameData = sourceData[frameIndex];

			for (var y = 0; y < bitsy.TILE_SIZE; y++) {
				for (var x = 0; x < bitsy.TILE_SIZE; x++) {
					var color = tileColorStartIndex + (frameData[y][x] === 1 ? colorIndex : 0);
					pixelBuffer[(((ty * bitsy.TILE_SIZE) + y) * bitsy.VIDEO_SIZE) + ((tx * bitsy.TILE_SIZE) + x)] = color;
				}
			}
		}

		//draw tiles
		for (i in room.tilemap) {
			for (j in room.tilemap[i]) {
				var id = room.tilemap[i][j];
				var x = parseInt(j);
				var y = parseInt(i);

				if (id != "0" && tile[id] != null) {
					drawTileInPixelBuffer(
						renderer.GetDrawingSource(tile[id].drw),
						tile[id].animation.frameIndex,
						tile[id].col,
						x,
						y,
						pixelBuffer);
				}
			}
		}

		//draw items
		for (var i = 0; i < room.items.length; i++) {
			var itm = room.items[i];
			drawTileInPixelBuffer(
				renderer.GetDrawingSource(item[itm.id].drw),
				item[itm.id].animation.frameIndex,
				item[itm.id].col,
				itm.x,
				itm.y,
				pixelBuffer);
		}

		//draw sprites
		for (id in sprite) {
			var spr = sprite[id];
			if (spr.room === room.id) {
				drawTileInPixelBuffer(
					renderer.GetDrawingSource(spr.drw),
					spr.animation.frameIndex,
					spr.col,
					spr.x,
					spr.y,
					pixelBuffer);
			}
		}

		return pixelBuffer;
	}

	function lerpColor(colorA, colorB, t) {
		return [
			colorA[0] + ((colorB[0] - colorA[0]) * t),
			colorA[1] + ((colorB[1] - colorA[1]) * t),
			colorA[2] + ((colorB[2] - colorA[2]) * t),
		];
	};
}; // TransitionManager()

// todo : is this wrapper still useful?
var PostProcessImage = function(imageData) {
	this.Width = bitsy.VIDEO_SIZE;
	this.Height = bitsy.VIDEO_SIZE;

	this.GetPixel = function(x, y) {
		return imageData[(y * bitsy.VIDEO_SIZE) + x];
	};

	this.GetData = function() {
		return imageData;
	};
};

var TransitionInfo = function(image, palette, playerX, playerY) {
	this.Image = image;

	this.Palette = palette;

	this.PlayerTilePos = {
		x: playerX,
		y: playerY
	};

	this.PlayerCenter = {
		x: Math.floor((playerX * bitsy.TILE_SIZE) + (bitsy.TILE_SIZE / 2)),
		y: Math.floor((playerY * bitsy.TILE_SIZE) + (bitsy.TILE_SIZE / 2))
	};
};
</script>

<script>
function Script() {

this.CreateInterpreter = function() {
	return new Interpreter();
};

this.CreateUtils = function() {
	return new Utils();
};

var Interpreter = function() {
	var env = new Environment();
	var parser = new Parser( env );

	this.SetDialogBuffer = function(buffer) { env.SetDialogBuffer( buffer ); };

	// TODO -- maybe this should return a string instead othe actual script??
	this.Compile = function(scriptName, scriptStr) {
		var script = parser.Parse(scriptStr, scriptName);
		env.SetScript(scriptName, script);
	}
	this.Run = function(scriptName, exitHandler, objectContext) { // Runs pre-compiled script
		var localEnv = new LocalEnvironment(env);

		if (objectContext) {
			localEnv.SetObject(objectContext); // PROTO : should this be folded into the constructor?
		}

		var script = env.GetScript(scriptName);

		script.Eval( localEnv, function(result) { OnScriptReturn(localEnv, exitHandler); } );
	}
	this.Interpret = function(scriptStr, exitHandler, objectContext) { // Compiles and runs code immediately
		// bitsy.log("INTERPRET");
		var localEnv = new LocalEnvironment(env);

		if (objectContext) {
			localEnv.SetObject(objectContext); // PROTO : should this be folded into the constructor?
		}

		var script = parser.Parse(scriptStr, "anonymous");
		script.Eval( localEnv, function(result) { OnScriptReturn(localEnv, exitHandler); } );
	}
	this.HasScript = function(name) { return env.HasScript(name); };

	this.ResetEnvironment = function() {
		env = new Environment();
		parser = new Parser( env );
	}

	this.Parse = function(scriptStr, rootId) { // parses a script but doesn't save it
		return parser.Parse(scriptStr, rootId);
	}

	this.Eval = function(scriptTree, exitHandler) { // runs a script stored externally
		var localEnv = new LocalEnvironment(env); // TODO : does this need an object context?
		scriptTree.Eval(
			localEnv,
			function(result) {
				OnScriptReturn(result, exitHandler);
			});
	}

	function OnScriptReturn(result, exitHandler) {
		if (exitHandler != null) {
			exitHandler(result);
		}
	}

	this.CreateExpression = function(expStr) {
		return parser.CreateExpression(expStr);
	}

	this.SetVariable = function(name,value,useHandler) {
		env.SetVariable(name,value,useHandler);
	}

	this.DeleteVariable = function(name,useHandler) {
		env.DeleteVariable(name,useHandler);
	}
	this.HasVariable = function(name) {
		return env.HasVariable(name);
	}

	this.SetOnVariableChangeHandler = function(onVariableChange) {
		env.SetOnVariableChangeHandler(onVariableChange);
	}
	this.GetVariableNames = function() {
		return env.GetVariableNames();
	}
	this.GetVariable = function(name) {
		return env.GetVariable(name);
	}

	function DebugVisualizeScriptTree(scriptTree) {
		var printVisitor = {
			Visit : function(node,depth) {
				bitsy.log("-".repeat(depth) + "- " + node.ToString());
			},
		};

		scriptTree.VisitAll( printVisitor );
	}

	this.DebugVisualizeScriptTree = DebugVisualizeScriptTree;

	this.DebugVisualizeScript = function(scriptName) {
		DebugVisualizeScriptTree(env.GetScript(scriptName));
	}
}


var Utils = function() {
	// for editor ui
	this.CreateDialogBlock = function(children,doIndentFirstLine) {
		if (doIndentFirstLine === undefined) {
			doIndentFirstLine = true;
		}

		var block = new DialogBlockNode(doIndentFirstLine);

		for (var i = 0; i < children.length; i++) {
			block.AddChild(children[i]);
		}
		return block;
	}

	this.CreateOptionBlock = function() {
		var block = new DialogBlockNode(false);
		block.AddChild(new FuncNode("say", [new LiteralNode(" ")]));
		return block;
	}

	this.CreateItemConditionPair = function() {
		var itemFunc = this.CreateFunctionBlock("item", ["0"]);
		var condition = new ExpNode("==", itemFunc, new LiteralNode(1));
		var result = new DialogBlockNode(true);
		result.AddChild(new FuncNode("say", [new LiteralNode(" ")]));
		var conditionPair = new ConditionPairNode(condition, result);
		return conditionPair;
	}

	this.CreateVariableConditionPair = function() {
		var varNode = this.CreateVariableNode("a");
		var condition = new ExpNode("==", varNode, new LiteralNode(1));
		var result = new DialogBlockNode(true);
		result.AddChild(new FuncNode("say", [new LiteralNode(" ")]));
		var conditionPair = new ConditionPairNode(condition, result);
		return conditionPair;
	}

	this.CreateDefaultConditionPair = function() {
		var condition = this.CreateElseNode();
		var result = new DialogBlockNode(true);
		result.AddChild(new FuncNode("say", [new LiteralNode(" ")]));
		var conditionPair = new ConditionPairNode(condition, result);
		return conditionPair;
	}

	this.CreateEmptySayFunc = function() {
		return new FuncNode("say", [new LiteralNode("...")]);
	}

	this.CreateFunctionBlock = function(name, initParamValues) {
		var parameters = [];
		for (var i = 0; i < initParamValues.length; i++) {
			parameters.push(new LiteralNode(initParamValues[i]));
		}

		var node = new FuncNode(name, parameters);
		var block = new CodeBlockNode();
		block.AddChild(node);
		return block;
	}

	// TODO : rename ParseStringToLiteralNode?
	this.CreateLiteralNode = function(str) {
		if (str === "true") {
			return new LiteralNode(true);
		}
		else if (str === "false") {
			return new LiteralNode(false);
		}
		else if (!isNaN(parseFloat(str))) {
			return new LiteralNode(parseFloat(str));
		}
		else {
			return new LiteralNode(str);
		}
	}

	this.CreateVariableNode = function(variableName) {
		return new VarNode(variableName);
	}

	this.CreatePropertyNode = function(propertyName, literalValue) {
		var varNode = new VarNode(propertyName);
		var valNode = new LiteralNode(literalValue);
		var node = new FuncNode("property", [varNode, valNode]);
		var block = new CodeBlockNode();
		block.AddChild(node);
		return block;
	}

	this.CreateElseNode = function() {
		return new ElseNode();
	}

	this.CreateStringLiteralNode = function(str) {
		return new LiteralNode(str);
	}

	// TODO : need to split up code & dialog blocks :|
	this.CreateCodeBlock = function() {
		return new CodeBlockNode();
	}

	this.ChangeSequenceType = function(oldSequence, type) {
		if(type === "sequence") {
			return new SequenceNode(oldSequence.children);
		}
		else if(type === "cycle") {
			return new CycleNode(oldSequence.children);
		}
		else if(type === "shuffle") {
			return new ShuffleNode(oldSequence.children);
		}
		return oldSequence;
	}

	this.CreateSequenceBlock = function() {
		var option1 = new DialogBlockNode( false /*doIndentFirstLine*/ );
		option1.AddChild(new FuncNode("say", [new LiteralNode("...")]));

		var option2 = new DialogBlockNode( false /*doIndentFirstLine*/ );
		option2.AddChild(new FuncNode("say", [new LiteralNode("...")]));

		var sequence = new SequenceNode( [ option1, option2 ] );
		var block = new CodeBlockNode();
		block.AddChild( sequence );
		return block;
	}

	this.CreateCycleBlock = function() {
		var option1 = new DialogBlockNode( false /*doIndentFirstLine*/ );
		option1.AddChild(new FuncNode("say", [new LiteralNode("...")]));

		var option2 = new DialogBlockNode( false /*doIndentFirstLine*/ );
		option2.AddChild(new FuncNode("say", [new LiteralNode("...")]));

		var sequence = new CycleNode( [ option1, option2 ] );
		var block = new CodeBlockNode();
		block.AddChild( sequence );
		return block;
	}

	this.CreateShuffleBlock = function() {
		var option1 = new DialogBlockNode( false /*doIndentFirstLine*/ );
		option1.AddChild(new FuncNode("say", [new LiteralNode("...")]));

		var option2 = new DialogBlockNode( false /*doIndentFirstLine*/ );
		option2.AddChild(new FuncNode("say", [new LiteralNode("...")]));

		var sequence = new ShuffleNode( [ option1, option2 ] );
		var block = new CodeBlockNode();
		block.AddChild( sequence );
		return block;
	}

	this.CreateIfBlock = function() {
		var leftNode = new CodeBlockNode();
		leftNode.AddChild( new FuncNode("item", [new LiteralNode("0")] ) );
		var rightNode = new LiteralNode( 1 );
		var condition1 = new ExpNode("==", leftNode, rightNode );

		var condition2 = new ElseNode();

		var result1 = new DialogBlockNode();
		result1.AddChild(new FuncNode("say", [new LiteralNode("...")]));

		var result2 = new DialogBlockNode();
		result2.AddChild(new FuncNode("say", [new LiteralNode("...")]));

		var ifNode = new IfNode( [ condition1, condition2 ], [ result1, result2 ] );
		var block = new CodeBlockNode();
		block.AddChild( ifNode );
		return block;
	}

	this.ReadDialogScript = function(lines, i) {
		var scriptStr = "";
		if (lines[i] === Sym.DialogOpen) {
			scriptStr += lines[i] + "\n";
			i++;
			while(lines[i] != Sym.DialogClose) {
				scriptStr += lines[i] + "\n";
				i++;
			}
			scriptStr += lines[i];
			i++;
		}
		else {
			scriptStr += lines[i];
			i++;
		}
		return { script:scriptStr, index:i };
	}

	// TODO this.ReadCodeScript (reads through code open and close symbols), and this.ReadScript

	this.EnsureDialogBlockFormat = function(dialogStr) {
		// TODO -- what if it's already enclosed in dialog symbols??
		if(dialogStr.indexOf('\n') > -1) {
			dialogStr = Sym.DialogOpen + "\n" + dialogStr + "\n" + Sym.DialogClose;
		}
		return dialogStr;
	}

	this.RemoveDialogBlockFormat = function(source) {
		var sourceLines = source.split("\n");
		var dialogStr = "";
		if(sourceLines[0] === Sym.DialogOpen) {
			// multi line
			var i = 1;
			while (i < sourceLines.length && sourceLines[i] != Sym.DialogClose) {
				dialogStr += sourceLines[i] + (sourceLines[i+1] != Sym.DialogClose ? '\n' : '');
				i++;
			}
		}
		else {
			// single line
			dialogStr = source;
		}
		return dialogStr;
	}

	this.SerializeDialogNodeList = function(nodeList) {
		var tempBlock = new DialogBlockNode(false);
		 // set children directly to avoid breaking the parenting chain for this temp operation
		tempBlock.children = nodeList;
		return tempBlock.Serialize();
	}

	this.GetOperatorList = function() {
		return [Sym.Set].concat(Sym.Operators);
	}

	this.IsInlineCode = function(node) {
		return isInlineCode(node);
	}
}


/* BUILT-IN FUNCTIONS */ // TODO: better way to encapsulate these?
function deprecatedFunc(environment,parameters,onReturn) {
	bitsy.log("BITSY SCRIPT WARNING: Tried to use deprecated function");
	onReturn(null);
}

function sayFunc(environment, parameters, onReturn) {
	if (parameters[0] != undefined && parameters[0] != null) {
		var textStr = "" + parameters[0];
		environment.GetDialogBuffer().AddText(textStr);
		environment.GetDialogBuffer().AddScriptReturn(function() { onReturn(null); });
	}
	else {
		onReturn(null);
	}
}

function linebreakFunc(environment, parameters, onReturn) {
	// bitsy.log("LINEBREAK FUNC");
	environment.GetDialogBuffer().AddLinebreak();
	environment.GetDialogBuffer().AddScriptReturn(function() { onReturn(null); });
}

function pagebreakFunc(environment, parameters, onReturn) {
	environment.GetDialogBuffer().AddPagebreak(function() { onReturn(null); });
}

function drawFunc(environment, parameters, onReturn) {
	var drawingId = parameters[0];
	environment.GetDialogBuffer().AddDrawing(drawingId);
	environment.GetDialogBuffer().AddScriptReturn(function() { onReturn(null); });
}

function drawSpriteFunc(environment, parameters, onReturn) {
	var spriteId = parameters[0];

	// check if id parameter is actually a name
	if (names.sprite[spriteId] != undefined) {
		spriteId = names.sprite[spriteId];
	}

	var drawingId = sprite[spriteId].drw;
	drawFunc(environment, [drawingId], onReturn);
}

function drawTileFunc(environment, parameters, onReturn) {
	var tileId = parameters[0];

	// check if id parameter is actually a name
	if (names.tile[tileId] != undefined) {
		tileId = names.tile[tileId];
	}

	var drawingId = tile[tileId].drw;
	drawFunc(environment, [drawingId], onReturn);
}

function drawItemFunc(environment, parameters, onReturn) {
	var itemId = parameters[0];

	// check if id parameter is actually a name
	if (names.item[itemId] != undefined) {
		itemId = names.item[itemId];
	}

	var drawingId = item[itemId].drw;
	drawFunc(environment, [drawingId], onReturn);
}

function printFontFunc(environment, parameters, onReturn) {
	var allCharacters = "";
	var font = fontManager.Get(fontName);
	var codeList = font.allCharCodes();
	for (var i = 0; i < codeList.length; i++) {
		allCharacters += String.fromCharCode(codeList[i]) + " ";
	}
	sayFunc(environment, [allCharacters], onReturn);
}

function itemFunc(environment,parameters,onReturn) {
	var itemId = parameters[0];

	if (names.item[itemId] != undefined) {
		// id is actually a name
		itemId = names.item[itemId];
	}

	var curItemCount = player().inventory[itemId] ? player().inventory[itemId] : 0;

	if (parameters.length > 1) {
		// TODO : is it a good idea to force inventory to be >= 0?
		player().inventory[itemId] = Math.max(0, parseInt(parameters[1]));
		curItemCount = player().inventory[itemId];

		if (onInventoryChanged != null) {
			onInventoryChanged(itemId);
		}
	}

	onReturn(curItemCount);
}

function toggleTextEffect(environment, name) {
	if (environment.GetDialogBuffer().hasTextEffect(name)) {
		environment.GetDialogBuffer().popTextEffect(name);
	}
	else {
		environment.GetDialogBuffer().pushTextEffect(name, []);
	}
}

function color1Func(environment, parameters, onReturn) {
	toggleTextEffect(environment, "clr1");
	onReturn(null);
}

function color2Func(environment, parameters, onReturn) {
	toggleTextEffect(environment, "clr2");
	onReturn(null);
}

function color3Func(environment, parameters, onReturn) {
	toggleTextEffect(environment, "clr3");
	onReturn(null);
}

function colorFunc(environment, parameters, onReturn) {
	environment.GetDialogBuffer().pushTextEffect("clr", parameters);
	onReturn(null);
}

function colorPopFunc(environment, parameters, onReturn) {
	if (environment.GetDialogBuffer().hasTextEffect("clr")) {
		environment.GetDialogBuffer().popTextEffect("clr");
	}
	onReturn(null);
}

function rainbowFunc(environment, parameters, onReturn) {
	toggleTextEffect(environment, "rbw");
	onReturn(null);
}

function rainbowPopFunc(environment, parameters, onReturn) {
	if (environment.GetDialogBuffer().hasTextEffect("rbw")) {
		environment.GetDialogBuffer().popTextEffect("rbw");
	}
	onReturn(null);
}

function wavyFunc(environment, parameters, onReturn) {
	toggleTextEffect(environment, "wvy");
	onReturn(null);
}

function wavyPopFunc(environment, parameters, onReturn) {
	if (environment.GetDialogBuffer().hasTextEffect("wvy")) {
		environment.GetDialogBuffer().popTextEffect("wvy");
	}
	onReturn(null);
}

function shakyFunc(environment, parameters, onReturn) {
	toggleTextEffect(environment, "shk");
	onReturn(null);
}

function shakyPopFunc(environment, parameters, onReturn) {
	if (environment.GetDialogBuffer().hasTextEffect("shk")) {
		environment.GetDialogBuffer().popTextEffect("shk");
	}
	onReturn(null);
}

function propertyFunc(environment, parameters, onReturn) {
	var outValue = null;

	if (parameters.length > 0 && parameters[0]) {
		var propertyName = parameters[0];

		if (environment.HasProperty(propertyName)) {
			// TODO : in a future update I can handle the case of initializing a new property
			// after which we can move this block outside the HasProperty check
			if (parameters.length > 1) {
				var inValue = parameters[1];
				environment.SetProperty(propertyName, inValue);
			}

			outValue = environment.GetProperty(propertyName);
		}
	}

	bitsy.log("PROPERTY! " + propertyName + " " + outValue);

	onReturn(outValue);
}

function endFunc(environment,parameters,onReturn) {
	isEnding = true;
	isNarrating = true;
	dialogRenderer.SetCentered(true);
	dialogRenderer.DrawTextbox();
	onReturn(null);
}

function exitFunc(environment, parameters, onReturn) {
	var destRoom;
	var destX;
	var destY;

	if (parameters.length >= 1) {
		destRoom = parameters[0];

		// is it a name?
		if (names.room[destRoom] != undefined) {
			destRoom = names.room[destRoom];
		}
	}

	if (parameters.length >= 3) {
		destX = parseInt(parameters[1]);
		destY = parseInt(parameters[2]);
	}

	if (parameters.length >= 4) {
		var transitionEffect = parameters[3];

		transition.BeginTransition(
			player().room,
			player().x,
			player().y,
			destRoom,
			destX,
			destY,
			transitionEffect);
		transition.UpdateTransition(0);
	}

	var movePlayerAndResumeScript = function() {
		if (destRoom != undefined && destX != undefined && destY != undefined) {
			// update world state
			player().room = destRoom;
			player().x = destX;
			player().y = destY;
			state.room = destRoom;

			// update game state
			initRoom(state.room);
		}

		if (dialogRenderer) {
			dialogRenderer.updateTextboxPosition();
		}

		// resume dialog script
		onReturn(state.room);
	};

	// TODO : this doesn't play nice with pagebreak because it thinks the dialog is finished!
	if (transition.IsTransitionActive()) {
		transition.OnTransitionComplete(movePlayerAndResumeScript);
	}
	else {
		movePlayerAndResumeScript();
	}
}

function tuneFunc(environment, parameters, onReturn) {
	if (parameters.length > 0) {
		var tuneId = parameters[0];

		// check if id parameter is actually a name
		if (names.tune[tuneId] != undefined) {
			tuneId = names.tune[tuneId];
		}

		if (soundPlayer) {
			if (tuneId === "0") {
				soundPlayer.stopTune();
			}
			else if (state.tune != tuneId) {
				soundPlayer.playTune(tune[tuneId]);
			}
		}

		state.tune = tuneId;
	}

	onReturn(state.tune);
}

function blipFunc(environment, parameters, onReturn) {
	if (parameters.length > 0) {
		var blipId = parameters[0];

		// check if id parameter is actually a name
		if (names.blip[blipId] != undefined) {
			blipId = names.blip[blipId];
		}

		soundPlayer.playBlip(blip[blipId]);
	}

	// if a dialog skip is happening, stop it and force a redraw of the textbox
	if (dialogBuffer) {
		if (dialogBuffer.tryInterruptSkip()) {
			dialogRenderer.Draw(dialogBuffer, 0, true /* disableOnPrint */);
		}
	}

	onReturn(null);
}

/*
// TODO : use later?
function yakFunc(environment, parameters, onReturn) {
	if (parameters.length > 0) {
		var blipId = parameters[0];

		// check if id parameter is actually a name
		if (names.blip[blipId] != undefined) {
			blipId = names.blip[blipId];
		}

		environment.GetDialogBuffer().pushTextEffect("yak", [blipId]);
	}

	onReturn(null);
}

function yakPopFunc(environment, parameters, onReturn) {
	if (environment.GetDialogBuffer().hasTextEffect("yak")) {
		environment.GetDialogBuffer().popTextEffect("yak");
	}

	onReturn(null);
}
*/

function paletteFunc(environment, parameters, onReturn) {
	if (parameters.length > 0) {
		var palId = parameters[0];

		// check if id parameter is actually a name
		if (names.palette[palId] != undefined) {
			palId = names.palette[palId];
		}

		updatePalette(palId);
	}

	onReturn(state.pal);
}

function avatarFunc(environment, parameters, onReturn) {
	if (parameters.length > 0) {
		var sprId = parameters[0];

		// check if id parameter is actually a name
		if (names.sprite[sprId] != undefined) {
			sprId = names.sprite[sprId];
		}

		// override the avatar's current appearance
		state.ava = sprId;

		// redraw the avatar with its new appearance
		drawRoom(room[state.room], { redrawAvatar: true });
	}

	onReturn(state.ava);
}

/* BUILT-IN OPERATORS */
function setExp(environment,left,right,onReturn) {
	// bitsy.log("SET " + left.name);

	if(left.type != "variable") {
		// not a variable! return null and hope for the best D:
		onReturn( null );
		return;
	}

	right.Eval(environment,function(rVal) {
		environment.SetVariable( left.name, rVal );
		// bitsy.log("VAL " + environment.GetVariable( left.name ) );
		left.Eval(environment,function(lVal) {
			onReturn( lVal );
		});
	});
}
function equalExp(environment,left,right,onReturn) {
	// bitsy.log("EVAL EQUAL");
	// bitsy.log(left);
	// bitsy.log(right);
	right.Eval(environment,function(rVal){
		left.Eval(environment,function(lVal){
			onReturn( lVal === rVal );
		});
	});
}
function greaterExp(environment,left,right,onReturn) {
	right.Eval(environment,function(rVal){
		left.Eval(environment,function(lVal){
			onReturn( lVal > rVal );
		});
	});
}
function lessExp(environment,left,right,onReturn) {
	right.Eval(environment,function(rVal){
		left.Eval(environment,function(lVal){
			onReturn( lVal < rVal );
		});
	});
}
function greaterEqExp(environment,left,right,onReturn) {
	right.Eval(environment,function(rVal){
		left.Eval(environment,function(lVal){
			onReturn( lVal >= rVal );
		});
	});
}
function lessEqExp(environment,left,right,onReturn) {
	right.Eval(environment,function(rVal){
		left.Eval(environment,function(lVal){
			onReturn( lVal <= rVal );
		});
	});
}
function multExp(environment,left,right,onReturn) {
	right.Eval(environment,function(rVal){
		left.Eval(environment,function(lVal){
			onReturn( lVal * rVal );
		});
	});
}
function divExp(environment,left,right,onReturn) {
	right.Eval(environment,function(rVal){
		left.Eval(environment,function(lVal){
			onReturn( lVal / rVal );
		});
	});
}
function addExp(environment,left,right,onReturn) {
	right.Eval(environment,function(rVal){
		left.Eval(environment,function(lVal){
			onReturn( lVal + rVal );
		});
	});
}
function subExp(environment,left,right,onReturn) {
	right.Eval(environment,function(rVal){
		left.Eval(environment,function(lVal){
			onReturn( lVal - rVal );
		});
	});
}

/* ENVIRONMENT */
var Environment = function() {
	var dialogBuffer = null;
	this.SetDialogBuffer = function(buffer) { dialogBuffer = buffer; };
	this.GetDialogBuffer = function() { return dialogBuffer; };

	var functionMap = {};

	// dialog
	functionMap["say"] = sayFunc;
	functionMap["br"] = linebreakFunc;
	functionMap["pg"] = pagebreakFunc;

	// text effects
	functionMap["wvy"] = wavyFunc;
	functionMap["/wvy"] = wavyPopFunc;
	functionMap["shk"] = shakyFunc;
	functionMap["/shk"] = shakyPopFunc;
	functionMap["rbw"] = rainbowFunc;
	functionMap["/rbw"] = rainbowPopFunc;
	functionMap["clr"] = colorFunc;
	functionMap["/clr"] = colorPopFunc;
	// drawing text effects
	functionMap["drwt"] = drawTileFunc;
	functionMap["drws"] = drawSpriteFunc;
	functionMap["drwi"] = drawItemFunc;

	// room
	functionMap["end"] = endFunc;
	functionMap["exit"] = exitFunc;
	functionMap["pal"] = paletteFunc;
	functionMap["ava"] = avatarFunc;

	// inventory & variables
	functionMap["item"] = itemFunc;
	functionMap["property"] = propertyFunc;

	// sound
	functionMap["tune"] = tuneFunc;
	functionMap["blip"] = blipFunc;

	// legacy
	functionMap["clr1"] = color1Func;
	functionMap["clr2"] = color2Func;
	functionMap["clr3"] = color3Func;
	functionMap["print"] = sayFunc;
	functionMap["printTile"] = drawTileFunc;
	functionMap["printSprite"] = drawSpriteFunc;
	functionMap["printItem"] = drawItemFunc;

	// DEBUG
	functionMap["_debugOnlyPrintFont"] = printFontFunc;

	// EXPERIMENTAL
	// functionMap["yak"] = yakFunc;
	// functionMap["/yak"] = yakPopFunc;

	this.HasFunction = function(name) { return functionMap[name] != undefined; };
	this.EvalFunction = function(name,parameters,onReturn,env) {
		if (env == undefined || env == null) {
			env = this;
		}

		functionMap[name](env, parameters, onReturn);
	}

	var variableMap = {};

	this.HasVariable = function(name) { return variableMap[name] != undefined; };
	this.GetVariable = function(name) { return variableMap[name]; };
	this.SetVariable = function(name,value,useHandler) {
		// bitsy.log("SET VARIABLE " + name + " = " + value);
		if(useHandler === undefined) useHandler = true;
		variableMap[name] = value;
		if(onVariableChangeHandler != null && useHandler){
			onVariableChangeHandler(name);
		}
	};
	this.DeleteVariable = function(name,useHandler) {
		if(useHandler === undefined) useHandler = true;
		if(variableMap[name] != undefined) {
			variableMap.delete(name);
			if(onVariableChangeHandler != null && useHandler) {
				onVariableChangeHandler(name);
			}
		}
	};

	var operatorMap = {};
	operatorMap["="] = setExp;
	operatorMap["=="] = equalExp;
	operatorMap[">"] = greaterExp;
	operatorMap["<"] = lessExp;
	operatorMap[">="] = greaterEqExp;
	operatorMap["<="] = lessEqExp;
	operatorMap["*"] = multExp;
	operatorMap["/"] = divExp;
	operatorMap["+"] = addExp;
	operatorMap["-"] = subExp;

	this.HasOperator = function(sym) { return operatorMap[sym] != undefined; };
	this.EvalOperator = function(sym,left,right,onReturn) {
		operatorMap[ sym ]( this, left, right, onReturn );
	}

	var scriptMap = {};
	this.HasScript = function(name) { return scriptMap[name] != undefined; };
	this.GetScript = function(name) { return scriptMap[name]; };
	this.SetScript = function(name,script) { scriptMap[name] = script; };

	var onVariableChangeHandler = null;
	this.SetOnVariableChangeHandler = function(onVariableChange) {
		onVariableChangeHandler = onVariableChange;
	}
	this.GetVariableNames = function() {
		var variableNames = [];

		for (var key in variableMap) {
			variableNames.push(key);
		}

		return variableNames;
	}
}

// Local environment for a single run of a script: knows local context
var LocalEnvironment = function(parentEnvironment) {
	// this.SetDialogBuffer // not allowed in local environment?
	this.GetDialogBuffer = function() { return parentEnvironment.GetDialogBuffer(); };

	this.HasFunction = function(name) { return parentEnvironment.HasFunction(name); };
	this.EvalFunction = function(name,parameters,onReturn,env) {
		if (env == undefined || env == null) {
			env = this;
		}

		parentEnvironment.EvalFunction(name,parameters,onReturn,env);
	}

	this.HasVariable = function(name) { return parentEnvironment.HasVariable(name); };
	this.GetVariable = function(name) { return parentEnvironment.GetVariable(name); };
	this.SetVariable = function(name,value,useHandler) { parentEnvironment.SetVariable(name,value,useHandler); };
	// this.DeleteVariable // not needed in local environment?

	this.HasOperator = function(sym) { return parentEnvironment.HasOperator(sym); };
	this.EvalOperator = function(sym,left,right,onReturn,env) {
		if (env == undefined || env == null) {
			env = this;
		}

		parentEnvironment.EvalOperator(sym,left,right,onReturn,env);
	};

	// TODO : I don't *think* any of this is required by the local environment
	// this.HasScript
	// this.GetScript
	// this.SetScript

	// TODO : pretty sure these debug methods aren't required by the local environment either
	// this.SetOnVariableChangeHandler
	// this.GetVariableNames

	/* Here's where specific local context data goes:
	 * this includes access to the object running the script
	 * and any properties it may have (so far only "locked")
	 */

	// The local environment knows what object called it -- currently only used to access properties
	var curObject = null;
	this.HasObject = function() { return curObject != undefined && curObject != null; }
	this.SetObject = function(object) { curObject = object; }
	this.GetObject = function() { return curObject; }

	// accessors for properties of the object that's running the script
	this.HasProperty = function(name) {
		if (curObject && curObject.property && curObject.property.hasOwnProperty(name)) {
			return true;
		}
		else {
			return false;
		}
	};
	this.GetProperty = function(name) {
		if (curObject && curObject.property && curObject.property.hasOwnProperty(name)) {
			return curObject.property[name]; // TODO : should these be getters and setters instead?
		}
		else {
			return null;
		}
	};
	this.SetProperty = function(name, value) {
		// NOTE : for now, we need to gaurd against creating new properties
		if (curObject && curObject.property && curObject.property.hasOwnProperty(name)) {
			curObject.property[name] = value;
		}
	};
}

function leadingWhitespace(depth) {
	var str = "";
	for(var i = 0; i < depth; i++) {
		str += "  "; // two spaces per indent
	}
	// bitsy.log("WHITESPACE " + depth + " ::" + str + "::");
	return str;
}

/* NODES */
var TreeRelationship = function() {
	this.parent = null;
	this.children = [];

	this.AddChild = function(node) {
		this.children.push(node);
		node.parent = this;
	};

	this.AddChildren = function(nodeList) {
		for (var i = 0; i < nodeList.length; i++) {
			this.AddChild(nodeList[i]);
		}
	};

	this.SetChildren = function(nodeList) {
		this.children = [];
		this.AddChildren(nodeList);
	};

	this.VisitAll = function(visitor, depth) {
		if (depth == undefined || depth == null) {
			depth = 0;
		}

		visitor.Visit(this, depth);
		for (var i = 0; i < this.children.length; i++) {
			this.children[i].VisitAll( visitor, depth + 1 );
		}
	};

	this.rootId = null; // for debugging
	this.GetId = function() {
		// bitsy.log(this);
		if (this.rootId != null) {
			return this.rootId;
		}
		else if (this.parent != null) {
			var parentId = this.parent.GetId();
			if (parentId != null) {
				return parentId + "_" + this.parent.children.indexOf(this);
			}
		}
		else {
			return null;
		}
	}
}

function DialogBlockNode(doIndentFirstLine) {
	TreeRelationship.call(this);

	this.type = "dialog_block";

	this.Eval = function(environment, onReturn) {
		// bitsy.log("EVAL BLOCK " + this.children.length);

		if (isPlayerEmbeddedInEditor && events != undefined && events != null) {
			events.Raise("script_node_enter", { id: this.GetId() });
		}

		var lastVal = null;
		var i = 0;

		function evalChildren(children, done) {
			if (i < children.length) {
				// bitsy.log(">> CHILD " + i);
				children[i].Eval(environment, function(val) {
					// bitsy.log("<< CHILD " + i);
					lastVal = val;
					i++;
					evalChildren(children,done);
				});
			}
			else {
				done();
			}
		};

		var self = this;
		evalChildren(this.children, function() {
			if (isPlayerEmbeddedInEditor && events != undefined && events != null) {
				events.Raise("script_node_exit", { id: self.GetId() });
			}

			onReturn(lastVal);
		});
	}

	if (doIndentFirstLine === undefined) {
		doIndentFirstLine = true; // This is just for serialization
	}

	this.Serialize = function(depth) {
		if (depth === undefined) {
			depth = 0;
		}

		var str = "";
		var lastNode = null;

		for (var i = 0; i < this.children.length; i++) {

			var curNode = this.children[i];

			var shouldIndentFirstLine = (i == 0 && doIndentFirstLine);
			var shouldIndentAfterLinebreak = (lastNode && lastNode.type === "function" && lastNode.name === "br");

			if (shouldIndentFirstLine || shouldIndentAfterLinebreak) {
				str += leadingWhitespace(depth);
			}

			str += curNode.Serialize(depth);

			lastNode = curNode;
		}

		return str;
	}

	this.ToString = function() {
		return this.type + " " + this.GetId();
	};
}

function CodeBlockNode() {
	TreeRelationship.call(this);

	this.type = "code_block";

	this.Eval = function(environment, onReturn) {
		// bitsy.log("EVAL BLOCK " + this.children.length);

		if (isPlayerEmbeddedInEditor && events != undefined && events != null) {
			events.Raise("script_node_enter", { id: this.GetId() });
		}

		var lastVal = null;
		var i = 0;

		function evalChildren(children, done) {
			if (i < children.length) {
				// bitsy.log(">> CHILD " + i);
				children[i].Eval(environment, function(val) {
					// bitsy.log("<< CHILD " + i);
					lastVal = val;
					i++;
					evalChildren(children,done);
				});
			}
			else {
				done();
			}
		};

		var self = this;
		evalChildren(this.children, function() {
			if (isPlayerEmbeddedInEditor && events != undefined && events != null) {
				events.Raise("script_node_exit", { id: self.GetId() });
			}

			onReturn(lastVal);
		});
	}

	this.Serialize = function(depth) {
		if(depth === undefined) {
			depth = 0;
		}

		// bitsy.log("SERIALIZE BLOCK!!!");
		// bitsy.log(depth);
		// bitsy.log(doIndentFirstLine);

		var str = "{"; // todo: increase scope of Sym?

		// TODO : do code blocks ever have more than one child anymore????
		for (var i = 0; i < this.children.length; i++) {
			var curNode = this.children[i];
			str += curNode.Serialize(depth);
		}

		str += "}";

		return str;
	}

	this.ToString = function() {
		return this.type + " " + this.GetId();
	};
}

function isInlineCode(node) {
	return isTextEffectBlock(node) || isUndefinedBlock(node) || isMultilineListBlock(node);
}

function isUndefinedBlock(node) {
	return node.type === "code_block" && node.children.length > 0 && node.children[0].type === "undefined";
}

var textEffectBlockNames = ["clr1", "clr2", "clr3", "wvy", "shk", "rbw", "printSprite", "printItem", "printTile", "print", "say", "br"];
function isTextEffectBlock(node) {
	if (node.type === "code_block") {
		if (node.children.length > 0 && node.children[0].type === "function") {
			var func = node.children[0];
			return textEffectBlockNames.indexOf(func.name) != -1;
		}
	}
	return false;
}

var listBlockTypes = ["sequence", "cycle", "shuffle", "if"];
function isMultilineListBlock(node) {
	if (node.type === "code_block") {
		if (node.children.length > 0) {
			var child = node.children[0];
			return listBlockTypes.indexOf(child.type) != -1;
		}
	}
	return false;
}

// for round-tripping undefined code through the parser (useful for hacks!)
function UndefinedNode(sourceStr) {
	TreeRelationship.call(this);

	this.type = "undefined";
	this.source = sourceStr;

	this.Eval = function(environment,onReturn) {
		toggleTextEffect(environment, "_debug_highlight");
		sayFunc(environment, ["{" + sourceStr + "}"], function() {
			onReturn(null);
		});
		toggleTextEffect(environment, "_debug_highlight");
	}

	this.Serialize = function(depth) {
		return this.source;
	}

	this.ToString = function() {
		return "undefined" + " " + this.GetId();
	}
}

function FuncNode(name, args) {
	TreeRelationship.call(this);

	this.type = "function";
	this.name = name;
	this.args = args;

	this.Eval = function(environment,onReturn) {
		if (isPlayerEmbeddedInEditor && events != undefined && events != null) {
			events.Raise("script_node_enter", { id: this.GetId() });
		}

		var self = this; // hack to deal with scope (TODO : move up higher?)

		var argumentValues = [];
		var i = 0;

		function evalArgs(args, done) {
			// TODO : really hacky way to make we get the first
			// symbol's NAME instead of its variable value
			// if we are trying to do something with a property
			if (self.name === "property" && i === 0 && i < args.length) {
				if (args[i].type === "variable") {
					argumentValues.push(args[i].name);
					i++;
				}
				else {
					// first argument for a property MUST be a variable symbol
					// -- so skip everything if it's not!
					i = args.length;
				}
			}

			if (i < args.length) {
				// Evaluate each argument
				args[i].Eval(
					environment,
					function(val) {
						argumentValues.push(val);
						i++;
						evalArgs(args, done);
					});
			}
			else {
				done();
			}
		};

		evalArgs(
			this.args,
			function() {
				if (isPlayerEmbeddedInEditor && events != undefined && events != null) {
					events.Raise("script_node_exit", { id: self.GetId() });
				}

				environment.EvalFunction(self.name, argumentValues, onReturn);
			});
	}

	this.Serialize = function(depth) {
		var isDialogBlock = this.parent.type === "dialog_block";
		if (isDialogBlock && this.name === "say") {
			// TODO this could cause problems with "real" print functions
			return this.args[0].value; // first argument should be the text of the {print} func
		}
		else if (isDialogBlock && this.name === "br") {
			return "\n";
		}
		else {
			var str = "";
			str += this.name;
			for(var i = 0; i < this.args.length; i++) {
				str += " ";
				str += this.args[i].Serialize(depth);
			}
			return str;
		}
	}

	this.ToString = function() {
		return this.type + " " + this.name + " " + this.GetId();
	};
}

function LiteralNode(value) {
	TreeRelationship.call(this);

	this.type = "literal";
	this.value = value;

	this.Eval = function(environment,onReturn) {
		onReturn(this.value);
	};

	this.Serialize = function(depth) {
		var str = "";

		if (this.value === null) {
			return str;
		}

		if (typeof this.value === "string") {
			str += '"';
		}

		str += this.value;

		if (typeof this.value === "string") {
			str += '"';
		}

		return str;
	};

	this.ToString = function() {
		return this.type + " " + this.value + " " + this.GetId();
	};
}

function VarNode(name) {
	TreeRelationship.call(this);

	this.type = "variable";
	this.name = name;

	this.Eval = function(environment,onReturn) {
		// bitsy.log("EVAL " + this.name + " " + environment.HasVariable(this.name) + " " + environment.GetVariable(this.name));
		if( environment.HasVariable(this.name) )
			onReturn( environment.GetVariable( this.name ) );
		else
			onReturn(null); // not a valid variable -- return null and hope that's ok
	} // TODO: might want to store nodes in the variableMap instead of values???

	this.Serialize = function(depth) {
		var str = "" + this.name;
		return str;
	}

	this.ToString = function() {
		return this.type + " " + this.name + " " + this.GetId();
	};
}

function ExpNode(operator, left, right) {
	TreeRelationship.call(this);

	this.type = "operator";
	this.operator = operator;
	this.left = left;
	this.right = right;

	this.Eval = function(environment,onReturn) {
		// bitsy.log("EVAL " + this.operator);
		var self = this; // hack to deal with scope
		environment.EvalOperator( this.operator, this.left, this.right, 
			function(val){
				// bitsy.log("EVAL EXP " + self.operator + " " + val);
				onReturn(val);
			} );
		// NOTE : sadly this pushes a lot of complexity down onto the actual operator methods
	};

	this.Serialize = function(depth) {
		var isNegativeNumber = this.operator === "-" && this.left.type === "literal" && this.left.value === null;

		if (!isNegativeNumber) {
			var str = "";

			if (this.left != undefined && this.left != null) {
				str += this.left.Serialize(depth) + " ";
			}

			str += this.operator;

			if (this.right != undefined && this.right != null) {
				str += " " + this.right.Serialize(depth);
			}

			return str;
		}
		else {
			return this.operator + this.right.Serialize(depth); // hacky but seems to work
		}
	};

	this.VisitAll = function(visitor, depth) {
		if (depth == undefined || depth == null) {
			depth = 0;
		}

		visitor.Visit( this, depth );
		if(this.left != null)
			this.left.VisitAll( visitor, depth + 1 );
		if(this.right != null)
			this.right.VisitAll( visitor, depth + 1 );
	};

	this.ToString = function() {
		return this.type + " " + this.operator + " " + this.GetId();
	};
}

function SequenceBase() {
	TreeRelationship.call(this);

	this.Serialize = function(depth) {
		var str = "";
		str += this.type + "\n";
		for (var i = 0; i < this.children.length; i++) {
			str += leadingWhitespace(depth + 1) + Sym.List + " ";
			str += this.children[i].Serialize(depth + 2);
			str += "\n";
		}
		str += leadingWhitespace(depth);
		return str;
	};

	this.VisitAll = function(visitor, depth) {
		if (depth == undefined || depth == null) {
			depth = 0;
		}

		visitor.Visit(this, depth);
		for (var i = 0; i < this.children.length; i++) {
			this.children[i].VisitAll( visitor, depth + 1 );
		}
	};

	this.ToString = function() {
		return this.type + " " + this.GetId();
	};
}

function SequenceNode(options) {
	SequenceBase.call(this);

	this.type = "sequence";
	this.AddChildren(options);

	var index = 0;
	this.Eval = function(environment, onReturn) {
		// bitsy.log("SEQUENCE " + index);
		this.children[index].Eval(environment, onReturn);

		var next = index + 1;
		if (next < this.children.length) {
			index = next;
		}
	}
}

function CycleNode(options) {
	SequenceBase.call(this);

	this.type = "cycle";
	this.AddChildren(options);

	var index = 0;
	this.Eval = function(environment, onReturn) {
		// bitsy.log("CYCLE " + index);
		this.children[index].Eval(environment, onReturn);

		var next = index + 1;
		if (next < this.children.length) {
			index = next;
		}
		else {
			index = 0;
		}
	}
}

function ShuffleNode(options) {
	SequenceBase.call(this);

	this.type = "shuffle";
	this.AddChildren(options);

	var optionsShuffled = [];
	function shuffle(options) {
		optionsShuffled = [];
		var optionsUnshuffled = options.slice();
		while (optionsUnshuffled.length > 0) {
			var i = Math.floor(Math.random() * optionsUnshuffled.length);
			optionsShuffled.push(optionsUnshuffled.splice(i,1)[0]);
		}
	}
	shuffle(this.children);

	var index = 0;
	this.Eval = function(environment, onReturn) {
		optionsShuffled[index].Eval(environment, onReturn);
		
		index++;
		if (index >= this.children.length) {
			shuffle(this.children);
			index = 0;
		}
	}
}

// TODO : rename? ConditionalNode?
function IfNode(conditions, results, isSingleLine) {
	TreeRelationship.call(this);

	this.type = "if";

	for (var i = 0; i < conditions.length; i++) {
		this.AddChild(new ConditionPairNode(conditions[i], results[i]));
	}

	var self = this;
	this.Eval = function(environment, onReturn) {
		// bitsy.log("EVAL IF");
		var i = 0;
		function TestCondition() {
			self.children[i].Eval(environment, function(result) {
				if (result.conditionValue == true) {
					onReturn(result.resultValue);
				}
				else if (i+1 < self.children.length) {
					i++;
					TestCondition();
				}
				else {
					onReturn(null);
				}
			});
		};
		TestCondition();
	};

	if (isSingleLine === undefined) {
		isSingleLine = false; // This is just for serialization
	}

	this.Serialize = function(depth) {
		var str = "";
		if(isSingleLine) {
			// HACKY - should I even keep this mode???
			str += this.children[0].children[0].Serialize() + " ? " + this.children[0].children[1].Serialize();
			if (this.children.length > 1 && this.children[1].children[0].type === Sym.Else) {
				str += " " + Sym.ElseExp + " " + this.children[1].children[1].Serialize();
			}
		}
		else {
			str += "\n";
			for (var i = 0; i < this.children.length; i++) {
				str += this.children[i].Serialize(depth);
			}
			str += leadingWhitespace(depth);
		}
		return str;
	};

	this.IsSingleLine = function() {
		return isSingleLine;
	};

	this.VisitAll = function(visitor, depth) {
		if (depth == undefined || depth == null) {
			depth = 0;
		}

		visitor.Visit(this, depth);

		for (var i = 0; i < this.children.length; i++) {
			this.children[i].VisitAll(visitor, depth + 1);
		}
	};

	this.ToString = function() {
		return this.type + " " + this.mode + " " + this.GetId();
	};
}

function ConditionPairNode(condition, result) {
	TreeRelationship.call(this);

	this.type = "condition_pair";

	this.AddChild(condition);
	this.AddChild(result);

	var self = this;

	this.Eval = function(environment, onReturn) {
		self.children[0].Eval(environment, function(conditionSuccess) {
			if (conditionSuccess) {
				self.children[1].Eval(environment, function(resultValue) {
					onReturn({ conditionValue:true, resultValue:resultValue });
				});
			}
			else {
				onReturn({ conditionValue:false });
			}
		});
	};

	this.Serialize = function(depth) {
		var str = "";
		str += leadingWhitespace(depth + 1);
		str += Sym.List + " " + this.children[0].Serialize(depth) + " " + Sym.ConditionEnd + Sym.Linebreak;
		str += this.children[1].Serialize(depth + 2) + Sym.Linebreak;
		return str;
	};

	this.VisitAll = function(visitor, depth) {
		if (depth == undefined || depth == null) {
			depth = 0;
		}

		visitor.Visit(this, depth);

		for (var i = 0; i < this.children.length; i++) {
			this.children[i].VisitAll(visitor, depth + 1);
		}
	};

	this.ToString = function() {
		return this.type + " " + this.GetId();
	};
}

function ElseNode() {
	TreeRelationship.call(this);

	this.type = Sym.Else;

	this.Eval = function(environment, onReturn) {
		onReturn(true);
	};

	this.Serialize = function() {
		return Sym.Else;
	};

	this.ToString = function() {
		return this.type + " " + this.mode + " " + this.GetId();
	};
}

var Sym = {
	DialogOpen : '"""',
	DialogClose : '"""',
	CodeOpen : "{",
	CodeClose : "}",
	Linebreak : "\n", // just call it "break" ?
	Separator : ":",
	List : "-",
	String : '"',
	ConditionEnd : "?",
	Else : "else",
	ElseExp : ":", // special shorthand for expressions (deprecate?)
	Set : "=",
	Operators : ["==", ">=", "<=", ">", "<", "-", "+", "/", "*"], // operators need to be in reverse order of precedence
};

var Parser = function(env) {
	var environment = env;

	this.Parse = function(scriptStr, rootId) {
		var rootNode = new DialogBlockNode();
		rootNode.rootId = rootId;
		var state = new ParserState(rootNode, scriptStr);

		if (state.MatchAhead(Sym.DialogOpen)) {
			// multi-line dialog block
			var dialogStr = state.ConsumeBlock(Sym.DialogOpen + Sym.Linebreak, Sym.Linebreak + Sym.DialogClose);
			rootNode = new DialogBlockNode();
			rootNode.rootId = rootId; // hacky!!
			state = new ParserState(rootNode, dialogStr);
			state = ParseDialog(state);
		}
		else {
			// single-line dialog block
			state = ParseDialog(state);
		}

		return state.rootNode;
	};

	var ParserState = function( rootNode, str ) {
		this.rootNode = rootNode;
		this.curNode = this.rootNode;

		var sourceStr = str;
		var i = 0;
		this.Index = function() { return i; };
		this.Count = function() { return sourceStr.length; };
		this.Done = function() { return i >= sourceStr.length; };
		this.Char = function() { return sourceStr[i]; };
		this.Step = function(n) { if(n===undefined) n=1; i += n; };
		this.MatchAhead = function(str) {
			// bitsy.log(str);
			str = "" + str; // hack to turn single chars into strings
			// bitsy.log(str);
			// bitsy.log(str.length);
			for (var j = 0; j < str.length; j++) {
				if (i + j >= sourceStr.length) {
					return false;
				}
				else if (str[j] != sourceStr[i+j]) {
					return false;
				}
			}
			return true;
		}
		this.Peak = function(end) {
			var str = "";
			var j = i;
			// bitsy.log(j);
			while (j < sourceStr.length && end.indexOf(sourceStr[j]) == -1) {
				str += sourceStr[j];
				j++;
			}
			// bitsy.log("PEAK ::" + str + "::");
			return str;
		}
		this.ConsumeBlock = function(open, close, includeSymbols) {
			if (includeSymbols === undefined || includeSymbols === null) {
				includeSymbols = false;
			}

			var startIndex = i;

			var matchCount = 0;
			if (this.MatchAhead(open)) {
				matchCount++;
				this.Step(open.length);
			}

			while (matchCount > 0 && !this.Done()) {
				if (this.MatchAhead(close)) {
					matchCount--;
					this.Step( close.length );
				}
				else if (this.MatchAhead(open)) {
					matchCount++;
					this.Step(open.length);
				}
				else {
					this.Step();
				}
			}

			if (includeSymbols) {
				return sourceStr.slice(startIndex, i);
			}
			else {
				return sourceStr.slice(startIndex + open.length, i - close.length);
			}
		}

		this.Print = function() { bitsy.log(sourceStr); };
		this.Source = function() { return sourceStr; };
	};

	/*
		ParseDialog():
		This function adds {print} nodes and linebreak {br} nodes to display text,
		interleaved with bracketed code nodes for functions and flow control,
		such as text effects {shk} {wvy} or sequences like {cycle} and {shuffle}.
		The parsing of those code blocks is handled by ParseCode.

		Note on parsing newline characters:
		- there should be an implicit linebreak {br} after each dialog line
		- a "dialog line" is defined as any line that either:
			- 1) contains dialog text (any text outside of a code block)
			- 2) is entirely empty (no text, no code)
			- *or* 3) contains a list block (sequence, cycle, shuffle, or conditional)
		- lines *only* containing {code} blocks are not dialog lines

		NOTE TO SELF: all the state I'm storing in here feels like
		evidence that the parsing system kind of broke down at this point :(
		Maybe it would feel better if I move into the "state" object
	*/
	function ParseDialog(state) {
		var curLineNodeList = [];
		var curText = "";
		var curLineIsEmpty = true;
		var curLineContainsDialogText = false;
		var prevLineIsDialogLine = false;

		var curLineIsDialogLine = function() {
			return curLineContainsDialogText || curLineIsEmpty;
		}

		var resetLineStateForNewLine = function() {
			prevLineIsDialogLine = curLineIsDialogLine();
			curLineContainsDialogText = false;
			curLineIsEmpty = true;
			curText = "";
			curLineNodeList = [];
		}

		var tryAddTextNodeToList = function() {
			if (curText.length > 0) {
				var sayNode = new FuncNode("say", [new LiteralNode(curText)]);
				curLineNodeList.push(sayNode);

				curText = "";
				curLineIsEmpty = false;
				curLineContainsDialogText = true;
			}
		}

		var addCodeNodeToList = function() {
			var codeSource = state.ConsumeBlock(Sym.CodeOpen, Sym.CodeClose);
			var codeState = new ParserState(new CodeBlockNode(), codeSource);
			codeState = ParseCode(codeState);
			var codeBlockNode = codeState.rootNode;
			curLineNodeList.push(codeBlockNode);

			curLineIsEmpty = false;

			// lists count as dialog text, because they can contain it
			if (isMultilineListBlock(codeBlockNode)) {
				curLineContainsDialogText = true;
			}
		}

		var tryAddLinebreakNodeToList = function() {
			if (prevLineIsDialogLine) {
				var linebreakNode = new FuncNode("br", []);
				curLineNodeList.unshift(linebreakNode);
			}
		}

		var addLineNodesToParent = function() {
			for (var i = 0; i < curLineNodeList.length; i++) {
				state.curNode.AddChild(curLineNodeList[i]);
			}
		}

		while (!state.Done()) {
			if (state.MatchAhead(Sym.CodeOpen)) { // process code block
				// add any buffered text to a print node, and parse the code
				tryAddTextNodeToList();
				addCodeNodeToList();
			}
			else if (state.MatchAhead(Sym.Linebreak)) { // process new line
				// add any buffered text to a print node, 
				// and add a linebreak if we are between two dialog lines
				tryAddTextNodeToList();
				tryAddLinebreakNodeToList();

				// since we've reached the end of a line
				// add stored nodes for this line to the parent node we are building,
				// and reset state for the next line
				addLineNodesToParent();
				resetLineStateForNewLine();

				state.Step();
			}
			else {
				// continue adding text to the current text buffer
				curText += state.Char();
				state.Step();
			}
		}

		// to make sure we don't leave anything behind:
		// add buffered text to a print node and add all nodes
		// to the current parent node
		tryAddTextNodeToList();
		tryAddLinebreakNodeToList();
		addLineNodesToParent();

		return state;
	}

	function ParseDialogBlock(state) {
		var dialogStr = state.ConsumeBlock( Sym.DialogOpen, Sym.DialogClose );

		var dialogState = new ParserState(new DialogBlockNode(), dialogStr);
		dialogState = ParseDialog( dialogState );

		state.curNode.AddChild( dialogState.rootNode );

		return state;
	}

	/*
		ParseConditional():
		A conditional contains a list of conditions that can be
		evaluated to true or false, followed by more dialog
		that will be evaluated if the condition is true. The first
		true condition is the one that gets evaluated.
	*/
	function ParseConditional(state) {
		var conditionStrings = [];
		var resultStrings = [];
		var curIndex = -1;
		var requiredLeadingWhitespace = -1;

		// TODO : very similar to sequence parsing - can we share anything?
		function parseConditionalItemLine(state) {
			var lineText = "";
			var whitespaceCount = 0;
			var isNewCondition = false;
			var encounteredNonWhitespace = false;
			var encounteredConditionEnd = false;

			while (!state.Done() && !(state.Char() === Sym.Linebreak)) {
				// count whitespace until we hit the first non-whitespace character
				if (!encounteredNonWhitespace) {
					if (state.Char() === " " || state.Char() === "\t") {
						whitespaceCount++;
					}
					else {
						encounteredNonWhitespace = true;

						if (state.Char() === Sym.List) {
							isNewCondition = true;
							whitespaceCount += 2; // count the list seperator AND the following extra space
						}
					}
				}

				// if this is the condition, we need to track whether we've
				// reached the end of the condition
				if (isNewCondition && !encounteredConditionEnd) {
					if (state.Char() === Sym.ConditionEnd) {
						encounteredConditionEnd = true;
					}
				}

				// add characters one at a time, unless it's a code block
				// since code blocks can contain additional sequences inside
				// them that will mess up our list item detection
				if (state.Char() === Sym.CodeOpen) {
					lineText += state.ConsumeBlock(Sym.CodeOpen, Sym.CodeClose, true /*includeSymbols*/);
				}
				else {
					if (!encounteredConditionEnd) { // skip all characters including & after the condition end
						lineText += state.Char();
					}
					state.Step();
				}
			}

			if (state.Char() === Sym.Linebreak) {
				state.Step();
			}

			return { text:lineText, whitespace:whitespaceCount, isNewCondition:isNewCondition };
		}

		// TODO : this is copied from sequence parsing; share?
		function trimLeadingWhitespace(text, trimLength) {
			var textSplit = text.split(Sym.linebreak);
			textSplit = textSplit.map(function(line) { return line.slice(trimLength) });
			return textSplit.join(Sym.linebreak);
		}

		while (!state.Done()) {
			var lineResults = parseConditionalItemLine(state);

			if (lineResults.isNewCondition) {
				requiredLeadingWhitespace = lineResults.whitespace;
				curIndex++;
				conditionStrings[curIndex] = "";
				resultStrings[curIndex] = "";
			}

			// to avoid extra newlines in nested conditionals, only count lines
			// that at least match the whitespace count of the initial line
			// NOTE: see the comment in sequence parsing for more details
			if (lineResults.whitespace >= requiredLeadingWhitespace) {
				var trimmedText = trimLeadingWhitespace(lineResults.text, requiredLeadingWhitespace);

				if (lineResults.isNewCondition) {
					conditionStrings[curIndex] += trimmedText;
				}
				else {
					resultStrings[curIndex] += trimmedText + Sym.Linebreak;
				}
			}
		}

		// hack: cut off the trailing newlines from all the result strings
		resultStrings = resultStrings.map(function(result) { return result.slice(0,-1); });

		var conditions = [];
		for (var i = 0; i < conditionStrings.length; i++) {
			var str = conditionStrings[i].trim();
			if (str === Sym.Else) {
				conditions.push(new ElseNode());
			}
			else {
				var exp = CreateExpression(str);
				conditions.push(exp);
			}
		}

		var results = [];
		for (var i = 0; i < resultStrings.length; i++) {
			var str = resultStrings[i];
			var dialogBlockState = new ParserState(new DialogBlockNode(), str);
			dialogBlockState = ParseDialog(dialogBlockState);
			var dialogBlock = dialogBlockState.rootNode;
			results.push(dialogBlock);
		}

		state.curNode.AddChild(new IfNode(conditions, results));

		return state;
	}

	function IsSequence(str) {
		// bitsy.log("IsSequence? " + str);
		return str === "sequence" || str === "cycle" || str === "shuffle";
	}

	/*
		ParseSequence():
		Sequence nodes contain a list of dialog block nodes. The order those
		nodes are evaluated is determined by the type of sequence:
		- sequence: each child node evaluated once in order
		- cycle: repeats from the beginning after all nodes evaluate
		- shuffle: evaluate in a random order

		Each item in a sequence is sepearated by a "-" character.
		The seperator must come at the beginning of the line,
		but may be preceded by whitespace (in any amount).

		About whitespace: Whitespace at the start of a line
		is ignored if it less than or equal to the count of
		whitespace that preceded the list separator ("-") at
		the start of that item. (The count also includes the
		seperator and the extra space after the seperator.)
	 */
	function ParseSequence(state, sequenceType) {
		var itemStrings = [];
		var curItemIndex = -1; // -1 indicates not reading an item yet
		var requiredLeadingWhitespace = -1;

		function parseSequenceItemLine(state) {
			var lineText = "";
			var whitespaceCount = 0;
			var isNewListItem = false;
			var encounteredNonWhitespace = false;

			while (!state.Done() && !(state.Char() === Sym.Linebreak)) {
				// count whitespace until we hit the first non-whitespace character
				if (!encounteredNonWhitespace) {
					if (state.Char() === " " || state.Char() === "\t") {
						whitespaceCount++;
					}
					else {
						encounteredNonWhitespace = true;

						if (state.Char() === Sym.List) {
							isNewListItem = true;
							whitespaceCount += 2; // count the list seperator AND the following extra space
						}
					}
				}

				// add characters one at a time, unless it's a code block
				// since code blocks can contain additional sequences inside
				// them that will mess up our list item detection
				if (state.Char() === Sym.CodeOpen) {
					lineText += state.ConsumeBlock(Sym.CodeOpen, Sym.CodeClose, true /*includeSymbols*/);
				}
				else {
					lineText += state.Char();
					state.Step();
				}
			}

			if (state.Char() === Sym.Linebreak) {
				state.Step();
			}

			return { text:lineText, whitespace:whitespaceCount, isNewListItem:isNewListItem };
		}

		function trimLeadingWhitespace(text, trimLength) {
			// the split and join is necessary because a single "line"
			// can contain sequences that may contain newlines of their own
			// (we treat them all as one "line" for sequence parsing purposes)
			var textSplit = text.split(Sym.linebreak);
			textSplit = textSplit.map(function(line) { return line.slice(trimLength) });
			return textSplit.join(Sym.linebreak);
		}

		while (!state.Done()) {
			var lineResults = parseSequenceItemLine(state);

			if (lineResults.isNewListItem) {
				requiredLeadingWhitespace = lineResults.whitespace;
				curItemIndex++;
				itemStrings[curItemIndex] = "";
			}

			// to avoid double counting closing lines (empty ones ending in a curly brace)
			// we only allow lines that have at least as much whitespace as the start of the list item
			// TODO : I think right now this leads to a bug if the list item's indentation is less than
			// its parent code block... hopefully that won't be a big deal for now
			// (NOTE: I think the bug could be fixed by only applying this to the FINAL line of an item, but
			// that would require more consideration and testing)
			if (lineResults.whitespace >= requiredLeadingWhitespace) {
				var trimmedText = trimLeadingWhitespace(lineResults.text, requiredLeadingWhitespace);
				itemStrings[curItemIndex] += trimmedText + Sym.Linebreak;
			}
		}

		// a bit hacky: cut off the trailing newlines from all the items
		itemStrings = itemStrings.map(function(item) { return item.slice(0,-1); });

		var options = [];
		for (var i = 0; i < itemStrings.length; i++) {
			var str = itemStrings[i];
			var dialogBlockState = new ParserState(new DialogBlockNode(false /* doIndentFirstLine */), str);
			dialogBlockState = ParseDialog(dialogBlockState);
			var dialogBlock = dialogBlockState.rootNode;
			options.push(dialogBlock);
		}

		if (sequenceType === "sequence") {
			state.curNode.AddChild(new SequenceNode(options));
		}
		else if (sequenceType === "cycle") {
			state.curNode.AddChild(new CycleNode(options));
		}
		else if (sequenceType === "shuffle") {
			state.curNode.AddChild(new ShuffleNode(options));
		}

		return state;
	}

	function ParseFunction(state, funcName) {
		bitsy.log("~~~ PARSE FUNCTION " + funcName);

		var args = [];

		var curSymbol = "";
		function OnSymbolEnd() {
			curSymbol = curSymbol.trim();
			// bitsy.log("PARAMTER " + curSymbol);
			args.push( StringToValue(curSymbol) );
			// bitsy.log(args);
			curSymbol = "";
		}

		while( !( state.Char() === "\n" || state.Done() ) ) {
			if( state.MatchAhead(Sym.CodeOpen) ) {
				var codeBlockState = new ParserState(new CodeBlockNode(), state.ConsumeBlock(Sym.CodeOpen, Sym.CodeClose));
				codeBlockState = ParseCode( codeBlockState );
				var codeBlock = codeBlockState.rootNode;
				args.push( codeBlock );
				curSymbol = "";
			}
			else if( state.MatchAhead(Sym.String) ) {
				/* STRING LITERAL */
				var str = state.ConsumeBlock(Sym.String, Sym.String);
				// bitsy.log("STRING " + str);
				args.push( new LiteralNode(str) );
				curSymbol = "";
			}
			else if(state.Char() === " " && curSymbol.length > 0) {
				OnSymbolEnd();
			}
			else {
				curSymbol += state.Char();
			}
			state.Step();
		}

		if(curSymbol.length > 0) {
			OnSymbolEnd();
		}

		state.curNode.AddChild( new FuncNode( funcName, args ) );

		return state;
	}

	function IsValidVariableName(str) {
		var reg = /^[a-zA-Z_$][a-zA-Z_$0-9]*$/;
		var isValid = reg.test(str);
		// bitsy.log("VALID variable??? " + isValid);
		return isValid;
	}

	function StringToValue(valStr) {
		if(valStr[0] === Sym.CodeOpen) {
			// CODE BLOCK!!!
			var codeStr = (new ParserState( null, valStr )).ConsumeBlock(Sym.CodeOpen, Sym.CodeClose); //hacky
			var codeBlockState = new ParserState(new CodeBlockNode(), codeStr);
			codeBlockState = ParseCode( codeBlockState );
			return codeBlockState.rootNode;
		}
		else if(valStr[0] === Sym.String) {
			// STRING!!
			// bitsy.log("STRING");
			var str = "";
			var i = 1;
			while (i < valStr.length && valStr[i] != Sym.String) {
				str += valStr[i];
				i++;
			}
			// bitsy.log(str);
			return new LiteralNode( str );
		}
		else if(valStr === "true") {
			// BOOL
			return new LiteralNode( true );
		}
		else if(valStr === "false") {
			// BOOL
			return new LiteralNode( false );
		}
		else if( !isNaN(parseFloat(valStr)) ) {
			// NUMBER!!
			// bitsy.log("NUMBER!!! " + valStr);
			return new LiteralNode( parseFloat(valStr) );
		}
		else if(IsValidVariableName(valStr)) {
			// VARIABLE!!
			// bitsy.log("VARIABLE");
			return new VarNode(valStr); // TODO : check for valid potential variables
		}
		else {
			// uh oh
			return new LiteralNode(null);
		}
	}

	function CreateExpression(expStr) {
		expStr = expStr.trim();

		function IsInsideString(index) {
			var inString = false;
			for(var i = 0; i < expStr.length; i++) {
				if(expStr[i] === Sym.String)
					inString = !inString;

				if(index === i)
					return inString;
			}
			return false;
		}

		function IsInsideCode(index) {
			var count = 0;
			for(var i = 0; i < expStr.length; i++) {
				if(expStr[i] === Sym.CodeOpen)
					count++;
				else if(expStr[i] === Sym.CodeClose)
					count--;

				if(index === i)
					return count > 0;
			}
			return false;
		}

		var operator = null;

		// set is special because other operator can look like it, and it has to go first in the order of operations
		var setIndex = expStr.indexOf(Sym.Set);
		if( setIndex > -1 && !IsInsideString(setIndex) && !IsInsideCode(setIndex) ) { // it might be a set operator
			if( expStr[setIndex+1] != "=" && expStr[setIndex-1] != ">" && expStr[setIndex-1] != "<" ) {
				// ok it actually IS a set operator and not ==, >=, or <=
				operator = Sym.Set;
				var variableName = expStr.substring(0,setIndex).trim(); // TODO : valid variable name testing
				var left = IsValidVariableName(variableName) ? new VarNode( variableName ) : new LiteralNode(null);
				var right = CreateExpression( expStr.substring(setIndex+Sym.Set.length) );
				var exp = new ExpNode( operator, left, right );
				return exp;
			}
		}

		// special if "expression" for single-line if statements
		var ifIndex = expStr.indexOf(Sym.ConditionEnd);
		if( ifIndex > -1 && !IsInsideString(ifIndex) && !IsInsideCode(ifIndex) ) {
			operator = Sym.ConditionEnd;
			var conditionStr = expStr.substring(0,ifIndex).trim();
			var conditions = [ CreateExpression(conditionStr) ];

			var resultStr = expStr.substring(ifIndex+Sym.ConditionEnd.length);
			var results = [];
			function AddResult(str) {
				var dialogBlockState = new ParserState(new DialogBlockNode(), str);
				dialogBlockState = ParseDialog( dialogBlockState );
				var dialogBlock = dialogBlockState.rootNode;
				results.push( dialogBlock );
			}

			var elseIndex = resultStr.indexOf(Sym.ElseExp); // does this need to test for strings?
			if(elseIndex > -1) {
				conditions.push( new ElseNode() );

				var elseStr = resultStr.substring(elseIndex+Sym.ElseExp.length);
				var resultStr = resultStr.substring(0,elseIndex);

				AddResult( resultStr.trim() );
				AddResult( elseStr.trim() );
			}
			else {
				AddResult( resultStr.trim() );
			}

			return new IfNode( conditions, results, true /*isSingleLine*/ );
		}

		for( var i = 0; (operator == null) && (i < Sym.Operators.length); i++ ) {
			var opSym = Sym.Operators[i];
			var opIndex = expStr.indexOf( opSym );
			if( opIndex > -1 && !IsInsideString(opIndex) && !IsInsideCode(opIndex) ) {
				operator = opSym;
				var left = CreateExpression( expStr.substring(0,opIndex) );
				var right = CreateExpression( expStr.substring(opIndex+opSym.length) );
				var exp = new ExpNode( operator, left, right );
				return exp;
			}
		}

		if( operator == null ) {
			return StringToValue(expStr);
		}
	}
	this.CreateExpression = CreateExpression;

	function IsWhitespace(str) {
		return ( str === " " || str === "\t" || str === "\n" );
	}

	function IsExpression(str) {
		var tempState = new ParserState(null, str); // hacky
		var textOutsideCodeBlocks = "";

		while (!tempState.Done()) {
			if (tempState.MatchAhead(Sym.CodeOpen)) {
				tempState.ConsumeBlock(Sym.CodeOpen, Sym.CodeClose);
			}
			else {
				textOutsideCodeBlocks += tempState.Char();
				tempState.Step();
			}
		}

		var containsAnyExpressionOperators = (textOutsideCodeBlocks.indexOf(Sym.ConditionEnd) != -1) ||
				(textOutsideCodeBlocks.indexOf(Sym.Set) != -1) ||
				(Sym.Operators.some(function(opSym) { return textOutsideCodeBlocks.indexOf(opSym) != -1; }));

		return containsAnyExpressionOperators;
	}

	function IsLiteral(str) {
		var isBool = str === "true" || str === "false";
		var isNum = !isNaN(parseFloat(str));
		var isStr = str[0] === '"' && str[str.length-1] === '"';
		var isVar = IsValidVariableName(str);
		var isEmpty = str.length === 0;
		return isBool || isNum || isStr || isVar || isEmpty;
	}

	function ParseExpression(state) {
		var line = state.Source(); // state.Peak( [Sym.Linebreak] ); // TODO : remove the linebreak thing
		// bitsy.log("EXPRESSION " + line);
		var exp = CreateExpression(line);
		// bitsy.log(exp);
		state.curNode.AddChild(exp);
		state.Step(line.length);
		return state;
	}

	function IsConditionalBlock(state) {
		var peakToFirstListSymbol = state.Peak([Sym.List]);

		var foundListSymbol = peakToFirstListSymbol < state.Source().length;

		var areAllCharsBeforeListWhitespace = true;
		for (var i = 0; i < peakToFirstListSymbol.length; i++) {
			if (!IsWhitespace(peakToFirstListSymbol[i])) {
				areAllCharsBeforeListWhitespace = false;
			}
		}

		var peakToFirstConditionSymbol = state.Peak([Sym.ConditionEnd]);
		peakToFirstConditionSymbol = peakToFirstConditionSymbol.slice(peakToFirstListSymbol.length);
		var hasNoLinebreakBetweenListAndConditionEnd = peakToFirstConditionSymbol.indexOf(Sym.Linebreak) == -1;

		return foundListSymbol && 
			areAllCharsBeforeListWhitespace && 
			hasNoLinebreakBetweenListAndConditionEnd;
	}

	function ParseCode(state) {
		if (IsConditionalBlock(state)) {
			state = ParseConditional(state);
		}
		else if (environment.HasFunction(state.Peak([" "]))) { // TODO --- what about newlines???
			var funcName = state.Peak([" "]);
			state.Step(funcName.length);
			state = ParseFunction(state, funcName);
		}
		else if (IsSequence(state.Peak([" ", Sym.Linebreak]))) {
			var sequenceType = state.Peak([" ", Sym.Linebreak]);
			state.Step(sequenceType.length);
			state = ParseSequence(state, sequenceType);
		}
		else if (IsLiteral(state.Source()) || IsExpression(state.Source())) {
			state = ParseExpression(state);
		}
		else {
			var undefinedSrc = state.Peak([]);
			var undefinedNode = new UndefinedNode(undefinedSrc);
			state.curNode.AddChild(undefinedNode);
		}

		// just go to the end now
		while (!state.Done()) {
			state.Step();
		}

		return state;
	}

	function ParseCodeBlock(state) {
		var codeStr = state.ConsumeBlock( Sym.CodeOpen, Sym.CodeClose );
		var codeState = new ParserState(new CodeBlockNode(), codeStr);
		codeState = ParseCode( codeState );
		state.curNode.AddChild( codeState.rootNode );
		return state;
	}

}

} // Script()
</script>

<script>
function Dialog() {

this.CreateRenderer = function() {
	return new DialogRenderer();
};

this.CreateBuffer = function() {
	return new DialogBuffer();
};

var DialogRenderer = function() {
	// TODO : refactor this eventually? remove everything from struct.. avoid the defaults?
	var textboxInfo = {
		width : 104,
		height : 8+4+2+5, //8 for text, 4 for top-bottom padding, 2 for line padding, 5 for arrow
		top : 12,
		left : 12,
		bottom : 12, //for drawing it from the bottom
		padding_vert : 2,
		padding_horz : 4,
		arrow_height : 5,
	};

	var font = null;
	this.SetFont = function(f) {
		font = f;
		textboxInfo.height = (textboxInfo.padding_vert * 3) + (relativeFontHeight() * 2) + textboxInfo.arrow_height;

		// todo : clean up all the scale stuff
		var textboxScaleW = textboxInfo.width * getTextScale();
		var textboxScaleH = textboxInfo.height * getTextScale();
		bitsy.textbox(false, 0, 0, textboxScaleW, textboxScaleH);
	}

	this.GetPixelsPerRow = function() {
		return (textboxInfo.width - (textboxInfo.padding_horz * 2)) * getTextScale();
	}

	// todo : cache this value? it shouldn't really change in the middle of a game
	function getTextScale() {
		return bitsy.textMode() === bitsy.TXT_LOREZ ? 1 : 2;
	}

	function relativeFontWidth() {
		return Math.ceil(font.getWidth() / getTextScale());
	}

	function relativeFontHeight() {
		return Math.ceil(font.getHeight() / getTextScale());
	}

	this.ClearTextbox = function() {
		bitsy.fill(bitsy.TEXTBOX, textBackgroundIndex);
	};

	var isCentered = false;
	this.SetCentered = function(centered) {
		isCentered = centered;
	};

	// todo : I can stop doing this every frame right?
	this.DrawTextbox = function() {
		if (isCentered) {
			// todo : will the height calculations always work?
			bitsy.textbox(true, textboxInfo.left, ((bitsy.VIDEO_SIZE / 2) - (textboxInfo.height / 2)));
		}
		else if (player().y < (bitsy.MAP_SIZE / 2)) {
			// bottom
			bitsy.textbox(true, textboxInfo.left, (bitsy.VIDEO_SIZE - textboxInfo.bottom - textboxInfo.height));
		}
		else {
			// top
			bitsy.textbox(true, textboxInfo.left, textboxInfo.top);
		}
	};

	var arrowdata = [
		1,1,1,1,1,
		0,1,1,1,0,
		0,0,1,0,0
	];

	this.DrawNextArrow = function() {
		// bitsy.log("draw arrow!");
		var text_scale = getTextScale();
		var textboxScaleW = textboxInfo.width * text_scale;
		var textboxScaleH = textboxInfo.height * text_scale;

		var top = (textboxInfo.height - 5) * text_scale;
		var left = (textboxInfo.width - (5 + 4)) * text_scale;
		if (textDirection === TextDirection.RightToLeft) { // RTL hack
			left = 4 * text_scale;
		}

		for (var y = 0; y < 3; y++) {
			for (var x = 0; x < 5; x++) {
				var i = (y * 5) + x;
				if (arrowdata[i] == 1) {
					//scaling nonsense
					for (var sy = 0; sy < text_scale; sy++) {
						for (var sx = 0; sx < text_scale; sx++) {
							var px = left + (x * text_scale) + sx;
							var py = top + (y * text_scale) + sy;
							bitsy.set(bitsy.TEXTBOX, (py * textboxScaleW) + px, textArrowIndex);
						}
					}
				}
			}
		}
	};

	function drawCharData(charData, textScale, top, left, width, height, color) {
		for (var y = 0; y < height; y++) {
			for (var x = 0; x < width; x++) {
				var i = (y * width) + x;
				if (charData[i] == 1) {
					bitsy.set(bitsy.TEXTBOX, ((top + y) * (textboxInfo.width * textScale)) + (left + x), color);
				}
			}
		}
	}

	this.DrawChar = function(char, row, col, leftPos) {
		// characters with effects need to be redrawn every frame
		if (char.effectList.length > 0) {
			char.redraw = true;
		}

		// skip characters that are already drawn and don't need to be updated
		if (!char.redraw) {
			return;
		}
		char.redraw = false;

		var text_scale = getTextScale();
		var charData = char.bitmap;
		var top;
		var left;

		if (char.effectList.length > 0) {
			// clear the pixels from the previous frame
			top = (4 * text_scale) + (row * 2 * text_scale) + (row * font.getHeight()) + Math.floor(char.offset.y);
			left = (4 * text_scale) + leftPos + Math.floor(char.offset.x);
			drawCharData(charData, text_scale, top, left, char.width, char.height, textBackgroundIndex);
		}

		// compute render offset *every* frame
		char.offset = {
			x: char.base_offset.x,
			y: char.base_offset.y
		};
		char.SetPosition(row, col);
		char.ApplyEffects(effectTime);

		top = (4 * text_scale) + (row * 2 * text_scale) + (row * font.getHeight()) + Math.floor(char.offset.y);
		left = (4 * text_scale) + leftPos + Math.floor(char.offset.x);

		drawCharData(charData, text_scale, top, left, char.width, char.height, char.color);

		// TODO : consider for a future update?
		/*
		if (soundPlayer && char.blip && char.hasPlayedBlip != true) {
			soundPlayer.playBlip(blip[char.blip], { isPitchRandomized: true });
			char.hasPlayedBlip = true;
		}
		*/

		// call printHandler for character
		if (!disableOnPrintHandlers) {
			char.OnPrint();
		}
	};

	var effectTime = 0; // TODO this variable should live somewhere better

	var shouldUpdateTextboxSettings = true;
	var shouldClearTextbox = true;
	var shouldDrawArrow = true;

	var disableOnPrintHandlers = false;

	this.Draw = function(buffer, dt, disableOnPrint) {
		disableOnPrintHandlers = (disableOnPrint === true);

		// bitsy.log("draw dialog");
		if (buffer.DidFlipPageThisFrame()) {
			shouldClearTextbox = true;
			shouldDrawArrow = true;
		}

		effectTime += dt;

		if (shouldUpdateTextboxSettings) {
			bitsy.log("draw textbox");
			this.DrawTextbox(); // todo : rename to something more accurate
			shouldUpdateTextboxSettings = false;
		}

		if (shouldClearTextbox) {
			// bitsy.log("clear textbox");
			this.ClearTextbox();
			shouldClearTextbox = false;
		}

		// bitsy.log("draw chars");
		buffer.ForEachActiveChar(this.DrawChar);

		if (buffer.CanContinue() && shouldDrawArrow) {
			// bitsy.log("draw next arrow");
			this.DrawNextArrow();
			shouldDrawArrow = false;
		}

		if (buffer.DidPageFinishThisFrame() && onPageFinish != null) {
			bitsy.log("page finished");
			onPageFinish();
		}

		// bitsy.log("draw dialog end");
	};

	/* this is a hook for GIF rendering */
	var onPageFinish = null;
	this.SetPageFinishHandler = function(handler) {
		onPageFinish = handler;
	};

	this.Reset = function() {
		effectTime = 0;
		// TODO - anything else?

		shouldUpdateTextboxSettings = true;
		shouldClearTextbox = true;
		shouldDrawArrow = true;
	}

	this.updateTextboxPosition = function() {
		shouldUpdateTextboxSettings = true;
	};

	// this.CharsPerRow = function() {
	// 	return textboxInfo.charsPerRow;
	// }
}

var DialogBuffer = function() {
	var buffer = [[[]]]; // holds dialog in an array buffer
	var pageIndex = 0;
	var rowIndex = 0;
	var charIndex = 0;
	var nextCharTimer = 0;
	var nextCharMaxTime = 50; // in milliseconds
	var isDialogReadyToContinue = false;
	var activeTextEffects = [];
	var activeTextEffectParameters = [];
	var font = null;
	var arabicHandler = new ArabicHandler();
	var onDialogEndCallbacks = [];

	this.SetFont = function(f) {
		font = f;
	};

	this.SetPixelsPerRow = function(n) {
		pixelsPerRow = n;
	};

	this.CurPage = function() { return buffer[ pageIndex ]; };
	this.CurRow = function() { return this.CurPage()[ rowIndex ]; };
	this.CurChar = function() { return this.CurRow()[ charIndex ]; };
	this.CurPageCount = function() { return buffer.length; };
	this.CurRowCount = function() { return this.CurPage().length; };
	this.CurCharCount = function() { return this.CurRow().length; };

	this.ForEachActiveChar = function(handler) { // Iterates over visible characters on the active page
		var rowCount = rowIndex + 1;
		for (var i = 0; i < rowCount; i++) {
			var row = this.CurPage()[i];
			var charCount = (i == rowIndex) ? charIndex+1 : row.length;
			// bitsy.log(charCount);

			var leftPos = 0;
			if (textDirection === TextDirection.RightToLeft) {
				leftPos = 24 * 8; // hack -- I think this is correct?
			}

			for(var j = 0; j < charCount; j++) {
				var char = row[j];
				if(char) {
					if (textDirection === TextDirection.RightToLeft) {
						leftPos -= char.spacing;
					}
					// bitsy.log(j + " " + leftPos);

					// handler( char, i /*rowIndex*/, j /*colIndex*/ );
					handler(char, i /*rowIndex*/, j /*colIndex*/, leftPos)

					if (textDirection === TextDirection.LeftToRight) {
						leftPos += char.spacing;
					}
				}
			}
		}
	}

	this.Reset = function() {
		buffer = [[[]]];
		pageIndex = 0;
		rowIndex = 0;
		charIndex = 0;
		isDialogReadyToContinue = false;

		afterManualPagebreak = false;

		activeTextEffects = [];

		onDialogEndCallbacks = [];

		isActive = false;
	};

	this.DoNextChar = function() {
		nextCharTimer = 0; //reset timer

		//time to update characters
		if (charIndex + 1 < this.CurCharCount()) {
			//add char to current row
			charIndex++;
		}
		else if (rowIndex + 1 < this.CurRowCount()) {
			//start next row
			rowIndex++;
			charIndex = 0;
		}
		else {
			//the page is full!
			isDialogReadyToContinue = true;
			didPageFinishThisFrame = true;
		}

		if (this.CurChar() != null) {
			if (this.CurChar().isPageBreak) {
				// special case for page break marker character!
				isDialogReadyToContinue = true;
				didPageFinishThisFrame = true;
			}
			
			this.CurChar().OnPrint(); // make sure we hit the callback before we run out of text
		}
	};

	this.Update = function(dt) {
		didPageFinishThisFrame = false;
		didFlipPageThisFrame = false;
		// this.Draw(dt); // TODO move into a renderer object
		if (isDialogReadyToContinue) {
			return; //waiting for dialog to be advanced by player
		}

		nextCharTimer += dt; //tick timer

		if (nextCharTimer > nextCharMaxTime) {
			this.DoNextChar();
		}
	};

	var isSkipping = false;

	this.Skip = function() {
		bitsy.log("SKIPPP");
		isSkipping = true;

		didPageFinishThisFrame = false;
		didFlipPageThisFrame = false;

		// add new characters until you get to the end of the current line of dialog
		while (rowIndex < this.CurRowCount() && isSkipping) {
			this.DoNextChar();

			if (isDialogReadyToContinue) {
				//make sure to push the rowIndex past the end to break out of the loop
				rowIndex++;
				charIndex = 0;
			}
		}

		if (isSkipping) {
			rowIndex = this.CurRowCount() - 1;
			charIndex = this.CurCharCount() - 1;
		}

		isSkipping = false;
	};

	this.tryInterruptSkip = function() {
		if (isSkipping) {
			isSkipping = false;
			return true;
		}

		return false;
	};

	this.FlipPage = function() {
		didFlipPageThisFrame = true;
		isDialogReadyToContinue = false;
		pageIndex++;
		rowIndex = 0;
		charIndex = 0;
	}

	this.EndDialog = function() {
		isActive = false; // no more text to show... this should be a sign to stop rendering dialog

		for (var i = 0; i < onDialogEndCallbacks.length; i++) {
			onDialogEndCallbacks[i]();
		}
	}

	var afterManualPagebreak = false; // is it bad to track this state like this?

	this.Continue = function() {
		bitsy.log("CONTINUE");

		// if we used a page break character to continue we need
		// to run whatever is in the script afterwards! // TODO : make this comment better
		if (this.CurChar().isPageBreak) {
			// hacky: always treat a page break as the end of dialog
			// if there's more dialog later we re-activate the dialog buffer
			this.EndDialog();
			afterManualPagebreak = true;
			this.CurChar().OnContinue();
			return false;
		}
		if (pageIndex + 1 < this.CurPageCount()) {
			bitsy.log("FLIP PAGE!");
			//start next page
			this.FlipPage();
			return true; /* hasMoreDialog */
		}
		else {
			bitsy.log("END DIALOG!");
			bitsy.textbox(false);
			//end dialog mode
			this.EndDialog();
			return false; /* hasMoreDialog */
		}
	};

	var isActive = false;
	this.IsActive = function() { return isActive; };

	this.OnDialogEnd = function(callback) {
		if (!isActive) {
			callback();
		}
		else {
			onDialogEndCallbacks.push(callback);
		}
	}

	this.CanContinue = function() { return isDialogReadyToContinue; };

	function DialogChar() {
		this.redraw = true;

		this.effectList = [];
		this.effectParameterList = [];

		this.color = textColorIndex; // white
		this.offset = { x:0, y:0 }; // in pixels (screen pixels?)

		this.col = 0;
		this.row = 0;

		this.SetPosition = function(row,col) {
			// bitsy.log("SET POS");
			// bitsy.log(this);
			this.row = row;
			this.col = col;
		};

		this.ApplyEffects = function(time) {
			// bitsy.log("APPLY EFFECTS! " + time);
			for (var i = 0; i < this.effectList.length; i++) {
				var effectName = this.effectList[i];
				// bitsy.log("FX " + effectName);
				TextEffects[effectName].doEffect(this, time, this.effectParameterList[i]);
			}
		};

		var printHandler = null; // optional function to be called once on printing character
		this.SetPrintHandler = function(handler) {
			printHandler = handler;
		};
		this.OnPrint = function() {
			if (printHandler != null) {
				// bitsy.log("PRINT HANDLER ---- DIALOG BUFFER");
				printHandler();
				printHandler = null; // only call handler once (hacky)
			}
		};

		this.bitmap = [];
		this.width = 0;
		this.height = 0;
		this.base_offset = { // hacky name
 			x: 0,
			y: 0
		};
		this.spacing = 0;
	}

	function DialogFontChar(font, char, effectList, effectParameterList) {
		DialogChar.call(this);

		this.effectList = effectList.slice(); // clone effect list (since it can change between chars)
		this.effectParameterList = effectParameterList.slice();

		var charData = font.getChar(char);
		this.char = char;
		this.bitmap = charData.data;
		this.width = charData.width;
		this.height = charData.height;
		this.base_offset.x = charData.offset.x;
		this.base_offset.y = charData.offset.y;
		this.spacing = charData.spacing;
		this.blip = null;
		this.hasPlayedBlip = false;
	}

	function DialogDrawingChar(drawingId, effectList, effectParameterList) {
		DialogChar.call(this);

		this.effectList = effectList.slice(); // clone effect list (since it can change between chars)
		this.effectParameterList = effectParameterList.slice();

		// get the first frame of the drawing and flatten it
		var drawingData = renderer.GetDrawingSource(drawingId)[0];
		var drawingDataFlat = [];
		for (var i = 0; i < drawingData.length; i++) {
			drawingDataFlat = drawingDataFlat.concat(drawingData[i]);
		}

		this.bitmap = drawingDataFlat;
		this.width = 8;
		this.height = 8;
		this.spacing = 8;
	}

	function DialogScriptControlChar() {
		DialogChar.call(this);

		this.width = 0;
		this.height = 0;
		this.spacing = 0;
	}

	// is a control character really the best way to handle page breaks?
	function DialogPageBreakChar() {
		DialogChar.call(this);

		this.width = 0;
		this.height = 0;
		this.spacing = 0;

		this.isPageBreak = true;

		var continueHandler = null;

		this.SetContinueHandler = function(handler) {
			continueHandler = handler;
		};

		this.OnContinue = function() {
			if (continueHandler) {
				continueHandler();
			}
		};
	}

	function AddWordToCharArray(charArray, word, effectList, effectParameterList) {
		// bitsy.log("add char array");
		for (var i = 0; i < word.length; i++) {
			charArray.push(new DialogFontChar(font, word[i], effectList, effectParameterList));
		}
		// bitsy.log("add char array end");
		return charArray;
	}

	function GetCharArrayWidth(charArray) {
		var width = 0;
		for(var i = 0; i < charArray.length; i++) {
			width += charArray[i].spacing;
		}
		return width;
	}

	function GetStringWidth(str) {
		var width = 0;
		for (var i = 0; i < str.length; i++) {
			var charData = font.getChar(str[i]);
			width += charData.spacing;
		}
		return width;
	}

	var pixelsPerRow = 192; // hard-coded fun times!!!

	this.AddScriptReturn = function(onReturnHandler) {
		var curPageIndex = buffer.length - 1;
		var curRowIndex = buffer[curPageIndex].length - 1;
		var curRowArr = buffer[curPageIndex][curRowIndex];

		var controlChar = new DialogScriptControlChar();
		controlChar.SetPrintHandler(onReturnHandler);

		curRowArr.push(controlChar);

		isActive = true;
	}

	this.AddDrawing = function(drawingId) {
		// bitsy.log("DRAWING ID " + drawingId);

		var curPageIndex = buffer.length - 1;
		var curRowIndex = buffer[curPageIndex].length - 1;
		var curRowArr = buffer[curPageIndex][curRowIndex];

		var drawingChar = new DialogDrawingChar(drawingId, activeTextEffects, activeTextEffectParameters);

		var rowLength = GetCharArrayWidth(curRowArr);

		// TODO : clean up copy-pasted code here :/
		if (afterManualPagebreak) {
			this.FlipPage(); // hacky

			buffer[curPageIndex][curRowIndex] = curRowArr;
			buffer.push([]);
			curPageIndex++;
			buffer[curPageIndex].push([]);
			curRowIndex = 0;
			curRowArr = buffer[curPageIndex][curRowIndex];
			curRowArr.push(drawingChar);

			afterManualPagebreak = false;
		}
		else if (rowLength + drawingChar.spacing  <= pixelsPerRow || rowLength <= 0) {
			//stay on same row
			curRowArr.push(drawingChar);
		}
		else if (curRowIndex == 0) {
			//start next row
			buffer[curPageIndex][curRowIndex] = curRowArr;
			buffer[curPageIndex].push([]);
			curRowIndex++;
			curRowArr = buffer[curPageIndex][curRowIndex];
			curRowArr.push(drawingChar);
		}
		else {
			//start next page
			buffer[curPageIndex][curRowIndex] = curRowArr;
			buffer.push([]);
			curPageIndex++;
			buffer[curPageIndex].push([]);
			curRowIndex = 0;
			curRowArr = buffer[curPageIndex][curRowIndex];
			curRowArr.push(drawingChar);
		}

		isActive = true; // this feels like a bad way to do this???
	}

	// TODO : convert this into something that takes DialogChar arrays
	this.AddText = function(textStr) {
		bitsy.log("ADD TEXT >>" + textStr + "<<");

		//process dialog so it's easier to display
		var words = textStr.split(" ");

		// var curPageIndex = this.CurPageCount() - 1;
		// var curRowIndex = this.CurRowCount() - 1;
		// var curRowArr = this.CurRow();

		var curPageIndex = buffer.length - 1;
		var curRowIndex = buffer[curPageIndex].length - 1;
		var curRowArr = buffer[curPageIndex][curRowIndex];

		for (var i = 0; i < words.length; i++) {
			var word = words[i];
			if (arabicHandler.ContainsArabicCharacters(word)) {
				word = arabicHandler.ShapeArabicCharacters(word);
			}

			var wordWithPrecedingSpace = ((i == 0) ? "" : " ") + word;
			var wordLength = GetStringWidth(wordWithPrecedingSpace);

			var rowLength = GetCharArrayWidth(curRowArr);

			if (afterManualPagebreak) {
				this.FlipPage();

				// hacky copied bit for page breaks
				buffer[curPageIndex][curRowIndex] = curRowArr;
				buffer.push([]);
				curPageIndex++;
				buffer[curPageIndex].push([]);
				curRowIndex = 0;
				curRowArr = buffer[curPageIndex][curRowIndex];
				curRowArr = AddWordToCharArray(curRowArr, word, activeTextEffects, activeTextEffectParameters);

				afterManualPagebreak = false;
			}
			else if (rowLength + wordLength <= pixelsPerRow || rowLength <= 0) {
				//stay on same row
				curRowArr = AddWordToCharArray(curRowArr, wordWithPrecedingSpace, activeTextEffects, activeTextEffectParameters);
			}
			else if (curRowIndex == 0) {
				//start next row
				buffer[curPageIndex][curRowIndex] = curRowArr;
				buffer[curPageIndex].push([]);
				curRowIndex++;
				curRowArr = buffer[curPageIndex][curRowIndex];
				curRowArr = AddWordToCharArray(curRowArr, word, activeTextEffects, activeTextEffectParameters);
			}
			else {
				//start next page
				buffer[curPageIndex][curRowIndex] = curRowArr;
				buffer.push([]);
				curPageIndex++;
				buffer[curPageIndex].push([]);
				curRowIndex = 0;
				curRowArr = buffer[curPageIndex][curRowIndex];
				curRowArr = AddWordToCharArray(curRowArr, word, activeTextEffects, activeTextEffectParameters);
			}
		}

		//destroy any empty stuff
		var lastPage = buffer[buffer.length-1];
		var lastRow = lastPage[lastPage.length-1];
		if (lastRow.length == 0) {
			lastPage.splice(lastPage.length-1, 1);
		}
		if (lastPage.length == 0) {
			buffer.splice(buffer.length-1, 1);
		}

		//finish up 
		lastPage = buffer[buffer.length-1];
		lastRow = lastPage[lastPage.length-1];
		if (lastRow.length > 0) {
			var lastChar = lastRow[lastRow.length-1];
		}

		// bitsy.log(buffer);

		bitsy.log("add text finished");

		isActive = true;
	};

	this.AddLinebreak = function() {
		var lastPage = buffer[buffer.length-1];
		if (lastPage.length <= 1) {
			// bitsy.log("LINEBREAK - NEW ROW ");
			// add new row
			lastPage.push([]);
		}
		else {
			// add new page
			buffer.push([[]]);
		}
		// bitsy.log(buffer);

		isActive = true;
	}

	this.AddPagebreak = function(onReturnHandler) {
		var curPageIndex = buffer.length - 1;
		var curRowIndex = buffer[curPageIndex].length - 1;
		var curRowArr = buffer[curPageIndex][curRowIndex];

		// need to actually create a whole new page if following another pagebreak character
		if (afterManualPagebreak) {
			this.FlipPage(); // hacky

			buffer[curPageIndex][curRowIndex] = curRowArr;
			buffer.push([]);
			curPageIndex++;
			buffer[curPageIndex].push([]);
			curRowIndex = 0;
			curRowArr = buffer[curPageIndex][curRowIndex];

			afterManualPagebreak = false;
		}

		var pagebreakChar = new DialogPageBreakChar();
		pagebreakChar.SetContinueHandler(onReturnHandler);

		curRowArr.push(pagebreakChar);

		isActive = true;
	}

	this.hasTextEffect = function(name) {
		return activeTextEffects.indexOf(name) != -1;
	};

	this.pushTextEffect = function(name, parameters) {
		activeTextEffects.push(name);
		activeTextEffectParameters.push(parameters);
	};

	this.popTextEffect = function(name) {
		var i = activeTextEffects.lastIndexOf(name);
		activeTextEffects.splice(i, 1);
		activeTextEffectParameters.splice(i, 1);
	};

	/* this is a hook for GIF rendering */
	var didPageFinishThisFrame = false;
	this.DidPageFinishThisFrame = function(){ return didPageFinishThisFrame; };

	var didFlipPageThisFrame = false;
	this.DidFlipPageThisFrame = function(){ return didFlipPageThisFrame; };

	// this.SetCharsPerRow = function(num){ charsPerRow = num; }; // hacky
};

/* ARABIC */
var ArabicHandler = function() {

	var arabicCharStart = 0x0621;
	var arabicCharEnd = 0x064E;

	var CharacterForm = {
		Isolated : 0,
		Final : 1,
		Initial : 2,
		Middle : 3
	};

	// map glyphs to their character forms
	var glyphForms = {
		/*		 Isolated, Final, Initial, Middle Forms	*/
		0x0621: [0xFE80,0xFE80,0xFE80,0xFE80], /*  HAMZA  */ 
		0x0622: [0xFE81,0xFE82,0xFE81,0xFE82], /*  ALEF WITH MADDA ABOVE  */ 
		0x0623: [0xFE83,0xFE84,0xFE83,0xFE84], /*  ALEF WITH HAMZA ABOVE  */ 
		0x0624: [0xFE85,0xFE86,0xFE85,0xFE86], /*  WAW WITH HAMZA ABOVE  */ 
		0x0625: [0xFE87,0xFE88,0xFE87,0xFE88], /*  ALEF WITH HAMZA BELOW  */ 
		0x0626: [0xFE89,0xFE8A,0xFE8B,0xFE8C], /*  YEH WITH HAMZA ABOVE  */ 
		0x0627: [0xFE8D,0xFE8E,0xFE8D,0xFE8E], /*  ALEF  */ 
		0x0628: [0xFE8F,0xFE90,0xFE91,0xFE92], /*  BEH  */ 
		0x0629: [0xFE93,0xFE94,0xFE93,0xFE94], /*  TEH MARBUTA  */ 
		0x062A: [0xFE95,0xFE96,0xFE97,0xFE98], /*  TEH  */ 
		0x062B: [0xFE99,0xFE9A,0xFE9B,0xFE9C], /*  THEH  */ 
		0x062C: [0xFE9D,0xFE9E,0xFE9F,0xFEA0], /*  JEEM  */ 
		0x062D: [0xFEA1,0xFEA2,0xFEA3,0xFEA4], /*  HAH  */ 
		0x062E: [0xFEA5,0xFEA6,0xFEA7,0xFEA8], /*  KHAH  */ 
		0x062F: [0xFEA9,0xFEAA,0xFEA9,0xFEAA], /*  DAL  */ 
		0x0630: [0xFEAB,0xFEAC,0xFEAB,0xFEAC], /*  THAL */ 
		0x0631: [0xFEAD,0xFEAE,0xFEAD,0xFEAE], /*  RAA  */ 
		0x0632: [0xFEAF,0xFEB0,0xFEAF,0xFEB0], /*  ZAIN  */ 
		0x0633: [0xFEB1,0xFEB2,0xFEB3,0xFEB4], /*  SEEN  */ 
		0x0634: [0xFEB5,0xFEB6,0xFEB7,0xFEB8], /*  SHEEN  */ 
		0x0635: [0xFEB9,0xFEBA,0xFEBB,0xFEBC], /*  SAD  */ 
		0x0636: [0xFEBD,0xFEBE,0xFEBF,0xFEC0], /*  DAD  */ 
		0x0637: [0xFEC1,0xFEC2,0xFEC3,0xFEC4], /*  TAH  */ 
		0x0638: [0xFEC5,0xFEC6,0xFEC7,0xFEC8], /*  ZAH  */ 
		0x0639: [0xFEC9,0xFECA,0xFECB,0xFECC], /*  AIN  */ 
		0x063A: [0xFECD,0xFECE,0xFECF,0xFED0], /*  GHAIN  */ 
		0x063B: [0x0000,0x0000,0x0000,0x0000], /*  space */
		0x063C: [0x0000,0x0000,0x0000,0x0000], /*  space */
		0x063D: [0x0000,0x0000,0x0000,0x0000], /*  space */
		0x063E: [0x0000,0x0000,0x0000,0x0000], /*  space */
		0x063F: [0x0000,0x0000,0x0000,0x0000], /*  space */
		0x0640: [0x0640,0x0640,0x0640,0x0640], /*  TATWEEL  */ 
		0x0641: [0xFED1,0xFED2,0xFED3,0xFED4], /*  FAA  */ 
		0x0642: [0xFED5,0xFED6,0xFED7,0xFED8], /*  QAF  */ 
		0x0643: [0xFED9,0xFEDA,0xFEDB,0xFEDC], /*  KAF  */ 
		0x0644: [0xFEDD,0xFEDE,0xFEDF,0xFEE0], /*  LAM  */ 
		0x0645: [0xFEE1,0xFEE2,0xFEE3,0xFEE4], /*  MEEM  */ 
		0x0646: [0xFEE5,0xFEE6,0xFEE7,0xFEE8], /*  NOON  */ 
		0x0647: [0xFEE9,0xFEEA,0xFEEB,0xFEEC], /*  HEH  */ 
		0x0648: [0xFEED,0xFEEE,0xFEED,0xFEEE], /*  WAW  */ 
		0x0649: [0xFEEF,0xFEF0,0xFBE8,0xFBE9], /*  ALEF MAKSURA  */ 
		0x064A: [0xFEF1,0xFEF2,0xFEF3,0xFEF4], /*  YEH  */ 
		0x064B: [0xFEF5,0xFEF6,0xFEF5,0xFEF6], /*  LAM ALEF MADD*/
		0x064C: [0xFEF7,0xFEF8,0xFEF7,0xFEF8], /*  LAM ALEF HAMZA ABOVE*/
		0x064D: [0xFEF9,0xFEFa,0xFEF9,0xFEFa], /*  LAM ALEF HAMZA BELOW*/
		0x064E: [0xFEFb,0xFEFc,0xFEFb,0xFEFc], /*  LAM ALEF */
	};

	var disconnectedCharacters = [0x0621,0x0622,0x0623,0x0624,0x0625,0x0627,0x062f,0x0630,0x0631,0x0632,0x0648,0x0649,0x064b,0x064c,0x064d,0x064e];

	function IsArabicCharacter(char) {
		var code = char.charCodeAt(0);
		return (code >= arabicCharStart && code <= arabicCharEnd);
	}

	function ContainsArabicCharacters(word) {
		for (var i = 0; i < word.length; i++) {
			if (IsArabicCharacter(word[i])) {
				return true;
			}
		}
		return false;
	}

	function IsDisconnectedCharacter(char) {
		var code = char.charCodeAt(0);
		return disconnectedCharacters.indexOf(code) != -1;
	}

	function ShapeArabicCharacters(word) {
		var shapedWord = "";

		for (var i = 0; i < word.length; i++) {
			if (!IsArabicCharacter(word[i])) {
				shapedWord += word[i];
				continue;
			}

			var connectedToPreviousChar = i-1 >= 0 && IsArabicCharacter(word[i-1]) && !IsDisconnectedCharacter(word[i-1]);

			var connectedToNextChar = i+1 < word.length && IsArabicCharacter(word[i+1]) && !IsDisconnectedCharacter(word[i]);

			var form;
			if (!connectedToPreviousChar && !connectedToNextChar) {
				form = CharacterForm.Isolated;
			}
			else if (connectedToPreviousChar && !connectedToNextChar) {
				form = CharacterForm.Final;
			}
			else if (!connectedToPreviousChar && connectedToNextChar) {
				form = CharacterForm.Initial;
			}
			else if (connectedToPreviousChar && connectedToNextChar) {
				form = CharacterForm.Middle;
			}

			var code = word[i].charCodeAt(0);

			// handle lam alef special case
			if (code == 0x0644 && connectedToNextChar) {
				var nextCode = word[i+1].charCodeAt(0);
				var specialCode = null;
				if (nextCode == 0x0622) {
					// alef madd
					specialCode = glyphForms[0x064b][form];
				}
				else if (nextCode == 0x0623) {
					// hamza above
					specialCode = glyphForms[0x064c][form];
				}
				else if (nextCode == 0x0625) {
					// hamza below
					specialCode = glyphForms[0x064d][form];
				}
				else if (nextCode == 0x0627) {
					// alef
					specialCode = glyphForms[0x064e][form];
				}

				if (specialCode != null) {
					shapedWord += String.fromCharCode(specialCode);
					i++; // skip a step
					continue;
				}
			}

			// hacky?
			if (form === CharacterForm.Isolated) {
				shapedWord += word[i];
				continue;
			}

			var shapedCode = glyphForms[code][form];
			shapedWord += String.fromCharCode(shapedCode);
		}

		return shapedWord;
	}

	this.ContainsArabicCharacters = ContainsArabicCharacters;
	this.ShapeArabicCharacters = ShapeArabicCharacters;
}

/* TEXT EFFECTS */
var TextEffects = {};

function RainbowEffect() {
	function positiveModulo(number, divisor) {
		return ((number % divisor) + divisor) % divisor;
	}

	this.doEffect = function(char, time, parameters) {
		char.color = rainbowColorStartIndex + Math.floor(positiveModulo((time / 100) - char.col * 0.5, rainbowColorCount));
	};
}

TextEffects["rbw"] = new RainbowEffect();

function ColorEffect(index) {
	this.doEffect = function(char, time, parameters) {
		if (parameters && parameters.length > 0) {
			char.color = tileColorStartIndex + parameters[0];
		}
		else {
			char.color = tileColorStartIndex + index;
		}
	};
}

TextEffects["clr"] = new ColorEffect();
TextEffects["clr1"] = new ColorEffect(0);
TextEffects["clr2"] = new ColorEffect(1);
TextEffects["clr3"] = new ColorEffect(2);

function WavyEffect() {
	this.doEffect = function(char, time, parameters) {
		char.offset.y += Math.sin((time / 250) - (char.col / 2)) * 2;
	};
}

TextEffects["wvy"] = new WavyEffect();

function ShakyEffect() {
	function disturb(func, time, offset, mult1, mult2) {
		return func((time * mult1) - (offset * mult2));
	}

	this.doEffect = function(char, time, parameters) {
		char.offset.y += 1.5
						* disturb(Math.sin, time, char.col, 0.1, 0.5)
						* disturb(Math.cos, time, char.col, 0.3, 0.2)
						* disturb(Math.sin, time, char.row, 2.0, 1.0);
		char.offset.x += 1.5
						* disturb(Math.cos, time, char.row, 0.1, 1.0)
						* disturb(Math.sin, time, char.col, 3.0, 0.7)
						* disturb(Math.cos, time, char.col, 0.2, 0.3);
	};
}

TextEffects["shk"] = new ShakyEffect();

/*
// TODO : maybe use this in a future update?
function YakEffect() {
	this.doEffect = function(char, time, parameters) {
		if (char.char != " ") {
			char.blip = parameters[0];
		}
	};
}

TextEffects["yak"] = new YakEffect();
*/

var DebugHighlightEffect = function() {
	this.doEffect = function(char, time, parameters) {
		char.color = tileColorStartIndex;
	};
}

TextEffects["_debug_highlight"] = new DebugHighlightEffect();

} // Dialog()
</script>

<script>
function TileRenderer(debugName) {
bitsy.log("!!!!! NEW TILE RENDERER: " + debugName);

var drawingCache = {
	source: {},
	render: {},
};

// var debugRenderCount = 0;

function createRenderCacheId(drawingId, colorIndex) {
	return drawingId + "_" + colorIndex;
}

function renderDrawing(drawing) {
	// debugRenderCount++;
	// bitsy.log("RENDER COUNT " + debugRenderCount);

	var col = drawing.col;
	var bgc = drawing.bgc;
	var drwId = drawing.drw;
	var drawingFrames = drawingCache.source[drwId];

	// initialize render cache entry
	var cacheId = createRenderCacheId(drwId, col);
	if (drawingCache.render[cacheId] === undefined) {
		// initialize array of frames for drawing
		drawingCache.render[cacheId] = [];
	}

	for (var i = 0; i < drawingFrames.length; i++) {
		var frameData = drawingFrames[i];
		var frameTileId = renderTileFromDrawingData(frameData, col, bgc);
		drawingCache.render[cacheId].push(frameTileId);
	}
}

function renderTileFromDrawingData(drawingData, col, bgc) {
	var tileId = bitsy.tile();

	var backgroundColor = tileColorStartIndex + bgc;
	var foregroundColor = tileColorStartIndex + col;

	bitsy.fill(tileId, backgroundColor);

	for (var y = 0; y < bitsy.TILE_SIZE; y++) {
		for (var x = 0; x < bitsy.TILE_SIZE; x++) {
			var px = drawingData[y][x];
			if (px === 1) {
				bitsy.set(tileId, (y * bitsy.TILE_SIZE) + x, foregroundColor);
			}
		}
	}

	return tileId;
}

// TODO : move into core
function undefinedOrNull(x) {
	return x === undefined || x === null;
}

function isDrawingRendered(drawing) {
	var cacheId = createRenderCacheId(drawing.drw, drawing.col);
	return drawingCache.render[cacheId] != undefined;
}

function getRenderedDrawingFrames(drawing) {
	var cacheId = createRenderCacheId(drawing.drw, drawing.col);
	return drawingCache.render[cacheId];
}

function getDrawingFrameTileId(drawing, frameOverride) {
	var frameIndex = 0;

	if (drawing != null && drawing.animation.isAnimated) {
		if (frameOverride != undefined && frameOverride != null) {
			frameIndex = frameOverride;
		}
		else {
			frameIndex = drawing.animation.frameIndex;
		}
	}

	return getRenderedDrawingFrames(drawing)[frameIndex];
}

function getOrRenderDrawingFrame(drawing, frameOverride) {
	// bitsy.log("frame render: " + drawing.type + " " + drawing.id + " f:" + frameOverride);

	if (!isDrawingRendered(drawing)) {
		bitsy.log("frame render: doesn't exist " + drawing.id);
		renderDrawing(drawing);
	}

	return getDrawingFrameTileId(drawing, frameOverride);
}

function deleteRenders(drawingId) {
	for (var cacheId in drawingCache.render) {
		if (cacheId.indexOf(drawingId) === 0) {
			var tiles = drawingCache.render[cacheId];
			for (var i = 0; i < tiles.length; i++) {
				bitsy.delete(tiles[i]);
			}
			delete drawingCache.render[cacheId];
		}
	}
}

/* PUBLIC INTERFACE */
this.GetDrawingFrame = getOrRenderDrawingFrame;

// todo : leave individual get and set stuff for now - should I remove later?
// todo : better name for function?
this.SetDrawings = function(drawingSource) {
	drawingCache.source = drawingSource;
	// need to reset entire render cache when all the drawings are changed
	drawingCache.render = {};
};

this.SetDrawingSource = function(drawingId, drawingData) {
	deleteRenders(drawingId);
	drawingCache.source[drawingId] = drawingData;
};

this.GetDrawingSource = function(drawingId) {
	return drawingCache.source[drawingId];
};

this.GetFrameCount = function(drawingId) {
	return drawingCache.source[drawingId].length;
};

// todo : forceReset option is hacky?
this.ClearCache = function(forceReset) {
	if (forceReset === undefined || forceReset === true) {
		// delete all tiles from system memory before clearing the cache
		for (var cacheId in drawingCache.render) {
			var tiles = drawingCache.render[cacheId];
			for (var i = 0; i < tiles.length; i++) {
				bitsy.delete(tiles[i]);
			}
		}
	}

	drawingCache.render = {};
};

this.deleteDrawing = deleteRenders;

} // Renderer()
</script>

<script>
/* WORLD DATA */
var room = {};
var tile = {};
var sprite = {};
var item = {};
var dialog = {};
var end = {}; // for backwards compatibility
var palette = { // start off with a default palette
		"default" : {
			name : "default",
			colors : [[0,0,0],[255,255,255],[255,255,255]]
		}
	};
var variable = {}; // these are starting variable values -- they don't update (or I don't think they will)
var tune = {};
var blip = {};
var playerId = "A";
var fontName = defaultFontName;
var textDirection = TextDirection.LeftToRight;

/* NAME-TO-ID MAPS */
var names = {
	room : {},
	tile : {},
	sprite : {},
	item : {},
	dialog : {},
	palette : {},
	tune : {},
	blip : {},
};

// todo : this is basically a copy of the one in world.js - can I remove it?
function updateNamesFromCurData() {

	function createNameMap(objectStore) {
		var map = {};

		for (id in objectStore) {
			if (objectStore[id].name != undefined && objectStore[id].name != null) {
				map[objectStore[id].name] = id;
			}
		}

		return map;
	}

	names.room = createNameMap(room);
	names.tile = createNameMap(tile);
	names.sprite = createNameMap(sprite);
	names.item = createNameMap(item);
	names.dialog = createNameMap(dialog);
	names.palette = createNameMap(palette);
	names.tune = createNameMap(tune);
	names.blip = createNameMap(blip);
}

/* GAME STATE */
var state = {}
function resetGameState() {
	state.room = "0";
	state.ava = playerId; // avatar appearance override
	state.pal = "0"; // current palette id
	state.tune = "0"; // current tune id ("0" === off)
	state.exits = []; // exits in current room
	state.endings = []; // endings in current room
}

// title helper functions
function getTitle() {
	return dialog[titleDialogId].src;
}
function setTitle(titleSrc) {
	dialog[titleDialogId] = { src:titleSrc, name:null };
}

/* FLAGS */
var flags = createDefaultFlags();

// feature flags for testing purposes
var engineFeatureFlags = {
	isSoundEnabled : true,
	isFontEnabled : true,
	isTransitionEnabled : true,
	isScriptEnabled : true,
	isDialogEnabled : true,
	isRendererEnabled : true,
};

function clearGameData() {
	room = {};
	tile = {};
	sprite = {};
	item = {};
	dialog = {};
	palette = { //start off with a default palette
		"default" : {
			name : "default",
			colors : [[0,0,0],[255,255,255],[255,255,255]]
		}
	};
	isEnding = false; //todo - correct place for this?
	variable = {};

	updateNamesFromCurData();

	fontName = defaultFontName; // TODO : reset font manager too?
	textDirection = TextDirection.LeftToRight;

	resetGameState();

	isGameLoaded = false;
	isGameOver = false;
}

// engine event hooks for the editor
var onInventoryChanged = null;
var onVariableChanged = null;
var onGameReset = null;
var onInitRoom = null;

var isPlayerEmbeddedInEditor = false;

var renderer;
if (engineFeatureFlags.isRendererEnabled) {
	renderer = new TileRenderer("bitsy");
}

var curGameData = null;
var curDefaultFontData = null;

var isGameLoaded = false;
var isGameOver = false;

function load_game(gameData, defaultFontData, startWithTitle) {
	// bitsy.log("game data in: \n" + gameData);

	curGameData = gameData; //remember the current game (used to reset the game)

	if (dialogBuffer) {
		dialogBuffer.Reset();
	}

	if (scriptInterpreter) {
		scriptInterpreter.ResetEnvironment(); // ensures variables are reset -- is this the best way?
	}

	loadWorldFromGameData(gameData);

	bitsy.log("world loaded");

	if (fontManager && !isPlayerEmbeddedInEditor && defaultFontData) {
		bitsy.log("load font");

		curDefaultFontData = defaultFontData; // store for resetting game

		// todo : consider replacing this with a more general system for requesting resources from the system?
		// hack to ensure default font is available
		fontManager.AddResource(defaultFontName + fontManager.GetExtension(), defaultFontData);

		bitsy.log("load font end");
	}

	// request text mode
	if (flags.TXT_MODE === 1) {
		bitsy.textMode(bitsy.TXT_LOREZ);
	}
	else {
		// default to 2x scale for text rendering
		bitsy.textMode(bitsy.TXT_HIREZ);
	}

	if (fontManager && dialogBuffer) {
		bitsy.log("get font");

		var font = fontManager.Get( fontName );
		dialogBuffer.SetFont(font);
		dialogRenderer.SetFont(font);

		bitsy.log("get font end");
	}

	if (dialogBuffer) {
		// this feels a little silly to me - oh well??
		dialogBuffer.SetPixelsPerRow(dialogRenderer.GetPixelsPerRow());
	}

	setInitialVariables();

	bitsy.log("ready");

	onready(startWithTitle);

	isGameLoaded = true;
}

function loadWorldFromGameData(gameData) {
	bitsy.log("load world from game data");

	var world = parseWorld(gameData);

	bitsy.log("parse world done");

	// move world data into global scope
	palette = world.palette;
	room = world.room;
	tile = world.tile;
	sprite = world.sprite;
	item = world.item;
	dialog = world.dialog;
	end = world.end; // back compat endings
	variable = world.variable;
	fontName = world.fontName;
	textDirection = world.textDirection;
	tune = world.tune;
	blip = world.blip;
	flags = world.flags;
	names = world.names;

	if (renderer) {
		renderer.SetDrawings(world.drawings);
	}

	// find starting room and initialize it
	var roomIds = Object.keys(room);

	if (player() != undefined && player().room != null && roomIds.indexOf(player().room) != -1) {
		// player has valid room
		state.room = player().room;
	}
	else if (roomIds.length > 0) {
		// player not in any room! what the heck
		state.room = roomIds[0];
	}
	else {
		// uh oh there are no rooms I guess???
		state.room = null;
	}

	if (state.room != null) {
		bitsy.log("INIT ROOM " + state.room);
		initRoom(state.room);
	}
}

function reset_cur_game() {
	if (curGameData == null) {
		return; //can't reset if we don't have the game data
	}

	stopGame();
	clearGameData();

	if (isPlayerEmbeddedInEditor && onGameReset != null) {
		onGameReset();
	}
}

function onready(startWithTitle) {
	bitsy.log("game ready!");

	if (startWithTitle === undefined || startWithTitle === null) {
		startWithTitle = true;
	}

	if (startWithTitle) { // used by editor 
		startNarrating(getTitle());
	}
}

function setInitialVariables() {
	if (!scriptInterpreter) {
		return;
	}

	for(id in variable) {
		var value = variable[id]; // default to string
		if(value === "true") {
			value = true;
		}
		else if(value === "false") {
			value = false;
		}
		else if(!isNaN(parseFloat(value))) {
			value = parseFloat(value);
		}
		scriptInterpreter.SetVariable(id,value);
	}
	scriptInterpreter.SetOnVariableChangeHandler( onVariableChanged );
}

function getOffset(evt) {
	var offset = { x:0, y:0 };

	var el = evt.target;
	var rect = el.getBoundingClientRect();

	offset.x += rect.left + el.scrollLeft;
	offset.y += rect.top + el.scrollTop;

	offset.x = evt.clientX - offset.x;
	offset.y = evt.clientY - offset.y;

	return offset;
}

function stopGame() {
	if (soundPlayer) {
		soundPlayer.stopTune();
	}
	bitsy.log("stop GAME!");
}

function update(dt) {
	if (!isGameLoaded) {
		load_game(bitsy.getGameData(), bitsy.getFontData());
	}

	if (state.room == null) {
		// in the special case where there is no valid room, end the game
		startNarrating( "", true /*isEnding*/ );
	}

	if (!transition || !transition.IsTransitionActive()) {
		updateInput();
	}

	if (transition && transition.IsTransitionActive()) {
		// transition animation takes over everything!
		transition.UpdateTransition(dt);
	}
	else {
		if (bitsy.graphicsMode() != bitsy.GFX_MAP) {
			bitsy.graphicsMode(bitsy.GFX_MAP);
		}

		if (soundPlayer) {
			soundPlayer.update(dt);
		}

		if (!isNarrating && !isEnding) {
			// draw world if game has begun
			var didAnimate = updateAnimation(dt);

			// test whether player moved so we can redraw just the avatar
			playerCurX = player().x;
			playerCurY = player().y;
			var didPlayerMove = (playerPrevX != playerCurX) || (playerPrevY != playerCurY);

			drawRoom(room[state.room], { redrawAnimated: didAnimate, redrawAvatar: didPlayerMove });

			// store player's position for next frame
			playerPrevX = playerCurX;
			playerPrevY = playerCurY;
		}
		else {
			clearRoom();
		}

		if (dialogBuffer && dialogBuffer.IsActive() && !(soundPlayer && soundPlayer.isBlipPlaying())) {
			// bitsy.log("update dialog");
			// bitsy.log("renderer");
			dialogRenderer.Draw(dialogBuffer, dt);
			// bitsy.log("buffer");
			dialogBuffer.Update(dt);
			// bitsy.log("update dialog end");
		}

		// keep moving avatar if player holds down button
		if ((!dialogBuffer || !dialogBuffer.IsActive()) && !isEnding) {
			if (curPlayerDirection != Direction.None) {
				playerHoldToMoveTimer -= dt;

				if (playerHoldToMoveTimer <= 0) {
					movePlayer(curPlayerDirection, false /* isFirstMove */);
					playerHoldToMoveTimer = 150;
					// playerHoldToMoveTimer = 16; // PERF TEST
				}
			}
		}
	}

	// clean up state if the game is ending
	if (isGameOver) {
		bitsy.log("game over");
		reset_cur_game();
	}

	return true;
}

var isAnyButtonHeld = false;
var isMenuButtonHeld = false;
var isIgnoringInput = false;

function isAnyButtonDown() {
	return bitsy.button(bitsy.BTN_UP) ||
		bitsy.button(bitsy.BTN_DOWN) ||
		bitsy.button(bitsy.BTN_LEFT) ||
		bitsy.button(bitsy.BTN_RIGHT) ||
		bitsy.button(bitsy.BTN_OK);
}

function updateInput() {
	if (dialogBuffer && dialogBuffer.IsActive()) {
		if (!(soundPlayer && soundPlayer.isBlipPlaying())) {
			if (!isAnyButtonHeld && isAnyButtonDown()) {
				/* CONTINUE DIALOG */
				if (dialogBuffer.CanContinue()) {
					var hasMoreDialog = dialogBuffer.Continue();
					if (!hasMoreDialog) {
						// ignore currently held keys UNTIL they are released (stops player from insta-moving)
						isIgnoringInput = true;
						curPlayerDirection = Direction.None;
					}
				}
				else {
					dialogBuffer.Skip();
				}
			}
		}
	}
	else if (isEnding) {
		if (!isAnyButtonHeld && isAnyButtonDown()) {
			// tell game to restart
			isGameOver = true;
		}
	}
	else if (!isIgnoringInput) {
		/* WALK */
		var prevPlayerDirection = curPlayerDirection;

		if (bitsy.button(bitsy.BTN_UP)) {
			curPlayerDirection = Direction.Up;
		}
		else if (bitsy.button(bitsy.BTN_DOWN)) {
			curPlayerDirection = Direction.Down;
		}
		else if (bitsy.button(bitsy.BTN_LEFT)) {
			curPlayerDirection = Direction.Left;
		}
		else if (bitsy.button(bitsy.BTN_RIGHT)) {
			curPlayerDirection = Direction.Right;
		}
		else {
			curPlayerDirection = Direction.None;
		}

		if (curPlayerDirection != Direction.None && curPlayerDirection != prevPlayerDirection) {
			movePlayer(curPlayerDirection, true /* isFirstMove */);
			playerHoldToMoveTimer = 500;
			// playerHoldToMoveTimer = 32; // PERF TEST
		}
	}

	if (!isAnyButtonDown()) {
		isIgnoringInput = false;
	}

	// quit when the user releases the restart button
	// todo : should I rename it bitsy.BTN_RESTART or bitsy.BTN_QUIT or bitsy.BTN_OFF?
	if (isMenuButtonHeld && !bitsy.button(bitsy.BTN_MENU)) {
		isGameOver = true;
	}

	isAnyButtonHeld = isAnyButtonDown();
	isMenuButtonHeld = bitsy.button(bitsy.BTN_MENU);
}

var animationCounter = 0;
var animationTime = 400;
function updateAnimation(dt) {
	animationCounter += dt;
	// bitsy.log("anim " + animationCounter);
	if (animationCounter >= animationTime) {
		// animate sprites
		for (id in sprite) {
			var spr = sprite[id];
			if (spr.animation.isAnimated) {
				spr.animation.frameIndex = (spr.animation.frameIndex + 1) % spr.animation.frameCount;
			}
		}

		// animate tiles
		for (id in tile) {
			var til = tile[id];
			if (til.animation.isAnimated) {
				til.animation.frameIndex = (til.animation.frameIndex + 1) % til.animation.frameCount;
			}
		}

		// animate items
		for (id in item) {
			var itm = item[id];
			if (itm.animation.isAnimated) {
				itm.animation.frameIndex = (itm.animation.frameIndex + 1) % itm.animation.frameCount;
			}
		}

		// reset counter
		animationCounter = 0;

		// updated animations this frame
		return true;
	}

	// did *not* update animations this frame
	return false;
}

function resetAllAnimations() {
	for (id in sprite) {
		var spr = sprite[id];
		if (spr.animation.isAnimated) {
			spr.animation.frameIndex = 0;
		}
	}

	for (id in tile) {
		var til = tile[id];
		if (til.animation.isAnimated) {
			til.animation.frameIndex = 0;
		}
	}

	for (id in item) {
		var itm = item[id];
		if (itm.animation.isAnimated) {
			itm.animation.frameIndex = 0;
		}
	}
}

function getSpriteAt(x, y, roomId) {
	if (roomId === undefined) {
		roomId = state.room;
	}

	for (id in sprite) {
		var spr = sprite[id];
		if (spr.room === roomId) {
			if (spr.x == x && spr.y == y) {
				return id;
			}
		}
	}

	return null;
}

var Direction = {
	None : -1,
	Up : 0,
	Down : 1,
	Left : 2,
	Right : 3
};

var curPlayerDirection = Direction.None;
var playerHoldToMoveTimer = 0;
var playerPrevX = 0;
var playerPrevY = 0;

function movePlayer(direction, isFirstMove) {
	didPlayerMove = false;
	var roomIds = Object.keys(room);

	if (player().room == null || roomIds.indexOf(player().room) < 0) {
		return; // player room is missing or invalid.. can't move them!
	}

	var spr = null;

	if (direction == Direction.Left && !(spr = getSpriteLeft()) && !isWallLeft()) {
		player().x -= 1;
	}
	else if (direction == Direction.Right && !(spr = getSpriteRight()) && !isWallRight()) {
		player().x += 1;
	}
	else if (direction == Direction.Up && !(spr = getSpriteUp()) && !isWallUp()) {
		player().y -= 1;
	}
	else if (direction == Direction.Down && !(spr = getSpriteDown()) && !isWallDown()) {
		player().y += 1;
	}

	var ext = getExit( player().room, player().x, player().y );
	var end = getEnding( player().room, player().x, player().y );
	var itmIndex = getItemIndex( player().room, player().x, player().y );

	// only play one sound effect per "turn"
	var blipId = null;

	// do items first, because you can pick up an item AND go through a door
	if (itmIndex > -1) {
		var itm = room[player().room].items[itmIndex];
		var itemRoom = player().room;

		// play sound on pitck up item
		if (item[itm.id].blip != null) {
			blipId = item[itm.id].blip;
		}

		startItemDialog(itm.id, function() {
			// remove item from room
			room[itemRoom].items.splice(itmIndex, 1);

			// update player inventory
			if (player().inventory[itm.id]) {
				player().inventory[itm.id] += 1;
			}
			else {
				player().inventory[itm.id] = 1;
			}

			// show inventory change in UI
			if (onInventoryChanged != null) {
				onInventoryChanged(itm.id);
			}
		});
	}

	if (end) {
		startEndingDialog(end);
	}
	else if (ext) {
		movePlayerThroughExit(ext);
	}
	else if (spr) {
		// play sound on greet sprite
		if (sprite[spr].blip != null) {
			blipId = sprite[spr].blip;
		}

		startSpriteDialog(spr /*spriteId*/);
	}

	// TODO : maybe add in a future update?
	/*
	// play sound when player moves (if no other sound selected)
	if (isFirstMove && blipId === null && sprite[state.ava].blip != null) {
		blipId = sprite[state.ava].blip;
		randomizeBlip = true;
		blipChannel = bitsy.SOUND2; // play walking sfx *under* the tune melody
	}
	*/

	if (soundPlayer && blipId != null && blip[blipId]) {
		soundPlayer.playBlip(blip[blipId]);
	}
}

var transition;
if (engineFeatureFlags.isTransitionEnabled) {
	transition = new TransitionManager();
}

function movePlayerThroughExit(ext) {
	var GoToDest = function() {
		if (transition && ext.transition_effect != null) {
			transition.BeginTransition(
				player().room,
				player().x,
				player().y,
				ext.dest.room,
				ext.dest.x,
				ext.dest.y,
				ext.transition_effect);

			transition.UpdateTransition(0);

			transition.OnTransitionComplete(function() {
				player().room = ext.dest.room;
				player().x = ext.dest.x;
				player().y = ext.dest.y;
				state.room = ext.dest.room;
				initRoom(state.room);
			});
		}
		else {
			player().room = ext.dest.room;
			player().x = ext.dest.x;
			player().y = ext.dest.y;
			state.room = ext.dest.room;

			initRoom(state.room);
		}
	};

	if (ext.dlg != undefined && ext.dlg != null) {
		// TODO : I need to simplify dialog code,
		// so I don't have to get the ID and the source str
		// every time!
		startDialog(
			dialog[ext.dlg].src,
			ext.dlg,
			function(result) {
				var isLocked = ext.property && ext.property.locked === true;
				if (!isLocked) {
					GoToDest();
				}
			},
			ext);
	}
	else {
		GoToDest();
	}
}

/* PALETTE INDICES */
var backgroundIndex = 0;
var textBackgroundIndex = 1;
var textArrowIndex = 2;
var textColorIndex = 3;

// precalculated rainbow colors
var rainbowColorStartIndex = 4;
var rainbowColorCount = 10;
var rainbowColors = [
	[255,0,0],
	[255,217,0],
	[78,255,0],
	[0,255,125],
	[0,192,255],
	[0,18,255],
	[136,0,255],
	[255,0,242],
	[255,0,138],
	[255,0,61],
];

function updatePaletteWithTileColors(tileColors) {
	// the screen background color should match the first tile color
	if (tileColors.length > 0) {
		var color = tileColors[0];
		bitsy.color(backgroundIndex, color[0], color[1], color[2]);
	}
	else {
		// as a fallback, use black as the background
		bitsy.log("no tile colors!");
		bitsy.color(backgroundIndex, 0, 0, 0);
	}

	// textbox colors
	bitsy.color(textBackgroundIndex, 0, 0, 0); // black
	bitsy.color(textArrowIndex, 255, 255, 255); // white
	bitsy.color(textColorIndex, 255, 255, 255); // white

	// rainbow colors
	for (var i = 0; i < rainbowColorCount; i++) {
		var color = rainbowColors[i];
		bitsy.color(rainbowColorStartIndex + i, color[0], color[1], color[2]);
	}

	// tile colors
	for (var i = 0; i < tileColors.length; i++) {
		var color = tileColors[i];
		bitsy.color(tileColorStartIndex + i, color[0], color[1], color[2]);
	}
}

function updatePalette(palId) {
	state.pal = palId;
	var pal = palette[state.pal];
	updatePaletteWithTileColors(pal.colors);
}

function initRoom(roomId) {
	bitsy.log("init room " + roomId);

	updatePalette(getRoomPal(roomId));

	// update avatar appearance
	state.ava = (room[roomId].ava != null) ? room[roomId].ava : playerId;

	if (renderer) {
		renderer.ClearCache();
	}

	// init exit properties
	state.exits = [];
	for (var i = 0; i < room[roomId].exits.length; i++) {
		var exit = createExitData(
			/* x 			*/ room[roomId].exits[i].x,
			/* y 			*/ room[roomId].exits[i].y,
			/* destRoom 	*/ room[roomId].exits[i].dest.room,
			/* destX 		*/ room[roomId].exits[i].dest.x,
			/* destY 		*/ room[roomId].exits[i].dest.y,
			/* transition 	*/ room[roomId].exits[i].transition_effect,
			/* dlg 			*/ room[roomId].exits[i].dlg);
		exit.property = { locked: false };

		state.exits.push(exit);
	}

	// init ending properties
	state.endings = [];
	for (var i = 0; i < room[roomId].endings.length; i++) {
		var end = createEndingData(
			/* id */ room[roomId].endings[i].id,
			/* x  */ room[roomId].endings[i].x,
			/* y  */ room[roomId].endings[i].y);
		end.property = { locked: false };

		state.endings.push(end);
	}

	if (soundPlayer) {
		if (!room[roomId].tune || room[roomId].tune === "0" || !tune[room[roomId].tune]) {
			// stop music
			state.tune = "0";
			soundPlayer.stopTune();
		}
		else if (room[roomId].tune != state.tune) {
			// start music
			state.tune = room[roomId].tune;
			soundPlayer.playTune(tune[state.tune]);
		}
	}

	var drawArgs = { redrawAll: true };
	drawRoom(room[roomId], drawArgs);

	if (onInitRoom) {
		onInitRoom(roomId);
	}
}

function getItemIndex( roomId, x, y ) {
	for( var i = 0; i < room[roomId].items.length; i++ ) {
		var itm = room[roomId].items[i];
		if ( itm.x == x && itm.y == y)
			return i;
	}
	return -1;
}

function getSpriteLeft() { //repetitive?
	return getSpriteAt( player().x - 1, player().y );
}

function getSpriteRight() {
	return getSpriteAt( player().x + 1, player().y );
}

function getSpriteUp() {
	return getSpriteAt( player().x, player().y - 1 );
}

function getSpriteDown() {
	return getSpriteAt( player().x, player().y + 1 );
}

function isWallLeft() {
	return (player().x - 1 < 0) || isWall( player().x - 1, player().y );
}

function isWallRight() {
	return (player().x + 1 >= bitsy.MAP_SIZE) || isWall(player().x + 1, player().y);
}

function isWallUp() {
	return (player().y - 1 < 0) || isWall( player().x, player().y - 1 );
}

function isWallDown() {
	return (player().y + 1 >= bitsy.MAP_SIZE) || isWall(player().x, player().y + 1);
}

function isWall(x, y, roomId) {
	if (roomId == undefined || roomId == null) {
		roomId = state.room;
	}

	var tileId = getTile(x, y, roomId);
	if (tileId === '0') {
		return false; // Blank spaces aren't walls, ya doofus
	}

	if (tile[tileId].isWall === undefined || tile[tileId].isWall === null) {
		// No wall-state defined: check room-specific walls
		var i = room[roomId].walls.indexOf(getTile(x, y, roomId));
		return (i > -1);
	}

	// Otherwise, use the tile's own wall-state
	return tile[tileId].isWall;
}

function getItem(roomId,x,y) {
	for (i in room[roomId].items) {
		var item = room[roomId].items[i];
		if (x == item.x && y == item.y) {
			return item;
		}
	}
	return null;
}

// todo : roomId isn't useful in these functions anymore! safe to remove?
function getExit(roomId, x, y) {
	for (i in state.exits) {
		var e = state.exits[i];
		if (x == e.x && y == e.y) {
			return e;
		}
	}
	return null;
}

function getEnding(roomId, x, y) {
	for (i in state.endings) {
		var e = state.endings[i];
		if (x == e.x && y == e.y) {
			return e;
		}
	}
	return null;
}

function getTile(x, y, roomId) {
	// bitsy.log(x + " " + y);
	var t = getRoom(roomId).tilemap[y][x];
	return t;
}

function player() {
	return sprite[playerId];
}

// Sort of a hack for legacy palette code (when it was just an array)
function getPal(id) {
	if (palette[id] === undefined) {
		id = "default";
	}

	return palette[ id ].colors;
}

function getRoom(id) {
	return room[id === undefined ? state.room : id];
}

function isSpriteOffstage(id) {
	return sprite[id].room == null;
}

function serializeNote(note, key, useFriendlyName) {
	var isSolfa = (key != undefined && key != null);
	var noteType = (isSolfa === true) ? Solfa : Note;

	if (isSolfa && key.scale.indexOf(note) === -1) {
		// no matching note in key
		return null;
	}

	if (isSolfa && useFriendlyName != true) {
		for (var name in Solfa) {
			if (Solfa[name] === note) {
				return name.toLowerCase();
			}
		}

		// no solfa note found
		return null;
	}

	// for a solfa note's "friendly name" convert to the chromatic equivalent
	if (isSolfa && useFriendlyName === true) {
		note = key.notes[note];
	}

	// from this point on, we know the note we're looking for is chromatic
	for (var name in Note) {
		if (Note[name] === note) {
			name = name.replace("_SHARP", "#");
			if (useFriendlyName === true && name === "H") {
				name = "C";
			}
			return name;
		}
	}

	// no note found
	return symbol;
}

function serializeOctave(octave) {
	for (var symbol in Octave) {
		if (Octave[symbol] === octave) {
			return symbol;
		}
	}

	// default to middle octave
	return "4";
}

//TODO this is in progress and doesn't support all features
function serializeWorld(skipFonts) {
	if (skipFonts === undefined || skipFonts === null) {
		skipFonts = false;
	}

	// update version flags
	flags.VER_MAJ = version.major;
	flags.VER_MIN = version.minor;

	var worldStr = "";
	/* TITLE */
	worldStr += getTitle() + "\n";
	worldStr += "\n";
	/* VERSION */
	worldStr += "# BITSY VERSION " + getEngineVersion() + "\n"; // add version as a comment for debugging purposes
	if (version.devBuildPhase != "RELEASE") {
		worldStr += "# DEVELOPMENT BUILD -- " + version.devBuildPhase;
	}
	worldStr += "\n";
	/* FLAGS */
	for (f in flags) {
		worldStr += "! " + f + " " + flags[f] + "\n";
	}
	worldStr += "\n"
	/* FONT */
	if (fontName != defaultFontName) {
		worldStr += "DEFAULT_FONT " + fontName + "\n";
		worldStr += "\n"
	}
	if (textDirection != TextDirection.LeftToRight) {
		worldStr += "TEXT_DIRECTION " + textDirection + "\n";
		worldStr += "\n"
	}
	/* PALETTE */
	for (id in palette) {
		if (id != "default") {
			worldStr += "PAL " + id + "\n";
			for (i in getPal(id)) {
				for (j in getPal(id)[i]) {
					worldStr += getPal(id)[i][j];
					if (j < 2) worldStr += ",";
				}
				worldStr += "\n";
			}
			if (palette[id].name != null) {
				worldStr += "NAME " + palette[id].name + "\n";
			}
			worldStr += "\n";
		}
	}
	/* ROOM */
	for (id in room) {
		worldStr += "ROOM " + id + "\n";
		if ( flags.ROOM_FORMAT == 0 ) {
			// old non-comma separated format
			for (i in room[id].tilemap) {
				for (j in room[id].tilemap[i]) {
					worldStr += room[id].tilemap[i][j];	
				}
				worldStr += "\n";
			}
		}
		else if ( flags.ROOM_FORMAT == 1 ) {
			// new comma separated format
			for (i in room[id].tilemap) {
				for (j in room[id].tilemap[i]) {
					worldStr += room[id].tilemap[i][j];
					if (j < room[id].tilemap[i].length-1) worldStr += ","
				}
				worldStr += "\n";
			}
		}
		if (room[id].name != null) {
			/* NAME */
			worldStr += "NAME " + room[id].name + "\n";
		}
		if (room[id].walls.length > 0) {
			/* WALLS */
			worldStr += "WAL ";
			for (j in room[id].walls) {
				worldStr += room[id].walls[j];
				if (j < room[id].walls.length-1) {
					worldStr += ",";
				}
			}
			worldStr += "\n";
		}
		if (room[id].items.length > 0) {
			/* ITEMS */
			for (j in room[id].items) {
				var itm = room[id].items[j];
				worldStr += "ITM " + itm.id + " " + itm.x + "," + itm.y;
				worldStr += "\n";
			}
		}
		if (room[id].exits.length > 0) {
			/* EXITS */
			for (j in room[id].exits) {
				var e = room[id].exits[j];
				if ( isExitValid(e) ) {
					worldStr += "EXT " + e.x + "," + e.y + " " + e.dest.room + " " + e.dest.x + "," + e.dest.y;
					if (e.transition_effect != undefined && e.transition_effect != null) {
						worldStr += " FX " + e.transition_effect;
					}
					if (e.dlg != undefined && e.dlg != null) {
						worldStr += " DLG " + e.dlg;
					}
					worldStr += "\n";
				}
			}
		}
		if (room[id].endings.length > 0) {
			/* ENDINGS */
			for (j in room[id].endings) {
				var e = room[id].endings[j];
				// todo isEndingValid
				worldStr += "END " + e.id + " " + e.x + "," + e.y;
				worldStr += "\n";
			}
		}
		if (room[id].pal != null && room[id].pal != "default") {
			/* PALETTE */
			worldStr += "PAL " + room[id].pal + "\n";
		}
		if (room[id].ava != null) {
			/* AVATAR SPRITE */
			worldStr += "AVA " + room[id].ava + "\n";
		}
		if (room[id].tune != null && room[id].tune != "0") {
			/* TUNE */
			worldStr += "TUNE " + room[id].tune + "\n";
		}
		worldStr += "\n";
	}
	/* TILES */
	for (id in tile) {
		worldStr += "TIL " + id + "\n";
		worldStr += serializeDrawing( "TIL_" + id );
		if (tile[id].name != null && tile[id].name != undefined) {
			/* NAME */
			worldStr += "NAME " + tile[id].name + "\n";
		}
		if (tile[id].isWall != null && tile[id].isWall != undefined) {
			/* WALL */
			worldStr += "WAL " + tile[id].isWall + "\n";
		}
		if (tile[id].col != null && tile[id].col != undefined && tile[id].col != 1) {
			/* COLOR OVERRIDE */
			worldStr += "COL " + tile[id].col + "\n";
		}
		if (tile[id].bgc != null && tile[id].bgc != undefined && tile[id].bgc != 0) {
			/* BACKGROUND COLOR OVERRIDE */
			if (tile[id].bgc < 0) {
				// transparent background
				worldStr += "BGC *\n";
			}
			else {
				worldStr += "BGC " + tile[id].bgc + "\n";
			}
		}
		worldStr += "\n";
	}
	/* SPRITES */
	for (id in sprite) {
		worldStr += "SPR " + id + "\n";
		worldStr += serializeDrawing( "SPR_" + id );
		if (sprite[id].name != null && sprite[id].name != undefined) {
			/* NAME */
			worldStr += "NAME " + sprite[id].name + "\n";
		}
		if (sprite[id].dlg != null) {
			worldStr += "DLG " + sprite[id].dlg + "\n";
		}
		if (sprite[id].room != null) {
			/* SPRITE POSITION */
			worldStr += "POS " + sprite[id].room + " " + sprite[id].x + "," + sprite[id].y + "\n";
		}
		if (sprite[id].inventory != null) {
			for(itemId in sprite[id].inventory) {
				worldStr += "ITM " + itemId + " " + sprite[id].inventory[itemId] + "\n";
			}
		}
		if (sprite[id].col != null && sprite[id].col != undefined && sprite[id].col != 2) {
			/* COLOR OVERRIDE */
			worldStr += "COL " + sprite[id].col + "\n";
		}
		if (sprite[id].bgc != null && sprite[id].bgc != undefined && sprite[id].bgc != 0) {
			/* BACKGROUND COLOR OVERRIDE */
			if (sprite[id].bgc < 0) {
				// transparent background
				worldStr += "BGC *\n";
			}
			else {
				worldStr += "BGC " + sprite[id].bgc + "\n";
			}
		}
		if (sprite[id].blip != null && sprite[id].blip != undefined) {
			/* BLIP */
			worldStr += "BLIP " + sprite[id].blip + "\n";
		}
		worldStr += "\n";
	}
	/* ITEMS */
	for (id in item) {
		worldStr += "ITM " + id + "\n";
		worldStr += serializeDrawing( "ITM_" + id );
		if (item[id].name != null && item[id].name != undefined) {
			/* NAME */
			worldStr += "NAME " + item[id].name + "\n";
		}
		if (item[id].dlg != null) {
			worldStr += "DLG " + item[id].dlg + "\n";
		}
		if (item[id].col != null && item[id].col != undefined && item[id].col != 2) {
			/* COLOR OVERRIDE */
			worldStr += "COL " + item[id].col + "\n";
		}
		if (item[id].bgc != null && item[id].bgc != undefined && item[id].bgc != 0) {
			/* BACKGROUND COLOR OVERRIDE */
			if (item[id].bgc < 0) {
				// transparent background
				worldStr += "BGC *\n";
			}
			else {
				worldStr += "BGC " + item[id].bgc + "\n";
			}
		}
		if (item[id].blip != null && item[id].blip != undefined) {
			/* BLIP */
			worldStr += "BLIP " + item[id].blip + "\n";
		}
		worldStr += "\n";
	}
	/* DIALOG */
	for (id in dialog) {
		if (id != titleDialogId) {
			worldStr += "DLG " + id + "\n";
			worldStr += dialog[id].src + "\n";
			if (dialog[id].name != null) {
				worldStr += "NAME " + dialog[id].name + "\n";
			}
			worldStr += "\n";
		}
	}
	/* ENDINGS (for backwards compability only) */
	for (id in end) {
		worldStr += "END " + id + "\n";
		worldStr += end[id].src + "\n";
		worldStr += "\n";
	}
	/* VARIABLES */
	for (id in variable) {
		worldStr += "VAR " + id + "\n";
		worldStr += variable[id] + "\n";
		worldStr += "\n";
	}
	/* TUNES */
	for (id in tune) {
		if (id === "0") {
			continue;
		}

		worldStr += "TUNE " + id + "\n";
		for (var i = 0; i < maxTuneLength && i < tune[id].melody.length; i++) {
			// MELODY
			for (var j = 0; j < barLength; j++) {
				var noteStr = serializeNote(tune[id].melody[i][j].note, tune[id].key);
				if (noteStr === null) {
					tune[id].melody[i][j].beats = 0;
				}
				if (tune[id].melody[i][j].beats != 1) {
					worldStr += tune[id].melody[i][j].beats;
				}
				if (tune[id].melody[i][j].beats > 0) {
					worldStr += noteStr;
				}
				if (tune[id].melody[i][j].beats > 0 && tune[id].melody[i][j].octave != Octave[4]) {
					worldStr += serializeOctave(tune[id].melody[i][j].octave);
				}
				if (tune[id].melody[i][j].beats > 0 && tune[id].melody[i][j].blip != undefined) {
					// todo : create constant for the blip separator?
					worldStr += "~" + tune[id].melody[i][j].blip;
				}
				if (j < 15) {
					worldStr += ",";
				}
			}
			worldStr += "\n";

			// HARMONY
			// todo : lots of copy-pasting - I could probably make some helper functions to simplify this
			for (var j = 0; j < barLength; j++) {
				var noteStr = serializeNote(tune[id].harmony[i][j].note, tune[id].key);
				if (noteStr === null) {
					tune[id].harmony[i][j].beats = 0;
				}
				if (tune[id].harmony[i][j].beats != 1) {
					worldStr += tune[id].harmony[i][j].beats;
				}
				if (tune[id].harmony[i][j].beats > 0) {
					worldStr += noteStr;
				}
				if (tune[id].harmony[i][j].beats > 0 && tune[id].harmony[i][j].octave != Octave[4]) {
					worldStr += serializeOctave(tune[id].harmony[i][j].octave);
				}
				if (tune[id].harmony[i][j].beats > 0 && tune[id].harmony[i][j].blip != undefined) {
					worldStr += "~" + tune[id].harmony[i][j].blip;
				}
				if (j < 15) {
					worldStr += ",";
				}
			}
			worldStr += "\n";

			if (i < (tune[id].melody.length - 1)) {
				worldStr += ">";
				worldStr += "\n";
			}
		}
		if (tune[id].name != null) {
			/* NAME */
			worldStr += "NAME " + tune[id].name + "\n";
		}
		if (tune[id].key != undefined && tune[id].key != null) {
			worldStr += "KEY ";
			for (var i = 0; i < Solfa.COUNT; i++) {
				worldStr += serializeNote(tune[id].key.notes[i]);
				if (i < Solfa.COUNT - 1) {
					worldStr += ",";
				}
			}
			worldStr += " ";
			for (var i = 0; i < tune[id].key.scale.length; i++) {
				worldStr += serializeNote(tune[id].key.scale[i], tune[id].key);
				if (i < tune[id].key.scale.length - 1) {
					worldStr += ",";
				}
			}
			worldStr += "\n";
		}
		worldStr += "TMP ";
		switch (tune[id].tempo) {
			case Tempo.SLW:
				worldStr += "SLW";
				break;
			case Tempo.MED:
				worldStr += "MED";
				break;
			case Tempo.FST:
				worldStr += "FST";
				break;
			case Tempo.XFST:
				worldStr += "XFST";
				break;
		}
		worldStr += "\n";
		worldStr += "SQR ";
		switch (tune[id].instrumentA) {
			case SquareWave.P8:
				worldStr += "P8";
				break;
			case SquareWave.P4:
				worldStr += "P4";
				break;
			case SquareWave.P2:
				worldStr += "P2";
				break;
		}
		worldStr += " ";
		switch (tune[id].instrumentB) {
			case SquareWave.P8:
				worldStr += "P8";
				break;
			case SquareWave.P4:
				worldStr += "P4";
				break;
			case SquareWave.P2:
				worldStr += "P2";
				break;
		}
		worldStr += "\n";
		if (tune[id].key != undefined && tune[id].key != null && tune[id].arpeggioPattern != ArpeggioPattern.OFF) {
			switch (tune[id].arpeggioPattern) {
				case ArpeggioPattern.UP:
					worldStr += "ARP UP\n";
					break;
				case ArpeggioPattern.DWN:
					worldStr += "ARP DWN\n";
					break;
				case ArpeggioPattern.INT5:
					worldStr += "ARP INT5\n";
					break;
				case ArpeggioPattern.INT8:
					worldStr += "ARP INT8\n";
					break;
			}
		}
		worldStr += "\n";
	}
	/* BLIP */
	for (id in blip) {
		if (id === "0") {
			continue;
		}

		worldStr += "BLIP " + id + "\n";
		// pitches
		if (blip[id].pitchA.beats > 0) {
			worldStr += serializeNote(blip[id].pitchA.note);
			if (blip[id].pitchA.octave != Octave[4]) {
				worldStr += serializeOctave(blip[id].pitchA.octave);
			}
		}
		else {
			worldStr += blip[id].pitchA.beats;
		}
		worldStr += ",";
		if (blip[id].pitchB.beats > 0) {
			worldStr += serializeNote(blip[id].pitchB.note);
			if (blip[id].pitchB.octave != Octave[4]) {
				worldStr += serializeOctave(blip[id].pitchB.octave);
			}
		}
		else {
			worldStr += blip[id].pitchB.beats;
		}
		worldStr += ",";
		if (blip[id].pitchC.beats > 0) {
			worldStr += serializeNote(blip[id].pitchC.note);
			if (blip[id].pitchC.octave != Octave[4]) {
				worldStr += serializeOctave(blip[id].pitchC.octave);
			}
		}
		else {
			worldStr += blip[id].pitchC.beats;
		}
		worldStr += "\n";
		if (blip[id].name != null) {
			/* NAME */
			worldStr += "NAME " + blip[id].name + "\n";
		}
		// envelope
		worldStr += "ENV " + blip[id].envelope.attack
			+ " " + blip[id].envelope.decay
			+ " " + blip[id].envelope.sustain
			+ " " + blip[id].envelope.length
			+ " " + blip[id].envelope.release + "\n";
		// beat
		worldStr += "BEAT " + blip[id].beat.time
			+ " " + blip[id].beat.delay + "\n";
		// instrument (square wave type)
		worldStr += "SQR ";
		switch (blip[id].instrument) {
			case SquareWave.P8:
				worldStr += "P8";
				break;
			case SquareWave.P4:
				worldStr += "P4";
				break;
			case SquareWave.P2:
				worldStr += "P2";
				break;
		}
		worldStr += "\n";
		// other parameters
		if (blip[id].doRepeat === true) {
			worldStr += "RPT 1\n";
		}
		// TODO : consider for future update
		// if (blip[id].doSlide === true) {
		// 	worldStr += "SLD 1\n";
		// }
		worldStr += "\n";
	}
	/* FONT */
	// TODO : support multiple fonts
	if (fontManager && fontName != defaultFontName && !skipFonts) {
		worldStr += fontManager.GetData(fontName);
	}

	return worldStr;
}

function serializeDrawing(drwId) {
	if (!renderer) {
		return "";
	}

	var drawingData = renderer.GetDrawingSource(drwId);
	var drwStr = "";
	for (f in drawingData) {
		for (y in drawingData[f]) {
			var rowStr = "";
			for (x in drawingData[f][y]) {
				rowStr += drawingData[f][y][x];
			}
			drwStr += rowStr + "\n";
		}
		if (f < (drawingData.length-1)) drwStr += ">\n";
	}
	return drwStr;
}

function isExitValid(e) {
	var hasValidStartPos = e.x >= 0 && e.x < bitsy.MAP_SIZE && e.y >= 0 && e.y < bitsy.MAP_SIZE;
	var hasDest = e.dest != null;
	var hasValidRoomDest = (e.dest.room != null && e.dest.x >= 0 && e.dest.x < bitsy.MAP_SIZE && e.dest.y >= 0 && e.dest.y < bitsy.MAP_SIZE);
	return hasValidStartPos && hasDest && hasValidRoomDest;
}

function setTile(mapId, x, y, tileId) {
	bitsy.set(mapId, (y * bitsy.MAP_SIZE) + x, tileId);
}

function drawTile(tileId, x, y) {
	setTile(bitsy.MAP1, x, y, tileId);
}

function drawSprite(tileId, x, y) {
	setTile(bitsy.MAP2, x, y, tileId);
}

function drawItem(tileId, x, y) {
	setTile(bitsy.MAP2, x, y, tileId);
}

// var debugLastRoomDrawn = "0";

function clearRoom() {
	var paletteId = "default";

	if (room === undefined) {
		// protect against invalid rooms
		return;
	}

	if (room.pal != null && palette[paletteId] != undefined) {
		paletteId = room.pal;
	}

	// clear background & foreground
	bitsy.fill(bitsy.MAP1, 0);
	bitsy.fill(bitsy.MAP2, 0);
}

function drawRoomBackground(room, frameIndex, redrawAnimatedOnly) {
	if (!redrawAnimatedOnly) {
		// clear background map
		bitsy.fill(bitsy.MAP1, 0);
	}

	// NOTE: interestingly the slowest part of this is iterating over all the tiles, not actually drawing them
	for (var y = 0; y < bitsy.MAP_SIZE; y++) {
		for (var x = 0; x < bitsy.MAP_SIZE; x++) {
			var id = room.tilemap[y][x];

			if (id != "0" && tile[id] == null) { // hack-around to avoid corrupting files (not a solution though!)
				id = "0";
				room.tilemap[y][x] = id;
			}

			if (id != "0" && (!redrawAnimatedOnly || tile[id].animation.isAnimated)) {
				drawTile(getTileFrame(tile[id], frameIndex), x, y);
			}
		}
	}
}

function drawRoomForeground(room, frameIndex, redrawAnimatedOnly) {
	if (!redrawAnimatedOnly) {
		// clear foreground map
		bitsy.fill(bitsy.MAP2, 0);
	}

	// draw items
	for (var i = 0; i < room.items.length; i++) {
		var itm = room.items[i];
		if (!redrawAnimatedOnly || item[itm.id].animation.isAnimated) {
			drawItem(getItemFrame(item[itm.id], frameIndex), itm.x, itm.y);
		}
	}

	// draw sprites
	for (id in sprite) {
		var spr = sprite[id];
		if (id != playerId && spr.room === room.id && (!redrawAnimatedOnly || spr.animation.isAnimated)) {
			drawSprite(getSpriteFrame(spr, frameIndex), spr.x, spr.y);
		}
	}
}

function drawRoomForegroundTile(room, frameIndex, x, y) {
	// draw items
	for (var i = 0; i < room.items.length; i++) {
		var itm = room.items[i];
		if (itm.x === x && itm.y === y) {
			drawItem(getItemFrame(item[itm.id], frameIndex), itm.x, itm.y);
		}
	}

	// draw sprites
	for (id in sprite) {
		var spr = sprite[id];
		if (id != playerId && spr.room === room.id && spr.x === x && spr.y === y) {
			drawSprite(getSpriteFrame(spr, frameIndex), spr.x, spr.y);
		}
	}
}

function drawRoom(room, args) {
	if (room === undefined || isNarrating) {
		// protect against invalid rooms
		return;
	}

	var redrawAll = args && (args.redrawAll === true);
	var redrawAnimated = args && (args.redrawAnimated === true);
	var redrawAvatar = args && (args.redrawAvatar === true);
	var frameIndex = args ? args.frameIndex : undefined;

	// if *only* redrawing the avatar, first clear its previous position
	if (redrawAvatar) {
		setTile(bitsy.MAP2, playerPrevX, playerPrevY, 0);
		// also redraw any sprite or item that might be "under" the player (todo: possible perf issue?)
		drawRoomForegroundTile(room, frameIndex, playerPrevX, playerPrevY);
	}

	// draw background & foreground tiles
	if (redrawAll || redrawAnimated) {
		// draw tiles
		drawRoomBackground(room, frameIndex, redrawAnimated);
		// draw sprites & items
		drawRoomForeground(room, frameIndex, redrawAnimated);
	}

	// draw the player's avatar at its current position
	if ((redrawAll || redrawAnimated || redrawAvatar) && sprite[playerId] && sprite[playerId].room === room.id) {
		var spr = sprite[playerId];
		var x = spr.x;
		var y = spr.y;

		// get the avatar override sprite (if there is one)
		if (state.ava && state.ava != playerId && sprite[state.ava]) {
			spr = sprite[state.ava];
		}

		drawSprite(getSpriteFrame(spr, frameIndex), x, y);
	}
}

// TODO : remove these get*Image methods
function getTileFrame(t, frameIndex) {
	if (!renderer) {
		return null;
	}
	return renderer.GetDrawingFrame(t, frameIndex);
}

function getSpriteFrame(s, frameIndex) {
	if (!renderer) {
		return null;
	}
	return renderer.GetDrawingFrame(s, frameIndex);
}

function getItemFrame(itm, frameIndex) {
	if (!renderer) {
		return null;
	}
	return renderer.GetDrawingFrame(itm, frameIndex);
}

function curDefaultPal() {
	return getRoomPal(state.room);
}

function getRoomPal(roomId) {
	var defaultId = "default";

	if (roomId == null) {
		return defaultId;
	}
	else if (room[roomId].pal != null) {
		//a specific palette was chosen
		return room[roomId].pal;
	}
	else {
		if (roomId in palette) {
			//there is a palette matching the name of the room
			return roomId;
		}
		else {
			//use the default palette
			return defaultId;
		}
	}
	return defaultId;
}

var isDialogMode = false;
var isNarrating = false;
var isEnding = false;

var dialogModule;
var dialogRenderer;
var dialogBuffer;
if (engineFeatureFlags.isDialogEnabled) {
	dialogModule = new Dialog();
	dialogRenderer = dialogModule.CreateRenderer();
	dialogBuffer = dialogModule.CreateBuffer();
}

var fontManager;
if (engineFeatureFlags.isFontEnabled) {
	fontManager = new FontManager();
}

// TODO : is this scriptResult thing being used anywhere???
function onExitDialog(scriptResult, dialogCallback) {
	isDialogMode = false;
	bitsy.textbox(false);

	if (isNarrating) {
		isNarrating = false;

		// redraw the room
		drawRoom(room[state.room], { redrawAll: true });
	}

	if (isDialogPreview) {
		isDialogPreview = false;

		if (onDialogPreviewEnd != null) {
			onDialogPreviewEnd();
		}
	}

	if (dialogCallback != undefined && dialogCallback != null) {
		dialogCallback(scriptResult);
	}

	if (soundPlayer) {
		soundPlayer.resumeTune();
	}
}

/*
TODO
- titles and endings should also take advantage of the script pre-compilation if possible??
- could there be a namespace collision?
- what about dialog NAMEs vs IDs?
- what about a special script block separate from DLG?
*/
function startNarrating(dialogStr, end) {
	bitsy.log("NARRATE " + dialogStr);

	if(end === undefined) {
		end = false;
	}

	isNarrating = true;
	isEnding = end;

	if (isEnding && soundPlayer) {
		soundPlayer.stopTune();
	}

	// clear the room tiles before narrating
	bitsy.fill(bitsy.MAP1, 0);
	bitsy.fill(bitsy.MAP2, 0);

	startDialog(dialogStr);
}

function startEndingDialog(ending) {
	isNarrating = true;
	isEnding = true;

	var endingScriptId = ending.id;
	var endingDialogStr = dialog[ending.id].src;

	// compatibility with pre-7.0 endings
	if (flags.DLG_COMPAT === 1 && end[ending.id]) {
		endingScriptId = "end_compat_" + ending.id;
		endingDialogStr = end[ending.id].src;
	}

	var tmpTuneId = null;
	if (isEnding && soundPlayer) {
		tmpTuneId = soundPlayer.getCurTuneId();
		soundPlayer.stopTune();
	}

	startDialog(
		endingDialogStr,
		endingScriptId,
		function() {
			var isLocked = ending.property && ending.property.locked === true;
			if (isLocked) {
				isEnding = false;

				// if the ending was cancelled, restart the music
				// todo : should it resume from where it started? (right now it starts over)
				if (tmpTuneId && soundPlayer && !soundPlayer.isTunePlaying()) {
					soundPlayer.playTune(tune[tmpTuneId]);
				}
			}
		},
		ending);
}

function startItemDialog(itemId, dialogCallback) {
	var dialogId = item[itemId].dlg;
	// bitsy.log("START ITEM DIALOG " + dialogId);
	if (dialog[dialogId]) {
		var dialogStr = dialog[dialogId].src;
		startDialog(dialogStr, dialogId, dialogCallback);
	}
	else {
		dialogCallback();
	}
}

function startSpriteDialog(spriteId) {
	var spr = sprite[spriteId];
	var dialogId = spr.dlg;

	// back compat for when dialog IDs were implicitly the same as sprite IDs
	if (flags.DLG_COMPAT === 1 && (dialogId === undefined || dialogId === null)) {
		dialogId = spr.id;
	}

	// bitsy.log("START SPRITE DIALOG " + dialogId);
	if (dialog[dialogId]){
		var dialogStr = dialog[dialogId].src;
		startDialog(dialogStr, dialogId);
	}
}

function startDialog(dialogStr, scriptId, dialogCallback, objectContext) {
	bitsy.log("START DIALOG");

	if (soundPlayer) {
		soundPlayer.pauseTune();
	}

	if (dialogStr.length <= 0) {
		onExitDialog(null, dialogCallback);
		return;
	}

	if (!dialogBuffer) {
		bitsy.log(dialogStr);
		onExitDialog(null, dialogCallback);
		return;
	}

	if (!scriptInterpreter) {
		dialogRenderer.Reset();
		dialogRenderer.SetCentered(isNarrating /*centered*/);
		dialogBuffer.Reset();
		dialogBuffer.AddText(dialogStr);
		dialogBuffer.OnDialogEnd(function() {
			onExitDialog(null, dialogCallback);
		});
		bitsy.log("dialog start end");
		return;
	};

	isDialogMode = true;

	dialogRenderer.Reset();
	dialogRenderer.SetCentered(isNarrating /*centered*/);
	dialogBuffer.Reset();
	scriptInterpreter.SetDialogBuffer(dialogBuffer);

	var onScriptEnd = function(scriptResult) {
		dialogBuffer.OnDialogEnd(function() {
			onExitDialog(scriptResult, dialogCallback);
		});
	};

	if (scriptId === undefined) { // TODO : what's this for again?
		scriptInterpreter.Interpret(dialogStr, onScriptEnd);
	}
	else {
		if (!scriptInterpreter.HasScript(scriptId)) {
			scriptInterpreter.Compile(scriptId, dialogStr);
		}
		// scriptInterpreter.DebugVisualizeScript(scriptId);
		scriptInterpreter.Run(scriptId, onScriptEnd, objectContext);
	}

}

var isDialogPreview = false;
function startPreviewDialog(script, dialogCallback) {
	if (!scriptInterpreter || !dialogBuffer) {
		return;
	}

	isNarrating = true;

	isDialogMode = true;

	isDialogPreview = true;

	dialogRenderer.Reset();
	dialogRenderer.SetCentered(true);
	dialogBuffer.Reset();
	scriptInterpreter.SetDialogBuffer(dialogBuffer);

	// TODO : do I really need a seperate callback for this debug mode??
	onDialogPreviewEnd = dialogCallback;

	var onScriptEndCallback = function(scriptResult) {
		dialogBuffer.OnDialogEnd(function() {
			onExitDialog(scriptResult, null);
		});
	};

	scriptInterpreter.Eval(script, onScriptEndCallback);
}

/* NEW SCRIPT STUFF */
var scriptModule;
var scriptInterpreter;
var scriptUtils;
// scriptInterpreter.SetDialogBuffer( dialogBuffer );
if (engineFeatureFlags.isScriptEnabled) {
	bitsy.log("init script module");
	scriptModule = new Script();
	bitsy.log("init interpreter");
	scriptInterpreter = scriptModule.CreateInterpreter();
	bitsy.log("init utils");
	scriptUtils = scriptModule.CreateUtils(); // TODO: move to editor.js?
	bitsy.log("init script module end");
}

/* SOUND */
var soundPlayer;
if (engineFeatureFlags.isSoundEnabled) {
	soundPlayer = new SoundPlayer();
}

/* EVENTS */
bitsy.loop(update);
</script>

<!-- store default font in separate script tag for back compat-->
<script type="text/bitsyFontData" id="ascii_small">
FONT ascii_small
SIZE 6 8
CHAR 0
000000
000000
000000
000000
000000
000000
000000
000000
CHAR 32
000000
000000
000000
000000
000000
000000
000000
000000
CHAR 33
000100
001110
001110
000100
000100
000000
000100
000000
CHAR 34
011011
011011
010010
000000
000000
000000
000000
000000
CHAR 8220
011011
011011
010010
000000
000000
000000
000000
000000
CHAR 8221
011011
011011
010010
000000
000000
000000
000000
000000
CHAR 35
000000
001010
011111
001010
001010
011111
001010
000000
CHAR 36
001000
001110
010000
001100
000010
011100
000100
000000
CHAR 37
011001
011001
000010
000100
001000
010011
010011
000000
CHAR 38
001000
010100
010100
001000
010101
010010
001101
000000
CHAR 39
001100
001100
001000
000000
000000
000000
000000
000000
CHAR 8216
001100
001100
001000
000000
000000
000000
000000
000000
CHAR 8217
001100
001100
001000
000000
000000
000000
000000
000000
CHAR 40
000100
001000
001000
001000
001000
001000
000100
000000
CHAR 41
001000
000100
000100
000100
000100
000100
001000
000000
CHAR 42
000000
001010
001110
011111
001110
001010
000000
000000
CHAR 43
000000
000100
000100
011111
000100
000100
000000
000000
CHAR 44
000000
000000
000000
000000
000000
001100
001100
001000
CHAR 45
000000
000000
000000
011111
000000
000000
000000
000000
CHAR 46
000000
000000
000000
000000
000000
001100
001100
000000
CHAR 47
000000
000001
000010
000100
001000
010000
000000
000000
CHAR 48
001110
010001
010011
010101
011001
010001
001110
000000
CHAR 49
000100
001100
000100
000100
000100
000100
001110
000000
CHAR 50
001110
010001
000001
000110
001000
010000
011111
000000
CHAR 51
001110
010001
000001
001110
000001
010001
001110
000000
CHAR 52
000010
000110
001010
010010
011111
000010
000010
000000
CHAR 53
011111
010000
010000
011110
000001
010001
001110
000000
CHAR 54
000110
001000
010000
011110
010001
010001
001110
000000
CHAR 55
011111
000001
000010
000100
001000
001000
001000
000000
CHAR 56
001110
010001
010001
001110
010001
010001
001110
000000
CHAR 57
001110
010001
010001
001111
000001
000010
001100
000000
CHAR 58
000000
000000
001100
001100
000000
001100
001100
000000
CHAR 59
000000
000000
001100
001100
000000
001100
001100
001000
CHAR 60
000010
000100
001000
010000
001000
000100
000010
000000
CHAR 61
000000
000000
011111
000000
000000
011111
000000
000000
CHAR 62
001000
000100
000010
000001
000010
000100
001000
000000
CHAR 63
001110
010001
000001
000110
000100
000000
000100
000000
CHAR 64
001110
010001
010111
010101
010111
010000
001110
000000
CHAR 65
001110
010001
010001
010001
011111
010001
010001
000000
CHAR 66
011110
010001
010001
011110
010001
010001
011110
000000
CHAR 67
001110
010001
010000
010000
010000
010001
001110
000000
CHAR 68
011110
010001
010001
010001
010001
010001
011110
000000
CHAR 69
011111
010000
010000
011110
010000
010000
011111
000000
CHAR 70
011111
010000
010000
011110
010000
010000
010000
000000
CHAR 71
001110
010001
010000
010111
010001
010001
001111
000000
CHAR 72
010001
010001
010001
011111
010001
010001
010001
000000
CHAR 73
001110
000100
000100
000100
000100
000100
001110
000000
CHAR 74
000001
000001
000001
000001
010001
010001
001110
000000
CHAR 75
010001
010010
010100
011000
010100
010010
010001
000000
CHAR 76
010000
010000
010000
010000
010000
010000
011111
000000
CHAR 77
010001
011011
010101
010001
010001
010001
010001
000000
CHAR 78
010001
011001
010101
010011
010001
010001
010001
000000
CHAR 79
001110
010001
010001
010001
010001
010001
001110
000000
CHAR 80
011110
010001
010001
011110
010000
010000
010000
000000
CHAR 81
001110
010001
010001
010001
010101
010010
001101
000000
CHAR 82
011110
010001
010001
011110
010010
010001
010001
000000
CHAR 83
001110
010001
010000
001110
000001
010001
001110
000000
CHAR 84
011111
000100
000100
000100
000100
000100
000100
000000
CHAR 85
010001
010001
010001
010001
010001
010001
001110
000000
CHAR 86
010001
010001
010001
010001
010001
001010
000100
000000
CHAR 87
010001
010001
010101
010101
010101
010101
001010
000000
CHAR 88
010001
010001
001010
000100
001010
010001
010001
000000
CHAR 89
010001
010001
010001
001010
000100
000100
000100
000000
CHAR 90
011110
000010
000100
001000
010000
010000
011110
000000
CHAR 91
001110
001000
001000
001000
001000
001000
001110
000000
CHAR 92
000000
010000
001000
000100
000010
000001
000000
000000
CHAR 93
001110
000010
000010
000010
000010
000010
001110
000000
CHAR 94
000100
001010
010001
000000
000000
000000
000000
000000
CHAR 95
000000
000000
000000
000000
000000
000000
000000
111111
CHAR 96
001100
001100
000100
000000
000000
000000
000000
000000
CHAR 97
000000
000000
001110
000001
001111
010001
001111
000000
CHAR 98
010000
010000
011110
010001
010001
010001
011110
000000
CHAR 99
000000
000000
001110
010001
010000
010001
001110
000000
CHAR 100
000001
000001
001111
010001
010001
010001
001111
000000
CHAR 101
000000
000000
001110
010001
011110
010000
001110
000000
CHAR 102
000110
001000
001000
011110
001000
001000
001000
000000
CHAR 103
000000
000000
001111
010001
010001
001111
000001
001110
CHAR 104
010000
010000
011100
010010
010010
010010
010010
000000
CHAR 105
000100
000000
000100
000100
000100
000100
000110
000000
CHAR 106
000010
000000
000110
000010
000010
000010
010010
001100
CHAR 107
010000
010000
010010
010100
011000
010100
010010
000000
CHAR 108
000100
000100
000100
000100
000100
000100
000110
000000
CHAR 109
000000
000000
011010
010101
010101
010001
010001
000000
CHAR 110
000000
000000
011100
010010
010010
010010
010010
000000
CHAR 111
000000
000000
001110
010001
010001
010001
001110
000000
CHAR 112
000000
000000
011110
010001
010001
010001
011110
010000
CHAR 113
000000
000000
001111
010001
010001
010001
001111
000001
CHAR 114
000000
000000
010110
001001
001000
001000
011100
000000
CHAR 115
000000
000000
001110
010000
001110
000001
001110
000000
CHAR 116
000000
001000
011110
001000
001000
001010
000100
000000
CHAR 117
000000
000000
010010
010010
010010
010110
001010
000000
CHAR 118
000000
000000
010001
010001
010001
001010
000100
000000
CHAR 119
000000
000000
010001
010001
010101
011111
001010
000000
CHAR 120
000000
000000
010010
010010
001100
010010
010010
000000
CHAR 121
000000
000000
010010
010010
010010
001110
000100
011000
CHAR 122
000000
000000
011110
000010
001100
010000
011110
000000
CHAR 123
000110
001000
001000
011000
001000
001000
000110
000000
CHAR 124
000100
000100
000100
000100
000100
000100
000100
000100
CHAR 125
001100
000010
000010
000011
000010
000010
001100
000000
CHAR 126
000000
000000
000000
001010
010100
000000
000000
000000
CHAR 160
000000
000000
000000
000000
000000
000000
000000
000000
CHAR 161
000100
000000
000100
000100
001110
001110
000100
000000
CHAR 162
000000
000100
001110
010000
010000
001110
000100
000000
CHAR 163
000110
001001
001000
011110
001000
001001
010111
000000
CHAR 165
010001
001010
000100
011111
000100
011111
000100
000000
CHAR 167
001110
010001
001100
001010
000110
010001
001110
000000
CHAR 171
000000
000000
001001
010010
001001
000000
000000
000000
CHAR 172
000000
000000
111111
000001
000001
000000
000000
000000
CHAR 177
000000
000100
001110
000100
000000
001110
000000
000000
CHAR 178
011000
000100
001000
011100
000000
000000
000000
000000
CHAR 181
000000
000000
010010
010010
010010
011100
010000
010000
CHAR 182
001111
010101
010101
001101
000101
000101
000101
000000
CHAR 187
000000
000000
010010
001001
010010
000000
000000
000000
CHAR 188
010000
010010
010100
001011
010101
000111
000001
000000
CHAR 189
010000
010010
010100
001110
010001
000010
000111
000000
CHAR 191
000100
000000
000100
001100
010000
010001
001110
000000
CHAR 196
001010
000000
000100
001010
010001
011111
010001
000000
CHAR 197
001110
001010
001110
011011
010001
011111
010001
000000
CHAR 198
001111
010100
010100
011111
010100
010100
010111
000000
CHAR 199
001110
010001
010000
010000
010001
001110
000100
001100
CHAR 201
000011
000000
011111
010000
011110
010000
011111
000000
CHAR 209
001010
010100
000000
010010
011010
010110
010010
000000
CHAR 214
010010
001100
010010
010010
010010
010010
001100
000000
CHAR 220
001010
000000
010010
010010
010010
010010
001100
000000
CHAR 223
000000
011100
010010
011100
010010
010010
011100
010000
CHAR 224
001100
000000
001110
000001
001111
010001
001111
000000
CHAR 225
000110
000000
001110
000001
001111
010001
001111
000000
CHAR 226
001110
000000
001110
000001
001111
010001
001111
000000
CHAR 228
001010
000000
001110
000001
001111
010001
001111
000000
CHAR 229
001110
001010
001110
000001
001111
010001
001111
000000
CHAR 230
000000
000000
011110
000101
011111
010100
001111
000000
CHAR 231
000000
001110
010001
010000
010001
001110
000100
001100
CHAR 232
001100
000000
001110
010001
011110
010000
001110
000000
CHAR 233
000011
000000
001110
010001
011110
010000
001110
000000
CHAR 234
001110
000000
001110
010001
011110
010000
001110
000000
CHAR 235
001010
000000
001110
010001
011110
010000
001110
000000
CHAR 236
001000
000000
000100
000100
000100
000100
000110
000000
CHAR 237
000110
000000
000100
000100
000100
000100
000110
000000
CHAR 238
000100
001010
000000
000100
000100
000100
000110
000000
CHAR 239
001010
000000
000100
000100
000100
000100
000110
000000
CHAR 241
001010
010100
000000
011100
010010
010010
010010
000000
CHAR 242
011000
000000
001100
010010
010010
010010
001100
000000
CHAR 243
000110
000000
001100
010010
010010
010010
001100
000000
CHAR 244
001110
000000
001100
010010
010010
010010
001100
000000
CHAR 246
001010
000000
001100
010010
010010
010010
001100
000000
CHAR 247
001010
000000
001110
010001
010001
010001
001110
000000
CHAR 249
011000
000000
010010
010010
010010
010110
001010
000000
CHAR 250
000110
000000
010010
010010
010010
010110
001010
000000
CHAR 251
001110
000000
010010
010010
010010
010110
001010
000000
CHAR 252
010010
000000
010010
010010
010010
010110
001010
000000
CHAR 255
001010
000000
010010
010010
010010
001110
000100
011000
CHAR 402
000010
000101
000100
001110
000100
000100
010100
001000
CHAR 915
011110
010010
010000
010000
010000
010000
010000
000000
CHAR 920
001100
010010
010010
011110
010010
010010
001100
000000
CHAR 931
011111
010000
001000
000100
001000
010000
011111
000000
CHAR 934
001110
000100
001110
010001
001110
000100
001110
000000
CHAR 937
000000
001110
010001
010001
001010
001010
011011
000000
CHAR 948
001100
010000
001000
000100
001110
010010
001100
000000
CHAR 949
000000
001110
010000
011110
010000
001110
000000
000000
CHAR 960
000000
011111
001010
001010
001010
001010
001010
000000
CHAR 963
000000
000000
001111
010010
010010
001100
000000
000000
CHAR 964
000000
000000
001010
010100
000100
000100
000100
000000
CHAR 966
000000
000100
001110
010101
010101
001110
000100
000000
CHAR 8226
000000
000000
000000
001100
001100
000000
000000
000000
CHAR 8252
001010
001010
001010
001010
001010
000000
001010
000000
CHAR 8592
000000
000100
001100
011111
001100
000100
000000
000000
CHAR 8593
000100
001110
011111
000100
000100
000100
000100
000000
CHAR 8594
000000
000100
000110
011111
000110
000100
000000
000000
CHAR 8595
000100
000100
000100
000100
011111
001110
000100
000000
CHAR 8734
000000
000000
001010
010101
010101
001010
000000
000000
CHAR 8735
000000
000000
000000
010000
010000
010000
011111
000000
CHAR 8801
000000
011110
000000
011110
000000
011110
000000
000000
CHAR 8804
000010
001100
010000
001100
000010
000000
011110
000000
CHAR 8805
010000
001100
000010
001100
010000
000000
011110
000000
CHAR 8962
000100
001110
011011
010001
010001
011111
000000
000000
CHAR 8976
000000
000000
011111
010000
010000
010000
000000
000000
CHAR 9472
000000
000000
000000
111111
000000
000000
000000
000000
CHAR 9474
000100
000100
000100
000100
000100
000100
000100
000100
CHAR 9488
000000
000000
000000
111100
000100
000100
000100
000100
CHAR 9492
000100
000100
000100
000111
000000
000000
000000
000000
CHAR 9500
000100
000100
000100
000111
000100
000100
000100
000100
CHAR 9508
000100
000100
000100
111100
000100
000100
000100
000100
CHAR 9516
000000
000000
000000
111111
000100
000100
000100
000100
CHAR 9524
000100
000100
000100
111111
000000
000000
000000
000000
CHAR 9532
000100
000100
000100
111111
000100
000100
000100
000100
CHAR 9552
000000
111111
000000
111111
000000
000000
000000
000000
CHAR 9553
010100
010100
010100
010100
010100
010100
010100
010100
CHAR 9556
000000
011111
010000
010111
010100
010100
010100
010100
CHAR 9557
000000
111100
000100
111100
000100
000100
000100
000100
CHAR 9558
000000
000000
000000
111100
010100
010100
010100
010100
CHAR 9559
000000
111100
000100
110100
010100
010100
010100
010100
CHAR 9561
010100
010100
010100
011111
000000
000000
000000
000000
CHAR 9562
010100
010111
010000
011111
000000
000000
000000
000000
CHAR 9563
000100
111100
000100
111100
000000
000000
000000
000000
CHAR 9564
010100
010100
010100
111100
000000
000000
000000
000000
CHAR 9565
010100
110100
000100
111100
000000
000000
000000
000000
CHAR 9566
000100
000111
000100
000111
000100
000100
000100
000100
CHAR 9567
010100
010100
010100
010111
010100
010100
010100
010100
CHAR 9568
010100
010111
010000
010111
010100
010100
010100
010100
CHAR 9569
000000
000000
010010
010010
010010
011100
010000
010000
CHAR 9570
010100
010100
010100
110100
010100
010100
010100
010100
CHAR 9571
010100
110100
000100
110100
010100
010100
010100
010100
CHAR 9572
000000
111111
000000
111111
000100
000100
000100
000100
CHAR 9573
000000
000000
000000
111111
010100
010100
010100
010100
CHAR 9574
000000
111111
000000
110111
010100
010100
010100
010100
CHAR 9575
000100
111111
000000
111111
000000
000000
000000
000000
CHAR 9576
010100
010100
010100
111111
000000
000000
000000
000000
CHAR 9577
010100
110111
000000
111111
000000
000000
000000
000000
CHAR 9580
010100
110111
000000
110111
010100
010100
010100
010100
CHAR 9601
000000
000000
000000
000000
000000
000000
000000
111111
CHAR 9602
000000
000000
000000
000000
000000
000000
111111
111111
CHAR 9603
000000
000000
000000
000000
000000
111111
111111
111111
CHAR 9604
000000
000000
000000
000000
111111
111111
111111
111111
CHAR 9605
000000
000000
000000
111111
111111
111111
111111
111111
CHAR 9606
000000
000000
111111
111111
111111
111111
111111
111111
CHAR 9607
000000
111111
111111
111111
111111
111111
111111
111111
CHAR 9608
111111
111111
111111
111111
111111
111111
111111
111111
CHAR 9609
111100
111100
111100
111100
111100
111100
111100
111100
CHAR 9610
111100
111100
111100
111100
111100
111100
111100
111100
CHAR 9611
111000
111000
111000
111000
111000
111000
111000
111000
CHAR 9613
110000
110000
110000
110000
110000
110000
110000
110000
CHAR 9615
100000
100000
100000
100000
100000
100000
100000
100000
CHAR 9617
010101
000000
101010
000000
010101
000000
101010
000000
CHAR 9618
010101
101010
010101
101010
010101
101010
010101
101010
CHAR 9619
101010
111111
010101
111111
101010
111111
010101
111111
CHAR 9644
000000
000000
000000
000000
000000
011110
011110
000000
CHAR 9650
000100
000100
001110
001110
011111
011111
000000
000000
CHAR 9658
001000
001100
001110
001111
001110
001100
001000
000000
CHAR 9660
011111
011111
001110
001110
000100
000100
000000
000000
CHAR 9668
000010
000110
001110
011110
001110
000110
000010
000000
CHAR 9675
000000
000000
011110
010010
010010
011110
000000
000000
CHAR 9688
111111
111111
111111
110011
110011
111111
111111
111111
CHAR 9689
111111
111111
100001
101101
101101
100001
111111
111111
CHAR 9786
001110
010001
011011
010001
010101
010001
001110
000000
CHAR 9787
001110
011111
010101
011111
010001
011111
001110
000000
CHAR 9788
000000
010101
001110
011011
001110
010101
000000
000000
CHAR 9792
001110
010001
010001
001110
000100
001110
000100
000000
CHAR 9794
000000
000111
000011
001101
010010
010010
001100
000000
CHAR 9824
000000
000100
001110
011111
011111
000100
001110
000000
CHAR 9827
000100
001110
001110
000100
011111
011111
000100
000000
CHAR 9829
000000
001010
011111
011111
011111
001110
000100
000000
CHAR 9830
000000
000100
001110
011111
011111
001110
000100
000000
CHAR 9834
000100
000110
000101
000100
001100
011100
011000
000000
CHAR 9835
000011
001101
001011
001101
001011
011011
011000
000000
</script>

</head>


<!-- DOCUMENT BODY -->
<body onload='startExportedGame()'>
	<!-- GAME CANVAS -->
	<canvas id='game'></canvas>
</body>


</html>